<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>泊客</title>
  
  <subtitle>心之所向</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.dengxf.cn/"/>
  <updated>2019-03-03T08:36:37.519Z</updated>
  <id>https://blog.dengxf.cn/</id>
  
  <author>
    <name>邓旭峰</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>QMQ源码分析之delay-server篇【二】</title>
    <link href="https://blog.dengxf.cn/14f2781.html"/>
    <id>https://blog.dengxf.cn/14f2781.html</id>
    <published>2019-03-02T01:35:59.000Z</published>
    <updated>2019-03-03T08:36:37.519Z</updated>
    
    <content type="html"><![CDATA[<p><a name="df368884"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>本来是固定时间周六更博，但是昨天失恋了，心情不好，晚了一天。那么上一篇我们梳理了下QMQ延迟消息的主要功能，这一篇在此基础上，对照着功能分析一下源码。</p></blockquote><p><a name="74fc4edb"></a></p><h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><p>要了解delay-server源码的一个整体结构，需要我们跟着源码，从初始化开始简单先过一遍。重试化的工作都在startup这个包里，而这个包只有一个ServerWrapper类。<img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1551520273789-e28ea7fb-b86e-4c50-ba21-66bbf9a2f123.png#align=left&amp;display=inline&amp;height=668&amp;name=image.png&amp;originHeight=668&amp;originWidth=1207&amp;size=86215&amp;status=done&amp;width=1207" alt="image.png"><br>结合上一篇的内容，通过这个类就基本能看到delay的一个源码结构。delay-server基于netty，init方法完成初始化工作（端口默认为20801、心跳、wheel等），register方法是向meta-server发起请求，获取自己自己的<code>角色</code>为<code>delay</code>，并开始和meta-server的心跳。startServer方法是开始HashWheel的转动，从上次结束的位置继续message_log的回放，开启netty server。另外在做准备工作时知道QMQ是基于一主一从一备的方式，关于这个sync方法，是开启监听一个端口回应<code>同步拉取</code>动作，如果是从节点还要开始向主节点发起<code>同步拉取</code>动作。当这一切都完成了，那么online方法就执行，表示delay开始上线提供服务了。总结一下两个要点，QMQ是基于netty进行通信，并且采用一主一从一备的方式。<br><a name="a39cf1ca"></a></p><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p>关于存储在之前我们也讨论了，delay-server接收到延迟消息，会顺序append到message_log，之后再对message_log进行回放，以生成schedule_log。所以关于存储我们需要关注两个东西，一个是message_log的存储，另一个是schedule_log的生成。<br><a name="message_log"></a></p><h2 id="message-log"><a href="#message-log" class="headerlink" title="message_log"></a>message_log</h2><p>其实message_log的生成很简单，就是顺序append。主要逻辑在<code>qunar.tc.qmq.delay.receiver.Receiver</code>这个类里，大致流程就是关于QMQ自定义协议的一个反序列化，然后再对序列化的单个消息进行存储。如图：<img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1551598452729-dfd480c5-fa43-4b60-b81a-221e3950acb1.png#align=left&amp;display=inline&amp;height=615&amp;name=image.png&amp;originHeight=615&amp;originWidth=1141&amp;size=114348&amp;status=done&amp;width=1141" alt="image.png"><br>主要逻辑在途中标红方法<code>doInvoke</code>中。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">doInvoke</span><span class="params">(ReceivedDelayMessage message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 注：这里是进行append的地方</span></span><br><span class="line">      ReceivedResult result = facade.appendMessageLog(message);</span><br><span class="line">      offer(message, result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">       <span class="keyword">error</span>(message, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delay存储层相关逻辑都在facade这个类里，初始化时类似消息的校验等工作也都在这里，而message_log的相关操作都在messageLog里。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  <span class="keyword">public</span> AppendMessageRecordResult <span class="keyword">append</span>(RawMessageExtend record) &#123;</span><br><span class="line">      AppendMessageResult&lt;<span class="keyword">Long</span>&gt; result;</span><br><span class="line">      <span class="comment">// 注：当前最新的一个segment</span></span><br><span class="line">      LogSegment segment = logManager.latestSegment();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == segment) &#123;</span><br><span class="line">          segment = logManager.allocNextSegment();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == segment) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageRecordResult(PutMessageStatus.CREATE_MAPPED_FILE_FAILED, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：真正进行append的动作是messageAppender</span></span><br><span class="line">      result = segment.<span class="keyword">append</span>(record, messageAppender);</span><br><span class="line">      <span class="keyword">switch</span> (result.getStatus()) &#123;</span><br><span class="line">          <span class="keyword">case</span> MESSAGE_SIZE_EXCEEDED:</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageRecordResult(PutMessageStatus.MESSAGE_ILLEGAL, <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">case</span> END_OF_FILE:</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">null</span> == logManager.allocNextSegment()) &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageRecordResult(PutMessageStatus.CREATE_MAPPED_FILE_FAILED, <span class="keyword">null</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">append</span>(record);</span><br><span class="line">          <span class="keyword">case</span> SUCCESS:</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageRecordResult(PutMessageStatus.SUCCESS, result);</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageRecordResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 看一下这个appender，也可以通过这里能看到QMQ的delay message 格式定义</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> DelayRawMessageAppender <span class="keyword">implements</span> MessageAppender&lt;RawMessageExtend, <span class="keyword">Long</span>&gt; &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer workingBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      <span class="keyword">public</span> AppendMessageResult&lt;<span class="keyword">Long</span>&gt; doAppend(<span class="keyword">long</span> baseOffset, ByteBuffer targetBuffer, <span class="keyword">int</span> freeSpace, RawMessageExtend message) &#123;</span><br><span class="line">          <span class="comment">// 这个lock这里影响不大</span></span><br><span class="line">          lock.lock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              workingBuffer.clear();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">final</span> String messageId = message.getHeader().getMessageId();</span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">byte</span>[] messageIdBytes = messageId.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">              <span class="keyword">final</span> String subject = message.getHeader().getSubject();</span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">byte</span>[] subjectBytes = subject.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">long</span> startWroteOffset = baseOffset + targetBuffer.position();</span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">int</span> recordSize = recordSizeWithCrc(messageIdBytes.length, subjectBytes.length, message.getBodySize());</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (recordSize &gt; config.getSingleMessageLimitSize()) &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult&lt;&gt;(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED, startWroteOffset, freeSpace, <span class="keyword">null</span>);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              workingBuffer.flip();</span><br><span class="line">              <span class="keyword">if</span> (recordSize != freeSpace &amp;&amp; recordSize + MIN_RECORD_BYTES &gt; freeSpace) &#123;</span><br><span class="line">              <span class="comment">// 填充</span></span><br><span class="line">                  workingBuffer.limit(freeSpace);</span><br><span class="line">                  workingBuffer.putInt(MESSAGE_LOG_MAGIC_V1);</span><br><span class="line">                  workingBuffer.put(MessageLogAttrEnum.ATTR_EMPTY_RECORD.getCode());</span><br><span class="line">                  workingBuffer.putLong(System.currentTimeMillis());</span><br><span class="line">                  targetBuffer.put(workingBuffer.array(), <span class="number">0</span>, freeSpace);</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult&lt;&gt;(AppendMessageStatus.END_OF_FILE, startWroteOffset, freeSpace, <span class="keyword">null</span>);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">int</span> headerSize = recordSize - message.getBodySize();</span><br><span class="line">                  workingBuffer.limit(headerSize);</span><br><span class="line">                  workingBuffer.putInt(MESSAGE_LOG_MAGIC_V2);</span><br><span class="line">                  workingBuffer.put(MessageLogAttrEnum.ATTR_MESSAGE_RECORD.getCode());</span><br><span class="line">                  workingBuffer.putLong(System.currentTimeMillis());</span><br><span class="line">                  <span class="comment">// 注意这里，是schedule_time ，即延迟时间</span></span><br><span class="line">                  workingBuffer.putLong(message.getScheduleTime());</span><br><span class="line">                  <span class="comment">// sequence,每个brokerGroup应该是唯一的</span></span><br><span class="line">                  workingBuffer.putLong(sequence.incrementAndGet());</span><br><span class="line">                  workingBuffer.putInt(messageIdBytes.length);</span><br><span class="line">                  workingBuffer.put(messageIdBytes);</span><br><span class="line">                  workingBuffer.putInt(subjectBytes.length);</span><br><span class="line">                  workingBuffer.put(subjectBytes);</span><br><span class="line">                  workingBuffer.putLong(message.getHeader().getBodyCrc());</span><br><span class="line">                  workingBuffer.putInt(message.getBodySize());</span><br><span class="line">                  targetBuffer.put(workingBuffer.array(), <span class="number">0</span>, headerSize);</span><br><span class="line">                  targetBuffer.put(message.getBody().nioBuffer());</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">final</span> <span class="keyword">long</span> payloadOffset = startWroteOffset + headerSize;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult&lt;&gt;(AppendMessageStatus.SUCCESS, startWroteOffset, recordSize, payloadOffset);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              lock.unlock();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上基本就是message_log的存储部分，接下来我们来看message_log的回放生成schedule_log。<br><a name="schedule_log"></a></p><h2 id="schedule-log"><a href="#schedule-log" class="headerlink" title="schedule_log"></a>schedule_log</h2><p>MessageLogReplayer这个类就是控制回放的地方。那么考虑一个问题，下一次重启的时候，我们该从哪里进行回放？QMQ是会有一个回放的offset，这个offset会定时刷盘，下次重启的时候会从这个offset位置开始回放。细节可以看一下下面这段代码块。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> LogVisitor&lt;LogRecord&gt; visitor = facade.newMessageLogVisitor(iterateFrom.longValue());</span><br><span class="line">adjustOffset(visitor);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> Optional&lt;LogRecord&gt; recordOptional = visitor.nextRecord();</span><br><span class="line">    <span class="keyword">if</span> (recordOptional.isPresent() &amp;&amp; recordOptional.<span class="built_in">get</span>() == DelayMessageLogVisitor.EMPTY_LOG_RECORD) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    recordOptional.ifPresent((record) -&gt; &#123;</span><br><span class="line">    <span class="comment">// post以进行存储</span></span><br><span class="line">        dispatcher.post(record);</span><br><span class="line">        <span class="keyword">long</span> checkpoint = record.getStartWroteOffset() + record.getRecordSize();</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">cursor</span>.addAndGet(record.getRecordSize());</span><br><span class="line">        facade.updateIterateOffset(checkpoint);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">iterateFrom.<span class="built_in">add</span>(visitor.visitedBufferSize());</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    LOGGER.warn(<span class="string">"message log iterate sleep interrupted"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里除了offset还有个cursor，这是为了防止回放失败，sleep 5ms后再次回放的时候从cursor位置开始，避免重复消息。那么我们看一下dispatcher.post这个方法:</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span>(<span class="params">LogRecord <span class="keyword">event</span></span>)</span> &#123;</span><br><span class="line"><span class="comment">// 这里是schedule_log</span></span><br><span class="line">    AppendLogResult&lt;ScheduleIndex&gt; result = facade.appendScheduleLog(<span class="keyword">event</span>);</span><br><span class="line">    <span class="keyword">int</span> code = result.getCode();</span><br><span class="line">    <span class="keyword">if</span> (MessageProducerCode.SUCCESS != code) &#123;</span><br><span class="line">        LOGGER.error(<span class="string">"appendMessageLog schedule log error,log:&#123;&#125; &#123;&#125;,code:&#123;&#125;"</span>, <span class="keyword">event</span>.getSubject(), <span class="keyword">event</span>.getMessageId(), code);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AppendException(<span class="string">"appendScheduleLogError"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先看这里</span></span><br><span class="line">    iterateCallback.apply(result.getAdditional());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如以上代码，我们看略过schedule_log的存储，看一下那个callback是几个意思:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> iterateCallback(<span class="keyword">final</span> ScheduleIndex <span class="keyword">index</span>) &#123;</span><br><span class="line">  <span class="comment">// 延迟时间</span></span><br><span class="line">      <span class="keyword">long</span> scheduleTime = <span class="keyword">index</span>.getScheduleTime();</span><br><span class="line">      <span class="comment">// 这个offset是startOffset,即在delay_segment中的这个消息的起始位置</span></span><br><span class="line">      <span class="keyword">long</span> offset = <span class="keyword">index</span>.getOffset();</span><br><span class="line">      <span class="comment">// 是否add到内存中的HashWheel</span></span><br><span class="line">      <span class="keyword">if</span> (wheelTickManager.canAdd(scheduleTime, offset)) &#123;</span><br><span class="line">          wheelTickManager.addWHeel(<span class="keyword">index</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的意思是，delay-server接收到消息，会判断一下这个消息是否需要add到内存中的wheel中，以防止丢消息。大家记着有这个事情，在投递小节中我们回过头来再说这里。那么回到facade.appendScheduleLog这个方法，schedule_log相关操作在scheduleLog里：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  <span class="keyword">public</span> RecordResult&lt;T&gt; <span class="keyword">append</span>(LogRecord record) &#123;</span><br><span class="line">      <span class="keyword">long</span> scheduleTime = record.getScheduleTime();</span><br><span class="line">      <span class="comment">// 这里是根据延迟时间定位对应的delaySegment的</span></span><br><span class="line">      DelaySegment&lt;T&gt; segment = locateSegment(scheduleTime);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == segment) &#123;</span><br><span class="line">          segment = allocNewSegment(scheduleTime);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == segment) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> NopeRecordResult(PutMessageStatus.CREATE_MAPPED_FILE_FAILED);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体动作在append里</span></span><br><span class="line">      <span class="keyword">return</span> retResult(segment.<span class="keyword">append</span>(record, appender));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>留意locateSegment这个方法，它是根据延迟时间定位DelaySegment，比如如果延迟时间是2019-03-03 16:00:00，那么就会定位到201903031600这个DelaySegment（注：这里贴的代码不是最新的，最新的是DelaySegment的刻度是可以配置，到分钟级别）。同样，具体动作也是appender做的，如下:</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    <span class="keyword">public</span> AppendRecordResult&lt;ScheduleSetSequence&gt; appendLog(LogRecord <span class="built_in">log</span>) &#123;</span><br><span class="line">        workingBuffer.<span class="built_in">clear</span>();</span><br><span class="line">        workingBuffer.flip();</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">byte</span>[] subjectBytes = <span class="built_in">log</span>.getSubject().getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">byte</span>[] messageIdBytes = <span class="built_in">log</span>.getMessageId().getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="built_in">int</span> recordSize = getRecordSize(<span class="built_in">log</span>, subjectBytes.length, messageIdBytes.length);</span><br><span class="line">        workingBuffer.limit(recordSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> scheduleTime = <span class="built_in">log</span>.getScheduleTime();</span><br><span class="line">        <span class="keyword">long</span> sequence = <span class="built_in">log</span>.getSequence();</span><br><span class="line">        workingBuffer.putLong(scheduleTime);</span><br><span class="line">        <span class="comment">// message_log中的sequence</span></span><br><span class="line">        workingBuffer.putLong(sequence);</span><br><span class="line">        workingBuffer.putInt(<span class="built_in">log</span>.getPayloadSize());</span><br><span class="line">        workingBuffer.putInt(messageIdBytes.length);</span><br><span class="line">        workingBuffer.put(messageIdBytes);</span><br><span class="line">        workingBuffer.putInt(subjectBytes.length);</span><br><span class="line">        workingBuffer.put(subjectBytes);</span><br><span class="line">        workingBuffer.put(<span class="built_in">log</span>.getRecord());</span><br><span class="line">        workingBuffer.flip();</span><br><span class="line">        ScheduleSetSequence record = <span class="keyword">new</span> ScheduleSetSequence(scheduleTime, sequence);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendRecordResult&lt;&gt;(AppendMessageStatus.SUCCESS, <span class="number">0</span>, recordSize, workingBuffer, record);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里也能看到schedule_log的消息格式。</p><p><strong>发现就写了个存储篇幅就已经挺大了，投递涉及到的内容可能更多，那么关于投递就开个下一篇吧。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;df368884&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="MQ" scheme="https://blog.dengxf.cn/tags/MQ/"/>
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>QMQ源码分析之delay-server篇【一】</title>
    <link href="https://blog.dengxf.cn/3159cb59.html"/>
    <id>https://blog.dengxf.cn/3159cb59.html</id>
    <published>2019-02-23T01:26:24.000Z</published>
    <updated>2019-03-03T08:36:37.519Z</updated>
    
    <content type="html"><![CDATA[<p><a name="df368884"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>QMQ是一款去哪儿网内部使用多年的mq。不久前(大概1-2年前)已在携程投入生产大规模使用，年前这款mq也开源了出来。关于<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1bmFyY29ycC9xbXE=" title="https://github.com/qunarcorp/qmq">QMQ<i class="fa fa-external-link"></i></span>的相关设计文章可以看<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1bmFyY29ycC9xbXEvdHJlZS9tYXN0ZXIvZG9jcy9jbg==" title="https://github.com/qunarcorp/qmq/tree/master/docs/cn">这里<i class="fa fa-external-link"></i></span>。在这里，我假设你已经对QMQ前世今生以及其设计和实现等背景知识已经有了一个较为全面的认识。</p></blockquote><p><a name="f2aee0d8"></a></p><h2 id="我的阅读姿势"><a href="#我的阅读姿势" class="headerlink" title="我的阅读姿势"></a>我的阅读姿势</h2><p>对一款开源产品愈来愈感兴趣，想要了解一款开源产品更多的技术细节的时候，最好的方式自然是去阅读她的源码。那么一个正确阅读开源软件源码的姿势是什么呢？我觉得这完全就像一个相亲过程：</p><ol><li>媒婆介绍相亲对象基本信息。这一定是前提。很多人都忽视了这一个步骤。在这个步骤中，要去了解这款开源软件是用来做什么的？解决了什么问题？如何解决这些问题的？所处地位？其实就是what,why,how,where四个问题。要是在阅读源码前能准备下这四个问题的答案，那么接下来阅读源码的工作将更有效果。</li><li>见面，喝茶，对媒婆所言一探究竟。这个时候我们要去认识下软件的整体结构，例如，包结构，依赖轻重，主要功能是哪些在哪里等。此外还要去验证下”媒婆所言”是否属实，我们要自己操作运行一下，对这个”姑娘”有一个基础认识。</li><li>约会。有以上基础认识之后，就要深入源码一探究竟。针对各功能点(主要是第一个步骤中谈到的解决的什么问题即why)各条线深入下去，最后贯穿起来，形成一个闭环。</li><li>自由发挥。这个时候就看缘分了，对上眼就成了contributor，对不上眼也能多个朋友多条路不是。</li></ol><p><a name="31762d66"></a></p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>对于delay-server，官方已经有了一些<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvX05XRW1rdTd2UkF1NWNjLW1LRHhLQQ==" title="https://mp.weixin.qq.com/s/_NWEmku7vRAu5cc-mKDxKA">介绍<i class="fa fa-external-link"></i></span>。记住，官方通常是最卖力的那个”媒婆”。qmq-delay-server其实主要做的是转发工作。所谓转发，就是delay-server做的就是个存储和投递的工作。怎么理解，就是qmq-client会对消息进行一个路由，即实时消息投递到实时server，延迟消息往delay-server投递，多说一句，这个路由的功能是由qmq-meta-server提供。投递到delay-server的消息会存下来，到时间之后再进行投递。现在我们知道了<code>存储</code>和<code>投递</code>是delay-server主要的两个功能点。那么我们挨个击破:<br><a name="a39cf1ca"></a></p><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>假如让我们来设计实现一个delay-server，存储部分我们需要解决什么问题？我觉得主要是要解决到期投递的<code>到期</code>问题。我们可以用传统db做，但是这个性能肯定是上不去的。我们也可以用基于LSM树的RocksDB。或者，干脆直接用文件存储。QMQ是用文件存储的。而用文件存储是怎么解决<code>到期</code>问题的呢？delay-server接收到延迟消息，就将消息append到message_log中，然后再通过回放这个message_log得到schedule_log，此外还有一个dispatch _log用于记录投递记录。QMQ还有个跟投递相关的存储设计，即两层HashWheel。第一层位于磁盘上，例如，以一个小时一个刻度一个文件，我们叫delay_message_segment，如延迟时间为2019年02月23日 19:00 至2019年02月23日 20:00为延迟消息将被存储在2019022319。并且这个刻度是可以配置调整的。第二层HashWheel位于内存中。也是以一个时间为刻度，比如500ms，加载进内存中的延迟消息文件会根据延迟时间hash到一个HashWheel中，第二层的wheel涉及更多的是下一小节的<strong>投递</strong>。貌似存储到这里就结束了，然而还有一个问题，目前当投递的时候我们需要将一个delay_message_segment加载进内存中，而假如我们提前一个刻度加载进一个delay_message_segment到内存中的hashwheel，比如在2019年02月23日 18:00加载2019022319这个segment文件，那么一个hashwheel中就会存在两个delay_message_segment，而这个时候所占内存是非常大的，所以这是完全不可接收的。所以，QMQ引入了一个数据结构，叫schedule_index，即消息索引，存储的内容为消息的索引，我们加载到内存的是这个schedule_index，在真正投递的时候再根据索引查到消息体进行投递。<br><a name="31cb9169"></a></p><h4 id="投递"><a href="#投递" class="headerlink" title="投递"></a>投递</h4><p>解决了存储，那么到期的延迟消息如何投递呢？如在上一小节<strong>存储</strong>中所提到的，内存中的hashwheel会提前一段时间加载delay_schedule_index，这个时间自然也是可以配置的。而在hashwheel中，默认每500ms会tick一次，这个500ms也是可以根据用户需求配置的。而在投递的时候，QMQ根据实时broker进行分组多线程投递，如果某一broker离线不可用，导致投递失败，delay-server会将延迟消息投递在其他<code>存活</code>的实时broker。其实这里对于实时的broker应该有一个关于投递消息权重的，现在delay-server没有考虑到这一点，不过我看已经有一个pr解决了这个问题，只是官方还没有时间看这个问题。除此之外，QMQ还考虑到了要是当前延迟消息所属的delay_segment已经加载到内存中的hashwheel了，这个时候消息应该是直接投递或也应加载到hashwheel中的。这里需要考虑的情况还是比较多的，比如考虑delay_segment正在加载、已经加载、加载完成等情况，对于这种情况，QMQ用了两个cursor来表示hashwheel加载到哪个delay_segment以及加载到对应segment的什么offset了，这里还是挺复杂的，这里的代码逻辑在<code>WheelTickManager</code>这个类。</p><hr><p>我们先来看一看整体结构<br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550935854945-5930d1df-0316-4e07-8d51-4f794093200f.png#align=left&amp;display=inline&amp;height=746&amp;name=image.png&amp;originHeight=746&amp;originWidth=1366&amp;size=265433&amp;status=done&amp;width=1366" alt="image.png"><br>以功能划分的包结构，算是比较清晰。cleaner是日志清理工作相关，receiver是接收消息相关，sender是投递相关，store是存储相关，sync是同步备份相关，wheel则是hashwheel相关。</p><p><strong>关于QMQ源码阅读前的准备工作就先做到这里，下一篇我们就深入源码分析以上提到的各个细节。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;df368884&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="MQ" scheme="https://blog.dengxf.cn/tags/MQ/"/>
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>如何科学上网？</title>
    <link href="https://blog.dengxf.cn/8c46c59b.html"/>
    <id>https://blog.dengxf.cn/8c46c59b.html</id>
    <published>2019-02-14T18:54:09.000Z</published>
    <updated>2019-03-03T08:36:37.523Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为了给我们提供一个<code>安全</code>的网络环境，所以先驱前辈们建立了一堵墙。总有些<code>调皮</code> <code>好奇</code>的孩子想要翻过墙去看看墙那边的世界。但是存在风险，需谨慎。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550203371840-7da7ce17-8331-4d90-9a69-0e2e66e5d844.png#align=left&amp;display=inline&amp;height=368&amp;linkTarget=_blank&amp;name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190215120239.png&amp;originHeight=948&amp;originWidth=1920&amp;size=59975&amp;width=746" alt="微信图片_20190215120239.png"><br>共有下面两种方式供选择：</p><h2 id="利用VPN"><a href="#利用VPN" class="headerlink" title="利用VPN"></a>利用VPN</h2><h4 id="免费"><a href="#免费" class="headerlink" title="免费"></a>免费</h4><p>免费的vpn有很多，但是速度、稳定性和流量限制是基本不能满足需要的，所以就不推荐了。</p><h4 id="收费"><a href="#收费" class="headerlink" title="收费"></a>收费</h4><p>收费的vpn一般都在每月10元左右，并且足够稳定。另外，建议大家选择国外的vpn，国内的vpn产商说不定哪天就跑路什么的。在这里，推荐ExpressVPN和PureVPN。前者比较知名，也比较<code>稳健</code>，价格大概在每月$7+；后者也相对比较好用，每月大概在$3+，说是有中国用户的专线。<br>详情可<span class="exturl" data-url="aHR0cHM6Ly93d3cudnBuZGFkYS5jb20vYmVzdC12cG5zLWZvci1jaGluYS1jbi8=" title="https://www.vpndada.com/best-vpns-for-china-cn/">参考<i class="fa fa-external-link"></i></span>。</p><h2 id="自建代理"><a href="#自建代理" class="headerlink" title="自建代理"></a>自建代理</h2><p>喜欢掌握主动权的我，倾向于采用自建代理的方案。综合来看自建代理都是最实惠，最可控的方案。</p><h4 id="购买VPS"><a href="#购买VPS" class="headerlink" title="购买VPS"></a>购买VPS</h4><p>目前VPS产商有两家做的最大，分别是BandwagonHost(搬瓦工)和Vultr。有篇<span class="exturl" data-url="aHR0cHM6Ly9mbHl6eWJsb2cuY29tL2JhbmR3YWdvbmhvc3QtdnVsdHItY29tcGFyaXNvbi8=" title="https://flyzyblog.com/bandwagonhost-vultr-comparison/">文章<i class="fa fa-external-link"></i></span>对比了这两家厂商的产品。<br>购买VPS都是有优惠的，<span class="exturl" data-url="aHR0cDovL2JhbndhZ29uZy5jbi8=" title="http://banwagong.cn/">搬瓦工<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cHM6Ly93d3cudnVsdHJ5aHcuY24v" title="https://www.vultryhw.cn/">Vultr<i class="fa fa-external-link"></i></span>。<br>因为搬瓦工比较老牌，老而弥坚，所以我选择的是它。如果你不喜欢老而弥<code>坚</code>的东西，选择了Vultr，那么请移步看<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3RhY2tjYy5jb20vMjAxOC8xMS8wOC9zc3ItdnBzLw==" title="https://www.stackcc.com/2018/11/08/ssr-vps/">搭建SSR<i class="fa fa-external-link"></i></span>。购买时注意是不是支持中国专线，如果没注意，那么购买成功之后也是可以更改线路的。购买完成，你会受到一封邮件，里边有ip port password等信息，连接上vps，安装完一些基础工具(wget等)，就可以开干了。</p><h4 id="搭建代理"><a href="#搭建代理" class="headerlink" title="搭建代理"></a>搭建代理</h4><p>现在用的最多的就是<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoYWRvd3NvY2tz" title="https://github.com/shadowsocks">shadowsocks<i class="fa fa-external-link"></i></span>，以及其衍生版本<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoYWRvd3NvY2tzci1iYWNrdXA=" title="https://github.com/shadowsocksr-backup">shadowsocks r<i class="fa fa-external-link"></i></span>。我选择的是shadowsockr。这里有个<span class="exturl" data-url="aHR0cHM6Ly9zc3IudG9vbHMv" title="https://ssr.tools/">ssr<i class="fa fa-external-link"></i></span>工具网站，客户端，一键安装脚本在这里都能找到。</p><ol><li>ssh连接上vps</li><li>依次运行下边三条命令：<br></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x shadowsocks-all.sh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure><p><br><br></p><ol><li>接下来按照提示，选择参数安装即可，步骤大概为：<ol><li>选择版本，建议ShadowsocksR</li><li>设置SSR密码</li><li>选择SSR服务器端口</li><li>选择加密方式<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/261134/1550223183058-b27b72ac-027a-4550-8273-f8516e1c1f1b.jpeg#align=left&amp;display=inline&amp;height=290&amp;linkTarget=_blank&amp;name=2018-07-12_154549.jpg&amp;originHeight=290&amp;originWidth=446&amp;size=23089&amp;width=446" alt="2018-07-12_154549.jpg"><br>如这里选择chacha20，输入对应序号12即可。</li><li>选择协议<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/261134/1550223232353-b1c4eea1-8116-4bab-b3ae-366e0c83982d.jpeg#align=left&amp;display=inline&amp;height=230&amp;linkTarget=_blank&amp;name=2018-07-12_154640.jpg&amp;originHeight=230&amp;originWidth=420&amp;size=23545&amp;width=420" alt="2018-07-12_154640.jpg"><br>如这里选择auth_aes128_md5，输入对应序号5即可</li><li>选择混淆方式<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/261134/1550223307214-0422bcaf-06ae-4139-b639-8958cb161b0a.jpeg#align=left&amp;display=inline&amp;height=182&amp;linkTarget=_blank&amp;name=2018-07-12_154714.jpg&amp;originHeight=182&amp;originWidth=392&amp;size=18147&amp;width=392" alt="2018-07-12_154714.jpg"><br>如这里选择http_simple，输入对应序号2即可</li><li>参数设置完成，任意键开始安装，静静等待。</li><li><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/261134/1550223377785-43bafaa1-6fd7-4030-a2a6-030421a377ae.jpeg#align=left&amp;display=inline&amp;height=325&amp;linkTarget=_blank&amp;name=2018-07-12_155328.jpg&amp;originHeight=325&amp;originWidth=644&amp;size=39392&amp;width=644" alt="2018-07-12_155328.jpg"><br>安装完成，你会看到以上信息，记录下来，待会儿会用到。你也可以在下图文件夹下的config.json看到。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550223556002-311135cd-fbdb-4c3c-9bf7-1d7f02b25dc5.png#align=left&amp;display=inline&amp;height=272&amp;linkTarget=_blank&amp;name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190215173855.png&amp;originHeight=272&amp;originWidth=556&amp;size=4809&amp;width=556" alt="微信图片_20190215173855.png"><br><h4 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a>客户端安装</h4><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoYWRvd3NvY2tzcnIvc2hhZG93c29ja3NyLWNzaGFycC9yZWxlYXNlcw==" title="https://github.com/shadowsocksrr/shadowsocksr-csharp/releases">windows<i class="fa fa-external-link"></i></span> 下载<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Fpbnl1aGFuZy9TaGFkb3dzb2Nrc1gtTkctUi9yZWxlYXNlcw==" title="https://github.com/qinyuhang/ShadowsocksX-NG-R/releases">mac<i class="fa fa-external-link"></i></span>下载<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoYWRvd3NvY2tzcnIvc2hhZG93c29ja3NyLWFuZHJvaWQvcmVsZWFzZXM=" title="https://github.com/shadowsocksrr/shadowsocksr-android/releases">andriod<i class="fa fa-external-link"></i></span>下载 或者在应用商城看一下有没有shadowsocks-r(或者ssr)客户端下载<br>ios 免费的App可以用Potatso Lite，不过应该需要<span class="exturl" data-url="aHR0cHM6Ly9zc3IudG9vbHMvMTA0" title="https://ssr.tools/104">申请<i class="fa fa-external-link"></i></span>一下美国AppleID<br>安装完毕，输入安装完毕让你记下的那些信息(在/etc/shadowsocks-r/config.json，或者在刚才安装的目录下找到shadowsocks-all.log文件里也有相关信息)。另外，ssr客户端支持二维码扫描，剪贴板导入等方式，很方便，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550225021512-044ebcee-5e88-4073-b67d-3630d915b71b.png#align=left&amp;display=inline&amp;height=106&amp;linkTarget=_blank&amp;name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190215180301.png&amp;originHeight=106&amp;originWidth=238&amp;size=19155&amp;width=238" alt="微信图片_20190215180301.png"><br>安卓上效果如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550225391948-1810ccd1-1ab2-412f-99a9-0fc3c3dcabb5.png#align=left&amp;display=inline&amp;height=846&amp;linkTarget=_blank&amp;name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190215180933.png&amp;originHeight=846&amp;originWidth=531&amp;size=565850&amp;width=531" alt="微信图片_20190215180933.png"><br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550225391033-e95f0c13-f1be-4b8e-8b21-686736e93f04.png#align=left&amp;display=inline&amp;height=840&amp;linkTarget=_blank&amp;name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190215180822.png&amp;originHeight=840&amp;originWidth=423&amp;size=164845&amp;width=423" alt="微信图片_20190215180822.png"><br>好了，安卓和ios设备现在基本都能上网了。但是pc端还需要一个东西，即chrome的一个插件，<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3dpdGNoeW9tZWdhLmNvbS8=" title="https://www.switchyomega.com/">swithy omega<i class="fa fa-external-link"></i></span>。下载插件添加到chrome完毕，配置如下图：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550225813408-a0996f52-f174-414e-86b0-4587373541ee.png#align=left&amp;display=inline&amp;height=349&amp;linkTarget=_blank&amp;name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190215181638.png&amp;originHeight=899&amp;originWidth=1920&amp;size=74173&amp;width=746" alt="微信图片_20190215181638.png"><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550225813437-708b1d32-c8d5-4df9-99ac-636e21e35f9b.png#align=left&amp;display=inline&amp;height=349&amp;linkTarget=_blank&amp;name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190215181642.png&amp;originHeight=899&amp;originWidth=1920&amp;size=41237&amp;width=746" alt="微信图片_20190215181642.png"></li></ol></li></ol><p>其中的规则列表网址：<span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2dmd2xpc3QvZ2Z3bGlzdC9tYXN0ZXIvZ2Z3bGlzdC50eHQ=" title="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt<i class="fa fa-external-link"></i></span> 详情可以参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dmd2xpc3QvZ2Z3bGlzdA==" title="https://github.com/gfwlist/gfwlist">gfwlist<i class="fa fa-external-link"></i></span></p><p>就是这些，你可以科学上网了。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;为了给我们提供一个&lt;code&gt;安全&lt;/code&gt;的网络环境，所以先驱前辈们建立了一堵墙。总有些&lt;code&gt;调皮&lt;/code&gt;
        
      
    
    </summary>
    
      <category term="工具" scheme="https://blog.dengxf.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="科学上网" scheme="https://blog.dengxf.cn/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>2018年终总结</title>
    <link href="https://blog.dengxf.cn/59ca7e41.html"/>
    <id>https://blog.dengxf.cn/59ca7e41.html</id>
    <published>2018-12-31T08:00:00.000Z</published>
    <updated>2019-03-03T08:36:03.599Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br><strong>又到年底，然而今年并不打算再写年终总结。</strong><br></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p
        
      
    
    </summary>
    
      <category term="生活" scheme="https://blog.dengxf.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="杂谈" scheme="https://blog.dengxf.cn/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
