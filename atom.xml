<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>young driver</title>
  
  <subtitle>小时候想要找一个喜欢《わがまま☆フェアリー ミルモでポン！》的女朋友</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.dengxf.cn/"/>
  <updated>2019-06-27T09:48:04.175Z</updated>
  <id>https://blog.dengxf.cn/</id>
  
  <author>
    <name>邓旭峰</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDK源码阅读之PriorityBlockingQueue</title>
    <link href="https://blog.dengxf.cn/73b74409.html"/>
    <id>https://blog.dengxf.cn/73b74409.html</id>
    <published>2019-06-24T19:40:25.000Z</published>
    <updated>2019-06-27T09:48:04.175Z</updated>
    
    <content type="html"><![CDATA[<p><a name="9676e737"></a></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>An unbounded {@linkpain<a href> </a>java.util.concurrent.BlockingQueue blocking queue} that uses the same ordering rules as class {@link<a href> </a>PriorityQueue} and supplies blocking retrieval operations.</p></blockquote><p>PriorityBlockingQueue,无界优先级阻塞队列。队列中的优先级根据提供的独立的一个 <code>Comparator</code> 接口或者实现 <code>Comparable</code> 接口的队列元素决定。</p><p><a name="a4d3b02a"></a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>优先级队列是基于堆(小顶堆)是实现的。线程安全性由内部声明的一个ReentrantLock保证，即所有的公共操作都是在锁下完成。</p><p><a name="8b1fa850"></a></p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆实际上是一种完全二叉树，分为大顶堆和小顶堆。大顶堆的堆顶的关键字肯定是所有关键字中最大的，小顶堆的堆顶的关键字是所有关键字中最小的。如下图：<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/261134/1561434132526-0c31a6ef-0d33-419e-bacd-403b54b80f80.jpeg#align=left&display=inline&height=409&name=big.jpg&originHeight=409&originWidth=654&size=13431&status=done&width=654" alt="big.jpg"><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/261134/1561434138348-6cd93259-1818-4a25-a526-a0b4b8b8d195.jpeg#align=left&display=inline&height=399&name=small.jpg&originHeight=399&originWidth=658&size=13470&status=done&width=658" alt="small.jpg"></p><p>一般堆都是由数组实现，记一个节点的索引下标为n，那么它的左右孩子为 <code>2n+1</code> 和 <code>2(n+1)</code> 。</p><p><a name="6a0dd2ab"></a></p><h3 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h3><ul><li>private static final int DEFAULT_INITIAL_CAPACITY = 11;   // 默认数组大小</li><li>private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;  // 数组支持最大大小</li><li>private transient Object[] queue; // 存储元素底层数组，以堆的形式</li><li>private transient int size;   // 队列中元素数量</li><li>private transient Comparator&lt;? super E&gt; comparator;   // 用于区分优先级的比较接口</li><li>private final ReentrantLock lock; // 保证线程安全的锁</li><li>private final Condition notEmpty; // lock.condition</li><li>private transient volatile int allocationSpinLock;    // 用于数组扩展时的自旋锁</li></ul><p><a name="088a74e1"></a></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li>public PriorityBlockingQueue();</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a &#123;<span class="doctag">@code</span> PriorityBlockingQueue&#125; with the default</span></span><br><span class="line"><span class="comment">    * initial capacity (11) that orders its elements according to</span></span><br><span class="line"><span class="comment">    * their &#123;<span class="doctag">@linkplain</span> Comparable natural ordering&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>队列默认大小为11</strong><br>**</p><ul><li>public PriorityBlockingQueue(int initialCapacity);</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a &#123;<span class="doctag">@code</span> PriorityBlockingQueue&#125; with the specified</span></span><br><span class="line"><span class="comment">    * initial capacity that orders its elements according to their</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@linkplain</span> Comparable natural ordering&#125;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity the initial capacity for this priority queue</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> initialCapacity&#125; is less</span></span><br><span class="line"><span class="comment">    *         than 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>未传入comparator，则需要队列元素自身实现ComParable接口</strong></p><ul><li>public PriorityBlockingQueue(int initialCapacity,Comparator&lt;? super E&gt; comparator);</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a &#123;<span class="doctag">@code</span> PriorityBlockingQueue&#125; with the specified initial</span></span><br><span class="line"><span class="comment">    * capacity that orders its elements according to the specified</span></span><br><span class="line"><span class="comment">    * comparator.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity the initial capacity for this priority queue</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  comparator the comparator that will be used to order this</span></span><br><span class="line"><span class="comment">    *         priority queue.  If &#123;<span class="doctag">@code</span> null&#125;, the &#123;<span class="doctag">@linkplain</span> Comparable</span></span><br><span class="line"><span class="comment">    *         natural ordering&#125; of the elements will be used.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> initialCapacity&#125; is less</span></span><br><span class="line"><span class="comment">    *         than 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">       <span class="keyword">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">       <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">       <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>public PriorityBlockingQueue(Collection&lt;? extends E&gt; c);</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a &#123;<span class="doctag">@code</span> PriorityBlockingQueue&#125; containing the elements</span></span><br><span class="line"><span class="comment">    * in the specified collection.  If the specified collection is a</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> SortedSet&#125; or a &#123;<span class="doctag">@link</span> PriorityQueue&#125;, this</span></span><br><span class="line"><span class="comment">    * priority queue will be ordered according to the same ordering.</span></span><br><span class="line"><span class="comment">    * Otherwise, this priority queue will be ordered according to the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@linkplain</span> Comparable natural ordering&#125; of its elements.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  c the collection whose elements are to be placed</span></span><br><span class="line"><span class="comment">    *         into this priority queue</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> ClassCastException if elements of the specified collection</span></span><br><span class="line"><span class="comment">    *         cannot be compared to one another according to the priority</span></span><br><span class="line"><span class="comment">    *         queue's ordering</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException if the specified collection or any</span></span><br><span class="line"><span class="comment">    *         of its elements are null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">       <span class="keyword">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">       <span class="keyword">boolean</span> heapify = <span class="keyword">true</span>; <span class="comment">// true if not known to be in heap order</span></span><br><span class="line">       <span class="keyword">boolean</span> screen = <span class="keyword">true</span>;  <span class="comment">// true if must screen for nulls</span></span><br><span class="line">       <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class="line">           SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">           <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) ss.comparator();</span><br><span class="line">           heapify = <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityBlockingQueue&lt;?&gt;) &#123;</span><br><span class="line">           PriorityBlockingQueue&lt;? extends E&gt; pq =</span><br><span class="line">               (PriorityBlockingQueue&lt;? extends E&gt;) c;</span><br><span class="line">           <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) pq.comparator();</span><br><span class="line">           screen = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">if</span> (pq.getClass() == PriorityBlockingQueue.class) <span class="comment">// exact match</span></span><br><span class="line">               heapify = <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       Object[] a = c.toArray();</span><br><span class="line">       <span class="keyword">int</span> n = a.length;</span><br><span class="line">       <span class="comment">// If c.toArray incorrectly doesn't return Object[], copy it.</span></span><br><span class="line">       <span class="keyword">if</span> (a.getClass() != Object[].class)</span><br><span class="line">           a = Arrays.copyOf(a, n, Object[].class);</span><br><span class="line">       <span class="keyword">if</span> (screen &amp;&amp; (n == <span class="number">1</span> || <span class="keyword">this</span>.comparator != <span class="keyword">null</span>)) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">               <span class="keyword">if</span> (a[i] == <span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">this</span>.queue = a;</span><br><span class="line">       <span class="keyword">this</span>.size = n;</span><br><span class="line">       <span class="keyword">if</span> (heapify)</span><br><span class="line">           heapify();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>有必要的话，需要堆化</strong></p><p><a name="8ce750bd"></a></p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>PriorityBlockingQueue的最主要的两个动作时，往队列中放入元素，从队列中取出元素。对应的两个核心的方法时 <code>offer</code> 和 <code>poll</code> 。此外还有在上述其中一个构造方法中，设计到一个堆化的操作，对应的方法时 <code>heapify</code> 。</p><p><a name="heapify"></a></p><h3 id="heapify"><a href="#heapify" class="headerlink" title="heapify"></a>heapify</h3><p>以堆的形式重新组织数组中的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Establishes the heap invariant (described above) in the entire tree,</span></span><br><span class="line"><span class="comment">    * assuming nothing about the order of the elements prior to the call.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Object[] array = queue;</span><br><span class="line">       <span class="keyword">int</span> n = size;</span><br><span class="line">       <span class="comment">// 因为堆的特性，所以，只需要从half位置开始往前搜刮</span></span><br><span class="line">       <span class="keyword">int</span> half = (n &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">       Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">       <span class="keyword">if</span> (cmp == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = half; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">               <span class="comment">// 位置i往后的孩子们不用担心了，已经拍好队了</span></span><br><span class="line">               <span class="comment">// i向下找array[i]的位置</span></span><br><span class="line">               siftDownComparable(i, (E) array[i], array, n);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = half; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">               <span class="comment">// 同理</span></span><br><span class="line">               siftDownUsingComparator(i, (E) array[i], array, n, cmp);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><a name="offer"></a></p><h3 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h3><p>队列是无界的，所以理论上offer永远返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Inserts the specified element into this priority queue.</span></span><br><span class="line"><span class="comment">    * As the queue is unbounded, this method will never return &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Queue#offer&#125;)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> ClassCastException if the specified element cannot be compared</span></span><br><span class="line"><span class="comment">    *         with elements currently in the priority queue according to the</span></span><br><span class="line"><span class="comment">    *         priority queue's ordering</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">int</span> n, cap;</span><br><span class="line">       Object[] array;</span><br><span class="line">       <span class="comment">// size超过了数组大小，就需要扩容了</span></span><br><span class="line">       <span class="keyword">while</span> ((n = size) &gt;= (cap = (array = queue).length))</span><br><span class="line">           tryGrow(array, cap);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">           <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">               <span class="comment">// 从位置n开始往上找到合适e待的位置，被e替换下的元素放在n位置上</span></span><br><span class="line">               siftUpComparable(n, e, array);</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="comment">// 同理</span></span><br><span class="line">               siftUpUsingComparator(n, e, array, cmp);</span><br><span class="line">           <span class="comment">// 容量 +1</span></span><br><span class="line">           size = n + <span class="number">1</span>;</span><br><span class="line">           <span class="comment">// signal 阻塞的get线程</span></span><br><span class="line">           notEmpty.signal();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>扩容的时候有点讲究，见下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tries to grow array to accommodate at least one more element</span></span><br><span class="line"><span class="comment">    * (but normally expand by about 50%), giving up (allowing retry)</span></span><br><span class="line"><span class="comment">    * on contention (which we expect to be rare). Call only while</span></span><br><span class="line"><span class="comment">    * holding lock.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> array the heap array</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> oldCap the length of the array</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryGrow</span><span class="params">(Object[] array, <span class="keyword">int</span> oldCap)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 释放锁，用自旋锁保证安全性</span></span><br><span class="line">       lock.unlock(); <span class="comment">// must release and then re-acquire main lock</span></span><br><span class="line">       Object[] newArray = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (allocationSpinLock == <span class="number">0</span> &amp;&amp;</span><br><span class="line">               <span class="comment">// 扩容时，用自旋锁锁住</span></span><br><span class="line">           UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, allocationSpinLockOffset,</span><br><span class="line">                                    <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 如果当前容量小于64，则每次扩容2，否则往两倍扩</span></span><br><span class="line">               <span class="keyword">int</span> newCap = oldCap + ((oldCap &lt; <span class="number">64</span>) ?</span><br><span class="line">                                      (oldCap + <span class="number">2</span>) : <span class="comment">// grow faster if small</span></span><br><span class="line">                                      (oldCap &gt;&gt; <span class="number">1</span>));</span><br><span class="line">               <span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;    <span class="comment">// possible overflow</span></span><br><span class="line">                   <span class="keyword">int</span> minCap = oldCap + <span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">if</span> (minCap &lt; <span class="number">0</span> || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">                   newCap = MAX_ARRAY_SIZE;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line">                   newArray = <span class="keyword">new</span> Object[newCap];</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               allocationSpinLock = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (newArray == <span class="keyword">null</span>) <span class="comment">// back off if another thread is allocating</span></span><br><span class="line">           Thread.yield();</span><br><span class="line">       <span class="comment">// 重新获取锁</span></span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">if</span> (newArray != <span class="keyword">null</span> &amp;&amp; queue == array) &#123;</span><br><span class="line">           queue = newArray;</span><br><span class="line">           System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, oldCap);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><a name="poll"></a></p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>需要在持有锁的前提下，才能从队列中获取元素。获取元素成功后，原则上堆结构是被_破坏_了，所以需要重新调整堆结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       <span class="comment">// 需要持有锁</span></span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 出队</span></span><br><span class="line">           <span class="keyword">return</span> dequeue();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Mechanics for poll().  Call only while holding lock.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = size - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Object[] array = queue;</span><br><span class="line">           <span class="comment">// 堆顶元素</span></span><br><span class="line">           E result = (E) array[<span class="number">0</span>];</span><br><span class="line">           E x = (E) array[n];</span><br><span class="line">           array[n] = <span class="keyword">null</span>;</span><br><span class="line">           Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">           <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">               <span class="comment">// 调整堆结构，即从位置0往下找x的位置</span></span><br><span class="line">               siftDownComparable(<span class="number">0</span>, x, array, n);</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               siftDownUsingComparator(<span class="number">0</span>, x, array, n, cmp);</span><br><span class="line">           <span class="comment">// size -= 1</span></span><br><span class="line">           size = n;</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><a name="4717902a"></a></p><h3 id="调整堆"><a href="#调整堆" class="headerlink" title="调整堆"></a>调整堆</h3><p>上文提到的调整堆的操作有 <code>siftDownComparable(siftDownUsingComparator)</code> 和 <code>siftUpComparable(siftUpUsingComparator)</code> 。<code>siftDownComparable</code> 和 <code>siftDownUsingComparator</code> 是同一种操作，只是比较元素大小一个是利用元素实现 <code>Comparable</code> 接口，一个是利用构造时传入的 <code>Comparator</code> 。</p><p><a name="siftDownComparable"></a></p><h5 id="siftDownComparable"><a href="#siftDownComparable" class="headerlink" title="siftDownComparable"></a>siftDownComparable</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Inserts item x at position k, maintaining heap invariant by</span></span><br><span class="line"><span class="comment">    * demoting x down the tree repeatedly until it is less than or</span></span><br><span class="line"><span class="comment">    * equal to its children or is a leaf.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> k the position to fill</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> x the item to insert</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> array the heap array</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> n heap size</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;)x;</span><br><span class="line">           <span class="keyword">int</span> half = n &gt;&gt;&gt; <span class="number">1</span>;           <span class="comment">// loop while a non-leaf</span></span><br><span class="line">           <span class="comment">// k &lt; half 只需数组的前半段找</span></span><br><span class="line">           <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">               <span class="comment">// 左孩子 2n+1</span></span><br><span class="line">               <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">               Object c = array[child];</span><br><span class="line">               <span class="comment">// 右孩子 2(n+1)</span></span><br><span class="line">               <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">if</span> (right &lt; n &amp;&amp;</span><br><span class="line">                   ((Comparable&lt;? <span class="keyword">super</span> T&gt;) c).compareTo((T) array[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                   <span class="comment">// 找到最小的孩子</span></span><br><span class="line">                   c = array[child = right];</span><br><span class="line">               <span class="keyword">if</span> (key.compareTo((T) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                   <span class="comment">// 如果key比最小的孩子还小，那么表示key的位置就是这里,break</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="comment">// key应该放在最小的孩子的位置</span></span><br><span class="line">               array[k] = c;</span><br><span class="line">               <span class="comment">// 然后继续找替换掉孩子的位置</span></span><br><span class="line">               k = child;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 这是k应该是父 而key是比k的孩子都小</span></span><br><span class="line">           array[k] = key;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><a name="siftUpComparable"></a></p><h5 id="siftUpComparable"><a href="#siftUpComparable" class="headerlink" title="siftUpComparable"></a>siftUpComparable</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Inserts item x at position k, maintaining heap invariant by</span></span><br><span class="line"><span class="comment">    * promoting x up the tree until it is greater than or equal to</span></span><br><span class="line"><span class="comment">    * its parent, or is the root.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * To simplify and speed up coercions and comparisons. the</span></span><br><span class="line"><span class="comment">    * Comparable and Comparator versions are separated into different</span></span><br><span class="line"><span class="comment">    * methods that are otherwise identical. (Similarly for siftDown.)</span></span><br><span class="line"><span class="comment">    * These methods are static, with heap state as arguments, to</span></span><br><span class="line"><span class="comment">    * simplify use in light of possible comparator exceptions.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> k the position to fill</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> x the item to insert</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> array the heap array</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array)</span> </span>&#123;</span><br><span class="line">       Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;) x;</span><br><span class="line">       <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 父节点</span></span><br><span class="line">           <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">           Object e = array[parent];</span><br><span class="line">           <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">               <span class="comment">// 要是比父节点大，则跳出，表示x应该放在k处</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="comment">// 比父节点小，则顶替父节点</span></span><br><span class="line">           array[k] = e;</span><br><span class="line">           <span class="comment">// 接着网上找父节点的位置</span></span><br><span class="line">           k = parent;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 填充k位置</span></span><br><span class="line">       array[k] = key;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><a name="25f9c7fa"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>优先级队列内部数据结构是一个数组，这个数组是以堆的形式组织的。线程安全性由内部的一个 <code>ReentrantLock</code> 保证，所有对元素的公共操作是需要在持有锁的前提下才能完成。</p><p>出入队后，我们说这个堆结构是被破坏了，所以需要重新调整下这个堆结构。调整堆主要是由两个操作组成：<code>siftUp[Comparable|Comparator]</code> 和 <code>siftDown[Comparable|Comparator]</code> 。分别是从下往上找替换的元素位置，从上往下找替换元素的位置。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;9676e737&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;An unbounded
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JDK" scheme="https://blog.dengxf.cn/tags/JDK/"/>
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读之LinkedTransferQueue</title>
    <link href="https://blog.dengxf.cn/f8a3bd88.html"/>
    <id>https://blog.dengxf.cn/f8a3bd88.html</id>
    <published>2019-06-13T23:58:45.000Z</published>
    <updated>2019-06-27T09:48:04.175Z</updated>
    
    <content type="html"><![CDATA[<p><a name="n9zcO"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><em>An unbounded {</em>*<em>@link *</em><em>java.util.concurrent.TransferQueue} based on linked nodes.This queue orders elements FIFO (first-in-first-out) with respect to any given producer.</em><br>LinkedTransferQueue基于链表实现于TransferQueue接口，是一个遵循FIFO的队列。TransferQueue具有阻塞队列的行为(继承BlockingQueue接口)，并且producer也可以阻塞等待consumer从队列中取出该element消费。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 如果有consumer正在队列阻塞等待获取数据，那么tryTransfer成功，否则失败。</span></span><br><span class="line"><span class="comment">    * 该方法并不会往队列里put元素，而是直接交给等待着的consumer。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * producer阻塞等待直到该element被consumer消费</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 与第一个方法的区别为，会等待上unit.toMillis(timeout)段时间</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 队列中是否有等待的consumer</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasWaitingConsumer</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 有多少个等待着的consumer</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWaitingConsumerCount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedTransferQueue除了有BlockingQueue的行为外，还具有以上行为。<br><a name="YmdPN"></a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>LinkedTransferQueue实现了TransferQueue接口，而TransferQueue又继承自BlockingQueue。<br>众所周知，阻塞队列是生产者往队列放入元素，消费者往队列取出元素进行消费，如果队列无空闲空间/无可用元素则生产者/消费者会相应阻塞。</p><p>一般的阻塞队列，生产者和消费者是互不关心的，即两者完全解耦。正常情况下一般是不会互相阻塞(队列有足够的空间，生产者不会因为队列无空闲空间而阻塞；队列有足够的元素，消费者不会因为队列无元素可取而阻塞)。生产者将元素入队就可以离开了，不关心谁取走了它的元素；消费者将元素取出就可以离开了，不关心谁放的这个元素。但是TransferQueue不是，它的生产者和消费者允许互相阻塞。</p><p>LinkedTransferQueue的算法采用的是一种Dual Queue的变种，Dual Queues with Slack。<br>Dual Queue不仅能存放数据节点，还能存放请求节点。一个数据节点想要入队，这个时候队列里正好有请求节点，此时”匹配”，并移除该请求节点。Blocking Dual Queue入队一个未匹配的请求节点时，会阻塞直到匹配节点入队。Dual Synchronous Queue在Blocking Dual Queue基础上，还会在一个未匹配的数据节点入队时也会阻塞。而Dual Transfer Queue支持以上任何一种模式，具体是哪一种取决于调用者，也就是有不同的api支持。</p><p>FIFO Dual Queue使用的是名叫M&amp;S的一种lock-free算法&lt;(<span class="exturl" data-url="aHR0cDovL3d3dy5jcy5yb2NoZXN0ZXIuZWR1L3Uvc2NvdHQvcGFwZXJzLzE5OTZfUE9EQ19xdWV1ZXMucGRmKSZndDvnmoTlj5jnp43jgII=" title="http://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf)&gt;的变种。">http://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf)&gt;的变种。<i class="fa fa-external-link"></i></span></p><p>M&amp;S算法维护一个”head”指针和一个”tail”指针。head指向一个匹配节点M，M指向第一个未匹配节点(如果未空则指向null)，tail指向未匹配节点。如下<br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1560502635177-d0c0f554-e605-4270-a03a-c6404eedf047.png#align=left&display=inline&height=200&name=image.png&originHeight=247&originWidth=660&size=8423&status=done&width=535" alt="image.png"><br>在Dual Queue内部，由链表组成，对于每个链表节点维护一个match status。在LinkedTransferQueue中为item。对于一个data节点，匹配过程体现在item上就是:non-null -&gt; null，反过来，对于一个request节点，匹配过程就是：null-&gt;non null。Dual Queue的这个match status一经改变，就不会再变更它了。也就是说这个item cas操作过后就不会动了。</p><p>基于此，现在的Dual Queue的组成可能就是在一个分割线前全是M节点，分割线后全是U节点。假设我们不关心时间和空间，入队和出队的过程就是遍历这个链表找到第一个U和最后一个U，这样我们就不会有cas竞争的问题了。</p><p>基于以上的分析，我们就可以有一个这样的tradeoff来减少head tail的cas竞争。如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1560502849977-aaf5419c-bf67-4a43-aa24-761f29ff67ed.png#align=left&display=inline&height=195&name=image.png&originHeight=203&originWidth=716&size=7732&status=done&width=688" alt="image.png"><br>将head和第一个未匹配的节点U之间的距离叫做”slack”，根据一些经验和实验数据发现，slack在1-3之间时工作的更好，所以，LinkedTransferQueue将其定为2。<br><a name="YXpNj"></a></p><h1 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h1><p>关于BlockingQueue的相关行为不做过多解读，主要看继承自TransferQueue的行为。<br><a name="Lkylm"></a></p><h3 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * head of the queue; null until first enqueue</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * tail of the queue; null until first append</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Possible values for "how" argument in xfer method.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NOW = <span class="number">0</span>; <span class="comment">// for untimed poll, tryTransfer</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASYNC = <span class="number">1</span>; <span class="comment">// for offer, put, add</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYNC = <span class="number">2</span>; <span class="comment">// for transfer, take</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMED = <span class="number">3</span>; <span class="comment">// for timed poll, tryTransfer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Node 类结构</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> isData;   <span class="comment">// false if this is a request node</span></span><br><span class="line">       <span class="comment">// 作者解释说item用Object，没用泛型的原因是利于垃圾回收</span></span><br><span class="line">       <span class="comment">// quoto:Uses Object, not E, for items to allow forgetting them after use.</span></span><br><span class="line">       <span class="comment">// 没查到为啥利于垃圾回收</span></span><br><span class="line">       <span class="keyword">volatile</span> Object item;   <span class="comment">// initially non-null if isData; CASed to match</span></span><br><span class="line">       <span class="keyword">volatile</span> Node next;</span><br><span class="line">       <span class="keyword">volatile</span> Thread waiter; <span class="comment">// null until waiting</span></span><br><span class="line">       </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Constructs a new node.  Uses relaxed write because item can</span></span><br><span class="line"><span class="comment">        * only be seen after publication via casNext.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       Node(Object item, <span class="keyword">boolean</span> isData) &#123;</span><br><span class="line">           <span class="comment">// 之所以可以用putObject，是因为item为volatile</span></span><br><span class="line">           <span class="comment">// 其次Node构造是在pred.casNext之后(casNext之后，构造node才算能够可达)</span></span><br><span class="line">           <span class="comment">// 所以可见性是能够保证的</span></span><br><span class="line">           UNSAFE.putObject(<span class="keyword">this</span>, itemOffset, item); <span class="comment">// relaxed write</span></span><br><span class="line">           <span class="keyword">this</span>.isData = isData;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Links node to itself to avoid garbage retention.  Called</span></span><br><span class="line"><span class="comment">        * only after CASing head field, so uses relaxed write.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forgetNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           UNSAFE.putObject(<span class="keyword">this</span>, nextOffset, <span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Sets item to self and waiter to null, to avoid garbage</span></span><br><span class="line"><span class="comment">        * retention after matching or cancelling. Uses relaxed writes</span></span><br><span class="line"><span class="comment">        * because order is already constrained in the only calling</span></span><br><span class="line"><span class="comment">        * contexts: item is forgotten only after volatile/atomic</span></span><br><span class="line"><span class="comment">        * mechanics that extract items.  Similarly, clearing waiter</span></span><br><span class="line"><span class="comment">        * follows either CAS or return from park (if ever parked;</span></span><br><span class="line"><span class="comment">        * else we don't care).</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forgetContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           UNSAFE.putObject(<span class="keyword">this</span>, itemOffset, <span class="keyword">this</span>);</span><br><span class="line">           UNSAFE.putObject(<span class="keyword">this</span>, waiterOffset, <span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Returns true if this node has been matched, including the</span></span><br><span class="line"><span class="comment">        * case of artificial matches due to cancellation.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">// 判断是否该Node是否匹配过</span></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isMatched</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           Object x = item;</span><br><span class="line">           <span class="keyword">return</span> (x == <span class="keyword">this</span>) <span class="comment">// manual cancel</span></span><br><span class="line">                   <span class="comment">// matched</span></span><br><span class="line">                   || ((x == <span class="keyword">null</span>) == isData);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>由以上代码能看到，内部维护的变量相对来说还是比较少的，主要是链表的head 和tail。最下边的四个静态场景是作为xfer方法how参数，以区分不通方法用于不同场景的调用。</p><ul><li><code>NOW</code>  用于poll()、tryTransfer(E e)方法调用</li><li><code>ASYNC</code>   用于offset()、put()、add()方法调用 </li><li><code>SYNC</code>  用于transfer()、take()方法调用</li><li><code>TIMED</code> 用于poll(long timeout,TimeUnit unit)、tryTransfer(E e,long timeout,TimeUnit unit)方法调用</li></ul><p><a name="8uolh"></a></p><h3 id="行为分析"><a href="#行为分析" class="headerlink" title="行为分析"></a>行为分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 通过xfer方法实现，同步不同的参数来区分不同的场景。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * producer，要是有等待的consumer成功，否则失败</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> xfer(e, <span class="keyword">true</span>, NOW, <span class="number">0</span>) == <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * producer，失败会interrupt,并抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (xfer(e, <span class="keyword">true</span>, SYNC, <span class="number">0</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Thread.interrupted(); <span class="comment">// failure possible only due to interrupt</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * producer,在timeout时间内，成功，否则</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (xfer(e, <span class="keyword">true</span>, TIMED, unit.toNanos(timeout)) == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (!Thread.interrupted())</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * consumer，在unit.toNanos(timeout)时间内成功，否则会抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       E e = xfer(<span class="keyword">null</span>, <span class="keyword">false</span>, TIMED, unit.toNanos(timeout));</span><br><span class="line">       <span class="keyword">if</span> (e != <span class="keyword">null</span> || !Thread.interrupted())</span><br><span class="line">           <span class="keyword">return</span> e;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * consumer,队列有即返回，否则null，不会阻塞等待</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> xfer(<span class="keyword">null</span>, <span class="keyword">false</span>, NOW, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * consumer,阻塞等待直到队列有元素(producer)可取</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       E e = xfer(<span class="keyword">null</span>, <span class="keyword">false</span>, SYNC, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> e;</span><br><span class="line">       Thread.interrupted();</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 队列中是否有等待的consuemr</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasWaitingConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> firstOfMode(<span class="keyword">false</span>) != <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 队列中等待的consumer总数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWaitingConsumerCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> countOfMode(<span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>以上是主要我们要分析的行为，可以看见，出来 <code>hasWaitingConsumer</code> 和 <code>getWaitingConsumerCount</code> ，其他对队列操作元素的方法，都是通过xfer方法实现的。<br>先看 <code>hasWaitingConsumer</code> 和 <code>getWaitingConsumerCount</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasWaitingConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> firstOfMode(<span class="keyword">false</span>) != <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the first unmatched node of the given mode, or null if</span></span><br><span class="line"><span class="comment">    * none.  Used by methods isEmpty, hasWaitingConsumer.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">firstOfMode</span><span class="params">(<span class="keyword">boolean</span> isData)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Node p = head; p != <span class="keyword">null</span>; p = succ(p)) &#123;</span><br><span class="line">           <span class="comment">// p.isMatched:</span></span><br><span class="line">           <span class="comment">// return (item == this) || ((x == null) == isData);</span></span><br><span class="line">           <span class="comment">// item == this 表示手动取消</span></span><br><span class="line">           <span class="comment">// ((x == null) == isData) 表示已匹配</span></span><br><span class="line">           <span class="keyword">if</span> (!p.isMatched())</span><br><span class="line">               <span class="comment">// 注意，队列里，未匹配的所有节点一定都是同一种类型的节点</span></span><br><span class="line">               <span class="comment">// p是队列中第一个未匹配的节点</span></span><br><span class="line">               <span class="comment">// 无非分两种情况分析：isData为true 和false</span></span><br><span class="line">               <span class="comment">// 1.true 如果p.isData == isData ，那么p为producer，那么返回当前节点，否则返回null。</span></span><br><span class="line">               <span class="comment">// 2.false 如果p.isData == isData,那么p为consumer....</span></span><br><span class="line">               <span class="keyword">return</span> (p.isData == isData) ? p : <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the successor of p, or the head node if p.next has been</span></span><br><span class="line"><span class="comment">    * linked to self, which will only be true if traversing with a</span></span><br><span class="line"><span class="comment">    * stale pointer that is now off the list.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> Node <span class="title">succ</span><span class="params">(Node p)</span> </span>&#123;</span><br><span class="line">       Node next = p.next;</span><br><span class="line">       <span class="keyword">return</span> (p == next) ? head : next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWaitingConsumerCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> countOfMode(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Traverses and counts unmatched nodes of the given mode.</span></span><br><span class="line"><span class="comment"> * Used by methods size and getWaitingConsumerCount.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countOfMode</span><span class="params">(<span class="keyword">boolean</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node p = head; p != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        <span class="comment">// p.isMatched:</span></span><br><span class="line">        <span class="comment">// return (item == this) || ((x == null) == isData);</span></span><br><span class="line">        <span class="comment">// item == this 表示手动取消</span></span><br><span class="line">        <span class="comment">// ((x == null) == isData) 表示已匹配</span></span><br><span class="line">        <span class="keyword">if</span> (!p.isMatched()) &#123;</span><br><span class="line">            <span class="comment">// 如果不等，那么后面的节点就不能有p.isData类型的节点了。</span></span><br><span class="line">            <span class="keyword">if</span> (p.isData != data)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (++count == Integer.MAX_VALUE) <span class="comment">// saturated</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node n = p.next;</span><br><span class="line">        <span class="keyword">if</span> (n != p)</span><br><span class="line">            p = n;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            p = head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两个方法还是挺清晰的，主要是要注意一个地方，就是第一个未匹配节点的类型，决定了后边未匹配节点的类型。<br>接下来看看 <code>xfer</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">xfer</span><span class="params">(E e, <span class="keyword">boolean</span> haveData, <span class="keyword">int</span> how, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不允许，说自己有货，口袋确实空的，这谁都顶不住的</span></span><br><span class="line">    <span class="keyword">if</span> (haveData &amp;&amp; (e == <span class="keyword">null</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node s = <span class="keyword">null</span>;                        <span class="comment">// the node to append, if needed</span></span><br><span class="line"></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;                            <span class="comment">// restart on append race</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Node h = head, p = h; p != <span class="keyword">null</span>; ) &#123; <span class="comment">// find &amp; match first node</span></span><br><span class="line">            <span class="keyword">boolean</span> isData = p.isData;</span><br><span class="line">            Object item = p.item;</span><br><span class="line">            <span class="comment">// 未匹配过</span></span><br><span class="line">            <span class="comment">// 如果p.item == p || (p.item == null) == p.isData 则已匹配 p.item == p cancel的情况</span></span><br><span class="line">            <span class="comment">// match consumer:p.item -&gt; itself producer:p.item-&gt;null</span></span><br><span class="line">            <span class="keyword">if</span> (item != p &amp;&amp; (item != <span class="keyword">null</span>) == isData) &#123; <span class="comment">// unmatched</span></span><br><span class="line">                <span class="comment">// 同类型,则break，在下一个循环里进行入队操作</span></span><br><span class="line">                <span class="keyword">if</span> (isData == haveData)   <span class="comment">// can't match</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// match 过程:</span></span><br><span class="line">                <span class="comment">// consumer:p.item -&gt; data; producer:p.item -&gt; null</span></span><br><span class="line">                <span class="comment">// 试图匹配，item-&gt;e</span></span><br><span class="line">                <span class="keyword">if</span> (p.casItem(item, e)) &#123; <span class="comment">// match</span></span><br><span class="line">                    <span class="keyword">for</span> (Node q = p; q != h; ) &#123;</span><br><span class="line">                        Node n = q.next;  <span class="comment">// update by 2 unless singleton</span></span><br><span class="line">                        <span class="comment">// 移动head，如果q.next == null 则head-&gt;q，否则head-&gt;n</span></span><br><span class="line">                        <span class="keyword">if</span> (head == h &amp;&amp; casHead(h, n == <span class="keyword">null</span> ? q : n)) &#123;</span><br><span class="line">                            <span class="comment">// 更新head成功，将其next指针指向自己，以作清理</span></span><br><span class="line">                            h.forgetNext();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;                 <span class="comment">// advance and retry</span></span><br><span class="line">                        <span class="comment">// 失败：1.head改变；2.cas竞争失败。总之就是有其他线程已经移动了head</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> ((h = head) == <span class="keyword">null</span> ||</span><br><span class="line">                                <span class="comment">// 即 slack &gt;= 2,需要重试，以调整slack的值在[0,2)范围内</span></span><br><span class="line">                                (q = h.next) == <span class="keyword">null</span> || !q.isMatched())</span><br><span class="line">                            <span class="keyword">break</span>;        <span class="comment">// unless slack &lt; 2</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    LockSupport.unpark(p.waiter);</span><br><span class="line">                    <span class="keyword">return</span> LinkedTransferQueue.&lt;E&gt;cast(item);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 失败了，已经有其他线程捷足先登，重试</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 前边都是匹配过的节点，接着往后找</span></span><br><span class="line">            Node n = p.next;</span><br><span class="line">            p = (p != n) ? n : (h = head); <span class="comment">// Use head if p offlist</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当how == NOW时，匹配失败立即返回，不会入队</span></span><br><span class="line">        <span class="keyword">if</span> (how != NOW) &#123;                 <span class="comment">// No matches available</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                s = <span class="keyword">new</span> Node(e, haveData);</span><br><span class="line">            Node pred = tryAppend(s, haveData);</span><br><span class="line">            <span class="comment">// 当pred == null时，表示当前队列的"分割线"后节点的mode，已经时过境迁了。</span></span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span> retry;           <span class="comment">// lost race vs opposite mode</span></span><br><span class="line">            <span class="comment">// how != ASYNC  需要阻塞等待</span></span><br><span class="line">            <span class="keyword">if</span> (how != ASYNC)</span><br><span class="line">                <span class="keyword">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e; <span class="comment">// not waiting</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">tryAppend</span><span class="params">(Node s, <span class="keyword">boolean</span> haveData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node t = tail, p = t; ; ) &#123;        <span class="comment">// move p to last node and append</span></span><br><span class="line">        Node n, u;                        <span class="comment">// temps for reads of next &amp; tail</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; (p = head) == <span class="keyword">null</span>) &#123;  <span class="comment">// 队列为空</span></span><br><span class="line">            <span class="comment">// head并不需要dummy node</span></span><br><span class="line">            <span class="keyword">if</span> (casHead(<span class="keyword">null</span>, s))</span><br><span class="line">                <span class="keyword">return</span> s;                 <span class="comment">// initialize</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.cannotPrecede(haveData))</span><br><span class="line">            <span class="comment">// haveData mode的节点s并不能成为p的后继</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;                  <span class="comment">// lost race vs opposite mode</span></span><br><span class="line">        <span class="comment">// tail并不是"tail",继续向后</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((n = p.next) != <span class="keyword">null</span>)    <span class="comment">// not last; keep traversing</span></span><br><span class="line">            p = p != t &amp;&amp; t != (u = tail) ? (t = u) : <span class="comment">// stale tail</span></span><br><span class="line">                    (p != n) ? n : <span class="keyword">null</span>;      <span class="comment">// restart if off list</span></span><br><span class="line">        <span class="comment">// cas失败，已经有其他线程已经先行cas成功</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!p.casNext(<span class="keyword">null</span>, s))</span><br><span class="line">            p = p.next;                   <span class="comment">// re-read on CAS failure</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// tail后还有其他节点</span></span><br><span class="line">            <span class="keyword">if</span> (p != t) &#123;                 <span class="comment">// update if slack now &gt;= 2</span></span><br><span class="line">                <span class="keyword">while</span> ((tail != t || !casTail(t, s)) &amp;&amp;   <span class="comment">// tail已经改变或者移动tail失败</span></span><br><span class="line">                        (t = tail) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        <span class="comment">// (s = t.next) != null &amp;&amp; (s = s.next) != null means slack &gt;= 2</span></span><br><span class="line">                        (s = t.next) != <span class="keyword">null</span> &amp;&amp; <span class="comment">// advance and retry</span></span><br><span class="line">                        (s = s.next) != <span class="keyword">null</span> &amp;&amp; s != t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">awaitMatch</span><span class="params">(Node s, Node pred, E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// how = timed == false ? SYNC : TIMED</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    Thread w = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> spins = -<span class="number">1</span>; <span class="comment">// initialized after first item and cancel checks</span></span><br><span class="line">    java.util.concurrent.ThreadLocalRandom randomYields = <span class="keyword">null</span>; <span class="comment">// bound if needed</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        Object item = s.item;</span><br><span class="line">        <span class="keyword">if</span> (item != e) &#123;                  <span class="comment">// matched</span></span><br><span class="line">            <span class="comment">// assert item != s;</span></span><br><span class="line">            s.forgetContents();           <span class="comment">// avoid garbage</span></span><br><span class="line">            <span class="comment">// 匹配完成</span></span><br><span class="line">            <span class="keyword">return</span> LinkedTransferQueue.&lt;E&gt;cast(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((w.isInterrupted() || (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)) &amp;&amp;</span><br><span class="line">                s.casItem(e, s)) &#123;        <span class="comment">// cancel</span></span><br><span class="line">            <span class="comment">// 这里 mark sweep</span></span><br><span class="line">            unsplice(pred, s);</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">if</span> (spins &lt; <span class="number">0</span>) &#123;                  <span class="comment">// establish spins at/near front</span></span><br><span class="line">            <span class="keyword">if</span> ((spins = spinsFor(pred, s.isData)) &gt; <span class="number">0</span>)</span><br><span class="line">                randomYields = ThreadLocalRandom.current();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;             <span class="comment">// spin</span></span><br><span class="line">            --spins;</span><br><span class="line">            <span class="keyword">if</span> (randomYields.nextInt(CHAINED_SPINS) == <span class="number">0</span>)</span><br><span class="line">                Thread.yield();           <span class="comment">// occasionally yield</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.waiter = w;                 <span class="comment">// request unpark then recheck</span></span><br><span class="line">        <span class="comment">// 阻塞等待，等待唤醒  </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合xfer注释，对照着前边的几个操作队列元素的方法，多理解即便，效果更佳。<br><a name="n8Lgq"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>内部采用了Dual Stack With Slack的结构，slack根据实践数据采用了slack=2</li><li>操作队列的元素的各个方法通过xfer方法实现，具体是根据不同的how参数来区分不同场景</li><li>对于一个data节点，匹配过程体现在item上就是:non-null -&gt; null，反过来，对于一个request节点，匹配过程就是：null-&gt;non null。</li><li>一个可阻塞的节点入队时，如果队列中有等待可匹配的节点，则匹配并移除该节点，否则，入队自旋等待或阻塞等待直至匹配成功或唤醒。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;n9zcO&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;An unbounded
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JDK" scheme="https://blog.dengxf.cn/tags/JDK/"/>
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读之SynchronousQueue</title>
    <link href="https://blog.dengxf.cn/157f68af.html"/>
    <id>https://blog.dengxf.cn/157f68af.html</id>
    <published>2019-05-26T00:51:04.000Z</published>
    <updated>2019-06-27T09:48:04.179Z</updated>
    
    <content type="html"><![CDATA[<p><a name="5nF7T"></a></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>根据源码总的描述，SynchronousQueue是一个阻塞队列，所有的入队出队操作都是阻塞的。根据作者的描述，这个工具的定位是在线程间同步对象，以达到在线程间传递一些信息、事件、或者任务的目的(_They are well suited for handoff designs, in which an object running in one thread must sync up with an object running in another thread in order to hand it some information, event, or )。<br>关于这个工具的描述，作者只介绍了这么多。SynchronousQueue是实现了BlockingQueue，但是有与一般意义上的queue(比如ArrayBlockingQueue)不一样，它内部并没有存放元素的地方。入队阻塞直到出队成功，反之亦然，在线程间同步传递对象，以在线程间同步信息。</p></blockquote><p><a name="zbM2O"></a></p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>SynchronousQueue内部并没有容纳元素的数据结构，也就是说SynchronousQueue并不存储元素。实现采用了一种无锁算法，扩展的<span class="exturl" data-url="aHR0cDovL3d3dy5jcy5yb2NoZXN0ZXIuZWR1L3Jlc2VhcmNoL3N5bmNocm9uaXphdGlvbi9wc2V1ZG9jb2RlL2R1YWxzLmh0bWw=" title="http://www.cs.rochester.edu/research/synchronization/pseudocode/duals.html">Dual stack and Dual Queue<i class="fa fa-external-link"></i></span>算法，算法的大概实现是采用链表，用头结点(head)和尾结点(tail)记录队列状态，而队列可以根据头尾以及当前节点状态，在不需要锁的情况的执行入出队操作。此外，竞争时，支持公平竞争和非公平竞争。公平竞争实现采用先进先出队列( FIFO queue)；而非公平竞争实现采用先进后出栈(FILO stack)。<br><a name="uuBx9"></a></p><h3 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** The number of CPUs, for spin control */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPUS = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxTimedSpins = (NCPUS &lt; <span class="number">2</span>) ? <span class="number">0</span> : <span class="number">32</span></span><br><span class="line">     </span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxUntimedSpins = maxTimedSpins * <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The number of nanoseconds for which it is faster to spin</span></span><br><span class="line"><span class="comment">  * rather than to use timed park. A rough estimate suffices.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;   </span><br><span class="line">     <span class="comment">/** Node represents an unfulfilled consumer */</span></span><br><span class="line">     <span class="comment">// 表示consumer，获取元素的请求</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST    = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">/** Node represents an unfulfilled producer */</span></span><br><span class="line">     <span class="comment">// 表示producer，插入元素的请求</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA       = <span class="number">1</span>;</span><br><span class="line">     <span class="comment">/** Node is fulfilling another unfulfilled DATA or REQUEST */</span></span><br><span class="line">     <span class="comment">// 这个状态就是匹配上了队列中的某一个节点</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FULFILLING = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/** Node class for TransferStacks. */</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SNode</span> </span>&#123;</span><br><span class="line">         <span class="keyword">volatile</span> SNode next;        <span class="comment">// next node in stack</span></span><br><span class="line">         <span class="comment">// 匹配上了某个节点</span></span><br><span class="line">         <span class="keyword">volatile</span> SNode match;       <span class="comment">// the node matched to this</span></span><br><span class="line">         <span class="keyword">volatile</span> Thread waiter;     <span class="comment">// to control park/unpark</span></span><br><span class="line">         Object item;                <span class="comment">// data; or null for REQUESTs</span></span><br><span class="line">         <span class="keyword">int</span> mode;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//...省略其他代码</span></span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Puts or takes an item.</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">     E transfer(E e, boolean timed, long nanos)&#123;</span></span><br><span class="line"><span class="comment">     // ...</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     //... 省略其他代码</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> static final class TransferQueue&lt;E&gt; extends Transferer&lt;E&gt;&#123;</span></span><br><span class="line"><span class="comment">     static final class QNode &#123;</span></span><br><span class="line"><span class="comment">         volatile QNode next;          // next node in queue</span></span><br><span class="line"><span class="comment">         // 注意区别SNode的item是volatile的</span></span><br><span class="line"><span class="comment">         volatile Object item;         // CAS'ed to or from null</span></span><br><span class="line"><span class="comment">         volatile Thread waiter;       // to control park/unpark</span></span><br><span class="line"><span class="comment">         final boolean isData;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         //...</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     /** Head of queue */</span></span><br><span class="line">     <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode head;</span><br><span class="line">     <span class="comment">/** Tail of queue */</span></span><br><span class="line">     <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode tail;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Reference to a cancelled node that might not yet have been</span></span><br><span class="line"><span class="comment">      * unlinked from queue because it was the last inserted node</span></span><br><span class="line"><span class="comment">      * when it was cancelled.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode cleanMe;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Puts or takes an item.</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">     E transfer(E e, boolean timed, long nanos)&#123;</span></span><br><span class="line"><span class="comment">//...   </span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br></pre></td></tr></table></figure><p>没有用于存储队列元素内部变量，并且有表示自旋时间的静态变量。内部有个Transferer抽象类，抽象类只有一个transfer方法。分别有TransferStack和TransferQueue实现了这个类，表示非公平和公平两种模式。<br><a name="6cLh5"></a></p><h1 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h1><p>主要逻辑都在这个transfer方法中，包括出入队也都是通过这个方法实现的。<br><a name="1T6Eh"></a></p><h3 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element into this queue, waiting if necessary</span></span><br><span class="line"><span class="comment"> * up to the specified wait time for another thread to receive it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 插入元素，阻塞给定时间，直到另一线程接收到插入元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, java.util.concurrent.TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 方法都是一个方法，区别在于第一个参数是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(e, <span class="keyword">true</span>, unit.toNanos(timeout)) != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Thread.interrupted())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="unehW"></a></p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Retrieves and removes the head of this queue, waiting</span></span><br><span class="line"><span class="comment">    * if necessary up to the specified wait time, for another thread</span></span><br><span class="line"><span class="comment">    * to insert it.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 获取和移除队列头部元素，阻塞给定时间，直到另一线程往队列插入元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="comment">// 方法都是一个方法，区别在于第一个参数是否为null</span></span><br><span class="line">       E e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">       <span class="keyword">if</span> (e != <span class="keyword">null</span> || !Thread.interrupted())</span><br><span class="line">           <span class="keyword">return</span> e;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><a name="KY6lj"></a></p><h3 id="TransferStack-transfer"><a href="#TransferStack-transfer" class="headerlink" title="TransferStack.transfer"></a>TransferStack.transfer</h3><p>TransferStack是非公平竞争的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * Basic algorithm is to loop trying one of three actions:</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * 1. If apparently empty or already containing nodes of same</span></span><br><span class="line"><span class="comment">           *    mode, try to push node on stack and wait for a match,</span></span><br><span class="line"><span class="comment">           *    returning it, or null if cancelled.</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * 2. If apparently containing node of complementary mode,</span></span><br><span class="line"><span class="comment">           *    try to push a fulfilling node on to stack, match</span></span><br><span class="line"><span class="comment">           *    with corresponding waiting node, pop both from</span></span><br><span class="line"><span class="comment">           *    stack, and return matched item. The matching or</span></span><br><span class="line"><span class="comment">           *    unlinking might not actually be necessary because of</span></span><br><span class="line"><span class="comment">           *    other threads performing action 3:</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * 3. If top of stack already holds another fulfilling node,</span></span><br><span class="line"><span class="comment">           *    help it out by doing its match and/or pop</span></span><br><span class="line"><span class="comment">           *    operations, and then continue. The code for helping</span></span><br><span class="line"><span class="comment">           *    is essentially the same as for fulfilling, except</span></span><br><span class="line"><span class="comment">           *    that it doesn't return the item.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          SNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">          <span class="comment">// 根据第一个参数决定具体是哪一种请求(poll or offer)</span></span><br><span class="line">          <span class="keyword">int</span> mode = (e == <span class="keyword">null</span>) ? REQUEST : DATA;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              SNode h = head;</span><br><span class="line">              <span class="comment">// 队列目前为空 或者 队列中全是同一种类型的节点</span></span><br><span class="line">              <span class="keyword">if</span> (h == <span class="keyword">null</span> || h.mode == mode) &#123;  <span class="comment">// empty or same-mode</span></span><br><span class="line">                  <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) &#123;      <span class="comment">// can't wait</span></span><br><span class="line">                      <span class="comment">// 这种直接返回null</span></span><br><span class="line">                      <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.isCancelled())</span><br><span class="line">                          casHead(h, h.next);     <span class="comment">// pop cancelled node</span></span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                  <span class="comment">// 构造一个节点入队</span></span><br><span class="line">                  <span class="comment">// s.next=h </span></span><br><span class="line">                  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class="line">                      <span class="comment">// 自旋或阻塞等待直到fulfill匹配</span></span><br><span class="line">                      SNode m = awaitFulfill(s, timed, nanos);</span><br><span class="line">                      <span class="comment">// 对于TransferStack，取消(超时)的节点,会赋值match为this</span></span><br><span class="line">                      <span class="comment">// 当match等于自身的时候就是该clean的节点，说明等待足够长时间了</span></span><br><span class="line">                      <span class="keyword">if</span> (m == s) &#123;               <span class="comment">// wait was cancelled</span></span><br><span class="line">                          clean(s);</span><br><span class="line">                          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="comment">// fulfill，匹配</span></span><br><span class="line">                      <span class="comment">// h -&gt; fulfill node ; s -&gt; match node;</span></span><br><span class="line">                      <span class="keyword">if</span> ((h = head) != <span class="keyword">null</span> &amp;&amp; h.next == s)</span><br><span class="line">                          <span class="comment">// s节点出队(或者该说出栈)</span></span><br><span class="line">                          casHead(h, s.next);     <span class="comment">// help s's fulfiller</span></span><br><span class="line">                      <span class="comment">// 如果是consumer的话，那么返回的值该是fulfill节点m的值，否则就是s节点的值</span></span><br><span class="line">                      <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                  &#125;</span><br><span class="line">              <span class="comment">// 那么这里就是fulfill操作了</span></span><br><span class="line">              <span class="comment">// h节点并不是fulfill</span></span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) &#123; <span class="comment">// try to fulfill</span></span><br><span class="line">                  <span class="keyword">if</span> (h.isCancelled())            <span class="comment">// already cancelled</span></span><br><span class="line">                      casHead(h, h.next);         <span class="comment">// pop and retry</span></span><br><span class="line">                  <span class="comment">// 入队一个fulfill节点</span></span><br><span class="line">                  <span class="comment">// s.next = h; h也应该是s的匹配节点</span></span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class="line">                      <span class="comment">// for循环 以防刚好待匹配节点因为时间到了失效了</span></span><br><span class="line">                      <span class="keyword">for</span> (;;) &#123; <span class="comment">// loop until matched or waiters disappear</span></span><br><span class="line">                          SNode m = s.next;       <span class="comment">// m is s's match</span></span><br><span class="line">                          <span class="comment">// 队列中已经没有等待节点</span></span><br><span class="line">                          <span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123;        <span class="comment">// all waiters are gone</span></span><br><span class="line">                              <span class="comment">// 这个时候就不该插fulfill节点了，所以pop刚插的fulfill</span></span><br><span class="line">                              casHead(s, <span class="keyword">null</span>);   <span class="comment">// pop fulfill node</span></span><br><span class="line">                              s = <span class="keyword">null</span>;           <span class="comment">// use new node next time</span></span><br><span class="line">                              <span class="keyword">break</span>;              <span class="comment">// restart main loop</span></span><br><span class="line">                          &#125;</span><br><span class="line">                          SNode mn = m.next;</span><br><span class="line">                          <span class="comment">// 即 m.match = s; unpark(m.thread);</span></span><br><span class="line">                          <span class="keyword">if</span> (m.tryMatch(s)) &#123;</span><br><span class="line">                              casHead(s, mn);     <span class="comment">// pop both s and m</span></span><br><span class="line">                              <span class="comment">// 同上</span></span><br><span class="line">                              <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                          &#125; <span class="keyword">else</span>                  <span class="comment">// lost match</span></span><br><span class="line">                              <span class="comment">// 匹配节点m已经cancel失效，则移除m节点</span></span><br><span class="line">                              s.casNext(m, mn);   <span class="comment">// help unlink</span></span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              <span class="comment">// h节点是fulfill节点，总会有这种情况的出现</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// help a fulfiller</span></span><br><span class="line">                  SNode m = h.next;               <span class="comment">// m is h's match</span></span><br><span class="line">                  <span class="keyword">if</span> (m == <span class="keyword">null</span>)                  <span class="comment">// waiter is gone</span></span><br><span class="line">                      casHead(h, <span class="keyword">null</span>);           <span class="comment">// pop fulfilling node</span></span><br><span class="line">                  <span class="keyword">else</span> &#123;</span><br><span class="line">                      SNode mn = m.next;</span><br><span class="line">                      <span class="keyword">if</span> (m.tryMatch(h))          <span class="comment">// help match</span></span><br><span class="line">                          casHead(h, mn);         <span class="comment">// pop both h and m</span></span><br><span class="line">                      <span class="keyword">else</span>                        <span class="comment">// lost match</span></span><br><span class="line">                          h.casNext(m, mn);       <span class="comment">// help unlink</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个SNode节点</span></span><br><span class="line"><span class="comment">// next一般是h</span></span><br><span class="line">      <span class="function"><span class="keyword">static</span> SNode <span class="title">snode</span><span class="params">(SNode s, Object e, SNode next, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (s == <span class="keyword">null</span>) s = <span class="keyword">new</span> SNode(e);</span><br><span class="line">          s.mode = mode;</span><br><span class="line">          s.next = next;</span><br><span class="line">          <span class="keyword">return</span> s;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spins/blocks until node s is matched by a fulfill operation.</span></span><br><span class="line"><span class="comment">// 自旋，直到fulfill操作匹配节点</span></span><br><span class="line">      <span class="function">SNode <span class="title">awaitFulfill</span><span class="params">(SNode s, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">          Thread w = Thread.currentThread();</span><br><span class="line">          <span class="comment">// 如果s在队列头，或者队列中有一有效的fulfill节点，那么将采用自旋</span></span><br><span class="line">          <span class="keyword">int</span> spins = (shouldSpin(s) ?</span><br><span class="line">                       (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">                  <span class="comment">// SNode.tryCancel：</span></span><br><span class="line">                  <span class="comment">// s.match = s</span></span><br><span class="line">                  s.tryCancel();</span><br><span class="line">              <span class="comment">// 节点s的匹配节点</span></span><br><span class="line">              SNode m = s.match;</span><br><span class="line">              <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">                  <span class="keyword">return</span> m;</span><br><span class="line">              <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                  nanos = deadline - System.nanoTime();</span><br><span class="line">                  <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                      s.tryCancel();</span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 自旋</span></span><br><span class="line">              <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">                  spins = shouldSpin(s) ? (spins-<span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">                  s.waiter = w; <span class="comment">// establish waiter so can park next iter</span></span><br><span class="line">              <span class="comment">// 阻塞</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">                  LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">              <span class="comment">// 给的时间大于阈值才会进入阻塞状态</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">                  LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Returns true if node s is at head or there is an active</span></span><br><span class="line"><span class="comment">       * fulfiller.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">boolean</span> <span class="title">shouldSpin</span><span class="params">(SNode s)</span> </span>&#123;</span><br><span class="line">          SNode h = head;</span><br><span class="line">          <span class="keyword">return</span> (h == s || h == <span class="keyword">null</span> || isFulfilling(h.mode));</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>TransferStack总是先进后出，并不保证公平，甚至在一些极端情况会导致一部分请求总得不到调度。<br>详情：</p><ul><li>请求到达，如果栈为空，则入栈相对应状态(consumer-&gt;request、producer-&gt;data)节点</li><li>如果栈不为空，并且目前节点状态与栈顶结点状态不一致(即并不是都为consumer or producer)，那么入栈一fulfill节点</li><li>匹配过程，匹配栈顶结点为fulfill以及后继节点为头结点的match，成功则出栈两节点</li><li>最后根据节点状态返回对应的需要同步的数据对象<br><a name="hvuBw"></a><h3 id="TransferQueue-transfer"><a href="#TransferQueue-transfer" class="headerlink" title="TransferQueue.transfer"></a>TransferQueue.transfer</h3>TransferQueue是公平竞争的实现。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">          <span class="comment">/* Basic algorithm is to loop trying to take either of</span></span><br><span class="line"><span class="comment">           * two actions:</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * 1. If queue apparently empty or holding same-mode nodes,</span></span><br><span class="line"><span class="comment">           *    try to add node to queue of waiters, wait to be</span></span><br><span class="line"><span class="comment">           *    fulfilled (or cancelled) and return matching item.</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * 2. If queue apparently contains waiting items, and this</span></span><br><span class="line"><span class="comment">           *    call is of complementary mode, try to fulfill by CAS'ing</span></span><br><span class="line"><span class="comment">           *    item field of waiting node and dequeuing it, and then</span></span><br><span class="line"><span class="comment">           *    returning matching item.</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * In each case, along the way, check for and try to help</span></span><br><span class="line"><span class="comment">           * advance head and tail on behalf of other stalled/slow</span></span><br><span class="line"><span class="comment">           * threads.</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * The loop starts off with a null check guarding against</span></span><br><span class="line"><span class="comment">           * seeing uninitialized head or tail values. This never</span></span><br><span class="line"><span class="comment">           * happens in current SynchronousQueue, but could if</span></span><br><span class="line"><span class="comment">           * callers held non-volatile/final ref to the</span></span><br><span class="line"><span class="comment">           * transferer. The check is here anyway because it places</span></span><br><span class="line"><span class="comment">           * null checks at top of loop, which is usually faster</span></span><br><span class="line"><span class="comment">           * than having them implicitly interspersed.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          QNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">          <span class="keyword">boolean</span> isData = (e != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              QNode t = tail;</span><br><span class="line">              QNode h = head;</span><br><span class="line">              <span class="comment">// 初始化还未完成</span></span><br><span class="line">              <span class="keyword">if</span> (t == <span class="keyword">null</span> || h == <span class="keyword">null</span>)         <span class="comment">// saw uninitialized value</span></span><br><span class="line">                  <span class="keyword">continue</span>;                       <span class="comment">// spin</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">// 队列为空，或当前节点和尾为相同类型节点</span></span><br><span class="line">              <span class="keyword">if</span> (h == t || t.isData == isData) &#123; <span class="comment">// empty or same-mode</span></span><br><span class="line">                  QNode tn = t.next;</span><br><span class="line">                  <span class="comment">// 尾巴变了</span></span><br><span class="line">                  <span class="keyword">if</span> (t != tail)                  <span class="comment">// inconsistent read</span></span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  <span class="comment">// 尾巴变了，但未更新，help一下</span></span><br><span class="line">                  <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;               <span class="comment">// lagging tail</span></span><br><span class="line">                      advanceTail(t, tn);</span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)        <span class="comment">// can't wait</span></span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                      <span class="comment">// 构造节点入队</span></span><br><span class="line">                      s = <span class="keyword">new</span> QNode(e, isData);</span><br><span class="line">                  <span class="keyword">if</span> (!t.casNext(<span class="keyword">null</span>, s))        <span class="comment">// failed to link in</span></span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 入队</span></span><br><span class="line">                  advanceTail(t, s);              <span class="comment">// swing tail and wait</span></span><br><span class="line">                  <span class="comment">// 阻塞等待fulfill</span></span><br><span class="line">                  Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line">                  <span class="comment">// QNode 的item：</span></span><br><span class="line">                  <span class="comment">// 等于this-&gt;cancel;null-&gt;consumer;not null -&gt; producer</span></span><br><span class="line">                  <span class="keyword">if</span> (x == s) &#123;                   <span class="comment">// wait was cancelled</span></span><br><span class="line">                      clean(t, s);</span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// s脱离队列，已不在队列中，这个时候需要重置一下队列</span></span><br><span class="line">                  <span class="keyword">if</span> (!s.isOffList()) &#123;           <span class="comment">// not already unlinked</span></span><br><span class="line">                      advanceHead(t, s);          <span class="comment">// unlink if head</span></span><br><span class="line">                      <span class="keyword">if</span> (x != <span class="keyword">null</span>)              <span class="comment">// and forget fields</span></span><br><span class="line">                          s.item = s;</span><br><span class="line">                      s.waiter = <span class="keyword">null</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 结合下面的else看，在else中会更改s.item</span></span><br><span class="line">                  <span class="comment">// x != null 表示当前为consumer</span></span><br><span class="line">                  <span class="comment">// x == null 表示当前为producer</span></span><br><span class="line">                  <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line"></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// complementary-mode</span></span><br><span class="line">                  <span class="comment">// m为fulfill节点</span></span><br><span class="line">                  QNode m = h.next;               <span class="comment">// node to fulfill</span></span><br><span class="line">                  <span class="comment">// 队列改变，或者fulfill为空则需要retry</span></span><br><span class="line">                  <span class="keyword">if</span> (t != tail || m == <span class="keyword">null</span> || h != head)</span><br><span class="line">                      <span class="keyword">continue</span>;                   <span class="comment">// inconsistent read</span></span><br><span class="line"></span><br><span class="line">                  Object x = m.item;</span><br><span class="line">                  <span class="comment">// m的item已经操作过:m.casItem(x,e)，即already fulfilled</span></span><br><span class="line">                  <span class="keyword">if</span> (isData == (x != <span class="keyword">null</span>) ||    <span class="comment">// m already fulfilled</span></span><br><span class="line">                      <span class="comment">// m节点失效</span></span><br><span class="line">                      x == m ||                   <span class="comment">// m cancelled</span></span><br><span class="line">                      <span class="comment">// 相当于TransferStack的匹配过程，将m.item=e</span></span><br><span class="line">                      <span class="comment">// cas失败，表示others have done，则需要重置头节点retry</span></span><br><span class="line">                      !m.casItem(x, e)) &#123;         <span class="comment">// lost CAS</span></span><br><span class="line">                      advanceHead(h, m);          <span class="comment">// dequeue and retry</span></span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 成功，h出队，head=m</span></span><br><span class="line">                  advanceHead(h, m);              <span class="comment">// successfully fulfilled</span></span><br><span class="line">                  <span class="comment">// 唤醒m节点阻塞线程</span></span><br><span class="line">                  LockSupport.unpark(m.waiter);</span><br><span class="line">                  <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Spins/blocks until node s is fulfilled.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function">Object <span class="title">awaitFulfill</span><span class="params">(QNode s, E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">          <span class="comment">/* Same idea as TransferStack.awaitFulfill */</span></span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">          Thread w = Thread.currentThread();</span><br><span class="line">          <span class="keyword">int</span> spins = ((head.next == s) ?</span><br><span class="line">                       (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">                  <span class="comment">// QNode.tryCancel:</span></span><br><span class="line">                  <span class="comment">// s.item = s</span></span><br><span class="line">                  s.tryCancel(e);</span><br><span class="line">              Object x = s.item;</span><br><span class="line">              <span class="keyword">if</span> (x != e)</span><br><span class="line">                  <span class="keyword">return</span> x;</span><br><span class="line">              <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                  nanos = deadline - System.nanoTime();</span><br><span class="line">                  <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                      s.tryCancel(e);</span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 自旋</span></span><br><span class="line">              <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">                  --spins;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">                  s.waiter = w;</span><br><span class="line">              <span class="comment">// 阻塞</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">                  LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">              <span class="comment">// 同样，需要大于阻塞阈值才会真正阻塞，否则就自旋</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">                  LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ul><p>TransferQueue总是FIFO，保证了公平。<br>详情：</p><ul><li>请求到达，如果队列为空，或者尾节点的类型和当前节点相同（同是consumer或producer），则在队列尾部入队当前节点等待，直到被唤醒</li><li>否则头结点出队，唤醒头结点对应线程，返回对应值</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;5nF7T&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JDK" scheme="https://blog.dengxf.cn/tags/JDK/"/>
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读之StampedLock</title>
    <link href="https://blog.dengxf.cn/77e66558.html"/>
    <id>https://blog.dengxf.cn/77e66558.html</id>
    <published>2019-05-21T03:26:14.000Z</published>
    <updated>2019-06-27T09:48:04.179Z</updated>
    
    <content type="html"><![CDATA[<p><a name="bnvsh"></a></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>作者<em>Doug Lea_如此描述这个类：_A capability-based lock with three modes for controlling read/write access.</em><br>这是一个有三种模式的锁。具体哪三种模式，请看源码中的示例。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三种模式用法</span></span><br><span class="line"><span class="comment"> * reading &amp; writing &amp; optimistic read</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// writing mode</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123; <span class="comment">// an exclusively locked method</span></span><br><span class="line">        <span class="keyword">long</span> stamp = sl.writeLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sl.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimistic Reading mode</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123; <span class="comment">// A read-only method</span></span><br><span class="line">        <span class="keyword">long</span> stamp = sl.tryOptimisticRead();</span><br><span class="line">        <span class="keyword">double</span> currentX = x, currentY = y;</span><br><span class="line">        <span class="comment">// 会有一个验证的步骤</span></span><br><span class="line">        <span class="keyword">if</span> (!sl.validate(stamp)) &#123;</span><br><span class="line">            stamp = sl.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX currentX + currentY currentY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock upgrade</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY)</span> </span>&#123; <span class="comment">// upgrade</span></span><br><span class="line">        <span class="comment">// Could instead start with optimistic, not read mode</span></span><br><span class="line">        <span class="keyword">long</span> stamp = sl.readLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp);</span><br><span class="line">                <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123;</span><br><span class="line">                    stamp = ws;</span><br><span class="line">                    x = newX;</span><br><span class="line">                    y = newY;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sl.unlockRead(stamp);</span><br><span class="line">                    stamp = sl.writeLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sl.unlock(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<a href="https://blog.dengxf.cn/4ba3385f.html">ReentrantReadWriteLock</a>中我们知道，如果在读并发比较高的情况下，那么可能会导致写线程饥饿。而StampedLock并不会发生写饥饿。另外，它也有锁升级的特性（ReentrantReadWriteLock只有锁降级）。那么看看它是怎么实现的吧。<br><a name="e6Z7w"></a></p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>锁算法是借鉴了序列锁(linux内核，参考<a href>文章1</a>、<span class="exturl" data-url="aHR0cDovL3d3dy5sYW1ldGVyLmNvbS9nZWxhdG8yMDA1LnBkZg==" title="http://www.lameter.com/gelato2005.pdf">文章2<i class="fa fa-external-link"></i></span>)和顺序读写锁(参考<span class="exturl" data-url="aHR0cDovL3d3dy5ocGwuaHAuY29tL3RlY2hyZXBvcnRzLzIwMTIvSFBMLTIwMTItNjguaHRtbA==" title="http://www.hpl.hp.com/techreports/2012/HPL-2012-68.html">文章<i class="fa fa-external-link"></i></span>)。具体算法细节还可以参考源码中的描述。<br>简单描述一下，用一个long类型（state）的变量表示锁状态（写锁、读锁）,低7位表示读锁状态，其他位表示写锁（第8位是否未1表示是否持有写锁，前面说的sequence lock），如果低7位不够表示读锁位，那么会用一个int值表示”溢出”的读锁。那么写锁可以表示为：state+=2^7；读锁可以表示为state+=1。此外，源码中还用了大量自旋来减少饥饿的概率，头部节点表示的线程不会阻塞，而是会一直自旋等待锁释放。<br>结合内部的变量声明理解一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/** The number of bits to use for reader count before overflowing */</span></span><br><span class="line"><span class="comment">// 在state上用低7位表示reader count</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LG_READERS = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Values for lock state and stamp operations</span></span><br><span class="line"><span class="comment">// 表示一个reader</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RUNIT = <span class="number">1L</span>;</span><br><span class="line"><span class="comment">// 表示一个writer</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WBIT  = <span class="number">1L</span> &lt;&lt; LG_READERS;</span><br><span class="line"><span class="comment">// reader掩码</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RBITS = WBIT - <span class="number">1L</span>;</span><br><span class="line"><span class="comment">// state上能表示的最大reader count</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RFULL = RBITS - <span class="number">1L</span>;</span><br><span class="line"><span class="comment">// state上表示锁的所有位的掩码</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ABITS = RBITS | WBIT;</span><br><span class="line"><span class="comment">// 反码</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SBITS = ~RBITS; <span class="comment">// note overlap with ABITS</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Values for node status; order matters</span></span><br><span class="line"><span class="comment">// 表示等待</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITING   = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 表示取消</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Modes for nodes (int not boolean to allow arithmetic)</span></span><br><span class="line"><span class="comment">// 读</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RMODE = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 写</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WMODE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Wait nodes */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WNode</span> </span>&#123;</span><br><span class="line">       <span class="keyword">volatile</span> WNode prev;</span><br><span class="line">       <span class="keyword">volatile</span> WNode next;</span><br><span class="line">       <span class="comment">// 表示当前节点上的reader</span></span><br><span class="line">       <span class="keyword">volatile</span> WNode cowait;    <span class="comment">// list of linked readers</span></span><br><span class="line">       <span class="keyword">volatile</span> Thread thread;   <span class="comment">// non-null while possibly parked</span></span><br><span class="line">       <span class="comment">// 相当于CLH上的那个locked</span></span><br><span class="line">       <span class="keyword">volatile</span> <span class="keyword">int</span> status;      <span class="comment">// 0, WAITING, or CANCELLED</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> mode;           <span class="comment">// RMODE or WMODE</span></span><br><span class="line">       WNode(<span class="keyword">int</span> m, WNode p) &#123; mode = m; prev = p; &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Head of CLH queue */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode whead;</span><br><span class="line">   <span class="comment">/** Tail (last) of CLH queue */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode wtail;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Lock sequence/state */</span></span><br><span class="line"><span class="comment">// 锁状态，或者叫锁序列</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> state;</span><br><span class="line">   <span class="comment">/** extra reader count when state read count saturated */</span></span><br><span class="line"><span class="comment">// state上只有低7位用来表示reader，超出的部分用这个int值表示</span></span><br><span class="line"><span class="comment">// 注意这个变量并不是volatile</span></span><br><span class="line"><span class="comment">// 改变这个值时，都是cas操作state，并且改变之后也会对state赋值,可见性和原子性通过这两个操作保证的</span></span><br><span class="line"><span class="comment">// 即 s=state; cmp(state,RBITS);++readerOverflow(or readerOverflow -= 1);state=s</span></span><br><span class="line"><span class="comment">// 自旋锁保证原子性，内存屏障保证可见性</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> readerOverflow;</span><br></pre></td></tr></table></figure><p>总结一下，用一个long型变量表示锁的计数，读锁计数用低7位表示，超出部分用一个int值表示。其他位表示写锁状态，第8位如果为1则表示写锁被持有，为0表示未被持有，也就是序列锁，这样即保证了锁（包括读写）的原子性，也能提高效率(操作读或写锁要保证互斥)。用一个CLH队列表示等待的节点，避免饥饿现象，节点首先会采用自旋的方式尝试获取锁。<br>接下来就跟着3个示例解析一下加解锁的流程。<br><a name="gQl9p"></a></p><h1 id="Reading-Mode"><a href="#Reading-Mode" class="headerlink" title="Reading Mode"></a>Reading Mode</h1><p>经过上面的分析，state上的低7位是用来表示reader count，而溢出部分，则用readerOverflow表示。<br><a name="wROlv"></a></p><h3 id="readLock"><a href="#readLock" class="headerlink" title="readLock"></a>readLock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 非互斥获取读锁，如果暂时不可取，则会阻塞直到可取</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> s = state, next;  <span class="comment">// bypass acquireRead on common uncontended case</span></span><br><span class="line">       <span class="comment">// 队列为空</span></span><br><span class="line">       <span class="keyword">return</span> ((whead == wtail </span><br><span class="line">                <span class="comment">// 并且reader count 小于RFULL(2^7 - 2=126)</span></span><br><span class="line">                &amp;&amp; (s &amp; ABITS) &lt; RFULL </span><br><span class="line">                <span class="comment">// cas操作state,state += 1</span></span><br><span class="line">                &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + RUNIT)) ?</span><br><span class="line">               <span class="comment">// 获取成功返回最新state值,否则，进入acquireRead(false,0L)</span></span><br><span class="line">               next : acquireRead(<span class="keyword">false</span>, <span class="number">0L</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 方法有点长，这个方法主要做的是在一定时间内通过自旋去请求锁，如果仍没请求到，则进入阻塞状态</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">acquireRead</span><span class="params">(<span class="keyword">boolean</span> interruptible, <span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">       WNode node = <span class="keyword">null</span>, p;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> spins = -<span class="number">1</span>;;) &#123;</span><br><span class="line">           WNode h;</span><br><span class="line">           <span class="comment">// 队列为空(or仅有一个节点)</span></span><br><span class="line">           <span class="keyword">if</span> ((h = whead) == (p = wtail)) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">long</span> m, s, ns;;) &#123;</span><br><span class="line">                   <span class="comment">// 写锁未被占有，并且读锁数量小于RFULL（126），ABITS=255,2^8-1</span></span><br><span class="line">                   <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) &lt; RFULL ?</span><br><span class="line">                       <span class="comment">// cas尝试获取读锁，state+=1</span></span><br><span class="line">                       U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, ns = s + RUNIT) :</span><br><span class="line">                       <span class="comment">// 写锁未被占用，读锁数量大于RFULL，执行tryIncReaderOverflow方法</span></span><br><span class="line">                       <span class="comment">// 关于tryIncReaderOverflow见下该方法解析</span></span><br><span class="line">                       (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != <span class="number">0L</span>))</span><br><span class="line">                       <span class="comment">// 更新成功，始终返回当前最新锁状态</span></span><br><span class="line">                       <span class="keyword">return</span> ns;</span><br><span class="line">                   <span class="comment">// 到这里那写锁就被占用了</span></span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (m &gt;= WBIT) &#123;</span><br><span class="line">                       <span class="comment">// 自旋等待</span></span><br><span class="line">                       <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="comment">// 这个随机是几个意思？分散线程状态聚集在一个状态？避免都在一个时间点阻塞or唤醒？</span></span><br><span class="line">                           <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span>)</span><br><span class="line">                               --spins;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="comment">// 自旋结束</span></span><br><span class="line">                           <span class="keyword">if</span> (spins == <span class="number">0</span>) &#123;</span><br><span class="line">                               WNode nh = whead, np = wtail;</span><br><span class="line">                               <span class="comment">// 头尾未改变</span></span><br><span class="line">                               <span class="keyword">if</span> ((nh == h &amp;&amp; np == p)</span><br><span class="line">                                       <span class="comment">// 头尾改变且队列不再为空</span></span><br><span class="line">                                       || (h = nh) != (p = np))</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// 因为在头部，上一轮自旋未拿到锁那紧接着下一轮自旋</span></span><br><span class="line">                           <span class="comment">// SPINS = (NCPU &gt; 1) ? 1 &lt;&lt; 6 : 0;</span></span><br><span class="line">                           spins = SPINS;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 尾巴为空，即 队列为空，需要初始化队列</span></span><br><span class="line">           <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123; <span class="comment">// initialize queue</span></span><br><span class="line">               WNode hd = <span class="keyword">new</span> WNode(WMODE, <span class="keyword">null</span>);</span><br><span class="line">               <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, WHEAD, <span class="keyword">null</span>, hd))</span><br><span class="line">                   wtail = hd;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 构造节点入队</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">               node = <span class="keyword">new</span> WNode(RMODE, p);</span><br><span class="line">           <span class="comment">// 头尾相等或尾节点表示非读锁节点(也就是尾节点是写锁请求线程节点)</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (h == p || p.mode != RMODE) &#123;</span><br><span class="line">               <span class="comment">// 队列尾巴改变</span></span><br><span class="line">               <span class="keyword">if</span> (node.prev != p)</span><br><span class="line">                   <span class="comment">// 重新置尾巴</span></span><br><span class="line">                   node.prev = p;</span><br><span class="line">               <span class="comment">// 往队列追加节点</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, WTAIL, p, node)) &#123;</span><br><span class="line">                   p.next = node;</span><br><span class="line">                   <span class="comment">// 跳出当前自旋循环，进入下一个for自旋循环</span></span><br><span class="line">                   <span class="comment">// 唯一跳出本次for循环的地方，也就是只有在往队列新增了个节点的时候出去进入下一个for自旋循环</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 将当前节点放在尾巴（是读节点或者头节点）cowait(表示读锁等待节点)链表位置头部</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (!U.compareAndSwapObject(p, WCOWAIT,</span><br><span class="line">                                            node.cowait = p.cowait, node))</span><br><span class="line">               <span class="comment">// 失败</span></span><br><span class="line">               node.cowait = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">// cas成功</span></span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 阻塞等待读锁，直到唤醒时，前驱已为头节点</span></span><br><span class="line">               <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                   WNode pp, c; Thread w;</span><br><span class="line">                   <span class="comment">// 唤醒头结点上的第一个wcowait</span></span><br><span class="line">                   <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; (c = h.cowait) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                       U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;</span><br><span class="line">                       (w = c.thread) != <span class="keyword">null</span>) <span class="comment">// help release</span></span><br><span class="line">                       <span class="comment">// 唤醒头结点上的cowait读节点线程</span></span><br><span class="line">                       U.unpark(w);</span><br><span class="line">                   <span class="comment">// 前驱为头结点，或当前节点为头结点，或前驱的前驱为空</span></span><br><span class="line">                   <span class="comment">// 也就是在队列的头部位置</span></span><br><span class="line">                   <span class="comment">// 则一直自旋，尝试获取读锁，除非已经有写锁被占有</span></span><br><span class="line">                   <span class="keyword">if</span> (h == (pp = p.prev) || h == p || pp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="keyword">long</span> m, s, ns;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           <span class="comment">// 获取读锁</span></span><br><span class="line">                           <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) &lt; RFULL ?</span><br><span class="line">                               U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s,</span><br><span class="line">                                                    ns = s + RUNIT) :</span><br><span class="line">                               (m &lt; WBIT &amp;&amp;</span><br><span class="line">                                (ns = tryIncReaderOverflow(s)) != <span class="number">0L</span>))</span><br><span class="line">                               <span class="keyword">return</span> ns;</span><br><span class="line">                           <span class="comment">// 如果是写锁已被占有则跳出</span></span><br><span class="line">                       &#125; <span class="keyword">while</span> (m &lt; WBIT);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 前驱未改变(未cancel)以及头节点未改变(即未有锁的释放获取)</span></span><br><span class="line">                   <span class="keyword">if</span> (whead == h &amp;&amp; p.prev == pp) &#123;</span><br><span class="line">                       <span class="keyword">long</span> time;</span><br><span class="line">                       <span class="comment">// 前驱的前驱为空，或前驱节点为头结点，或节点已经cancel</span></span><br><span class="line">                       <span class="comment">// 当目前节点是头节点，则跳出当前for，进入下一个for循环，自旋获取锁</span></span><br><span class="line">                       <span class="keyword">if</span> (pp == <span class="keyword">null</span> || h == p || p.status &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                           node = <span class="keyword">null</span>; <span class="comment">// throw away</span></span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (deadline == <span class="number">0L</span>)</span><br><span class="line">                           time = <span class="number">0L</span>;</span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">                           <span class="comment">// 将node.status=CANCELLED</span></span><br><span class="line">                           <span class="comment">// 将p的cowait链表上取消的节点剔除</span></span><br><span class="line">                           <span class="keyword">return</span> cancelWaiter(node, p, <span class="keyword">false</span>);</span><br><span class="line">                       Thread wt = Thread.currentThread();</span><br><span class="line">                       U.putObject(wt, PARKBLOCKER, <span class="keyword">this</span>);</span><br><span class="line">                       node.thread = wt;</span><br><span class="line">                       <span class="comment">// 前驱不为头结点</span></span><br><span class="line">                       <span class="keyword">if</span> ((h != pp</span><br><span class="line">                               <span class="comment">// 或写锁已经被其它线程获取且当前头结点未改变且前驱未改变</span></span><br><span class="line">                               || (state &amp; ABITS) == WBIT) &amp;&amp; whead == h &amp;&amp; p.prev == pp)</span><br><span class="line">                           <span class="comment">// 阻塞当前线程等待唤醒</span></span><br><span class="line">                           U.park(<span class="keyword">false</span>, time);</span><br><span class="line">                       node.thread = <span class="keyword">null</span>;</span><br><span class="line">                       U.putObject(wt, PARKBLOCKER, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (interruptible &amp;&amp; Thread.interrupted())</span><br><span class="line">                           <span class="keyword">return</span> cancelWaiter(node, p, <span class="keyword">true</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 这个循环就是头节点"进一步的深度"自旋，"其他"节点则阻塞</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> spins = -<span class="number">1</span>;;) &#123;</span><br><span class="line">           WNode h, np, pp; <span class="keyword">int</span> ps;</span><br><span class="line">           <span class="comment">// 队列为空，即当前节点在头部位置</span></span><br><span class="line">           <span class="keyword">if</span> ((h = whead) == p) &#123;</span><br><span class="line">               <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)</span><br><span class="line">                   <span class="comment">// HEAD_SPINS = (NCPU &gt; 1) ? 1 &lt;&lt; 10 : 0</span></span><br><span class="line">                   <span class="comment">// 首次自旋2^10</span></span><br><span class="line">                   spins = HEAD_SPINS;</span><br><span class="line">               <span class="comment">// (NCPU &gt; 1) ? 1 &lt;&lt; 16 : 0</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; MAX_HEAD_SPINS)</span><br><span class="line">                   <span class="comment">// 指数型递增</span></span><br><span class="line">                   spins &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">               <span class="comment">// 自旋等待锁，注意这里是在头部自旋</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> k = spins;;) &#123; <span class="comment">// spin at head</span></span><br><span class="line">                   <span class="keyword">long</span> m, s, ns;</span><br><span class="line">                   <span class="comment">// 下面是获取读锁</span></span><br><span class="line">                   <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) &lt; RFULL ?</span><br><span class="line">                       U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, ns = s + RUNIT) :</span><br><span class="line">                       (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != <span class="number">0L</span>)) &#123;</span><br><span class="line">                       <span class="comment">// 获得读锁</span></span><br><span class="line">                       WNode c; Thread w;</span><br><span class="line">                       whead = node;</span><br><span class="line">                       node.prev = <span class="keyword">null</span>;</span><br><span class="line">                       <span class="comment">// 唤醒所有在node上的wcowait读锁等待线程</span></span><br><span class="line">                       <span class="keyword">while</span> ((c = node.cowait) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (U.compareAndSwapObject(node, WCOWAIT,</span><br><span class="line">                                                      c, c.cowait) &amp;&amp;</span><br><span class="line">                               (w = c.thread) != <span class="keyword">null</span>)</span><br><span class="line">                               U.unpark(w);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">return</span> ns;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 已经有写锁被占用了，且自旋结束，结束此次自旋</span></span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (m &gt;= WBIT &amp;&amp;</span><br><span class="line">                            LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span> &amp;&amp; --k &lt;= <span class="number">0</span>)</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 队列不为空，且头节点部位空</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (h != <span class="keyword">null</span>) &#123;</span><br><span class="line">               WNode c; Thread w;</span><br><span class="line">               <span class="comment">// 依次唤醒头结点上的读锁等待线程，如果有cowait的话</span></span><br><span class="line">               <span class="keyword">while</span> ((c = h.cowait) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;</span><br><span class="line">                       (w = c.thread) != <span class="keyword">null</span>)</span><br><span class="line">                       U.unpark(w);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 头节点未改变</span></span><br><span class="line">           <span class="keyword">if</span> (whead == h) &#123;</span><br><span class="line">               <span class="comment">// 即前驱变了，如cancel了</span></span><br><span class="line">               <span class="keyword">if</span> ((np = node.prev) != p) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (np != <span class="keyword">null</span>)</span><br><span class="line">                       (p = np).next = node;   <span class="comment">// stale</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((ps = p.status) == <span class="number">0</span>)</span><br><span class="line">                   <span class="comment">// 更改前驱节点状态为WAITING</span></span><br><span class="line">                   U.compareAndSwapInt(p, WSTATUS, <span class="number">0</span>, WAITING);</span><br><span class="line">               <span class="comment">// 取消的节点要剔除掉</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (ps == CANCELLED) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((pp = p.prev) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       node.prev = pp;</span><br><span class="line">                       pp.next = node;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">long</span> time;</span><br><span class="line">                   <span class="keyword">if</span> (deadline == <span class="number">0L</span>)</span><br><span class="line">                       time = <span class="number">0L</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">                       <span class="comment">// 这个cancelWaiter跟前边的参数不一样</span></span><br><span class="line">                       <span class="comment">// 这里是除了前边的cancelWaiter的功能，还需要做唤醒node上的cowait</span></span><br><span class="line">                       <span class="comment">// 并且将cowait链表的第一个节点唤醒，且用这个cowait替换掉node的位置</span></span><br><span class="line">                       <span class="keyword">return</span> cancelWaiter(node, node, <span class="keyword">false</span>);</span><br><span class="line">                   Thread wt = Thread.currentThread();</span><br><span class="line">                   U.putObject(wt, PARKBLOCKER, <span class="keyword">this</span>);</span><br><span class="line">                   node.thread = wt;</span><br><span class="line">                   <span class="comment">// 前驱节点状态为WAITING</span></span><br><span class="line">                   <span class="keyword">if</span> (p.status &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                       <span class="comment">// 前驱不为头结点，或当前写锁被其它线程持有</span></span><br><span class="line">                       (p != h || (state &amp; ABITS) == WBIT) &amp;&amp;</span><br><span class="line">                       whead == h &amp;&amp; node.prev == p)</span><br><span class="line">                       <span class="comment">// 阻塞在这里</span></span><br><span class="line">                       U.park(<span class="keyword">false</span>, time);</span><br><span class="line">                   node.thread = <span class="keyword">null</span>;</span><br><span class="line">                   U.putObject(wt, PARKBLOCKER, <span class="keyword">null</span>);</span><br><span class="line">                   <span class="keyword">if</span> (interruptible &amp;&amp; Thread.interrupted())</span><br><span class="line">                       <span class="keyword">return</span> cancelWaiter(node, node, <span class="keyword">true</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 相当于是把自旋锁对state更新</span></span><br><span class="line"><span class="comment">    * 此外，readerOverflow并不是volatile，但是它的可见性和原子性是怎么保证的？</span></span><br><span class="line"><span class="comment">    * 可见性：state是volatile，可以借助它的内存屏障，因为readerOverflow是在state前操作的</span></span><br><span class="line"><span class="comment">    * 原子性：读锁在state上最大只有126个，当超过126是将state低位置为127，操作结束后将其置回126</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">tryIncReaderOverflow</span><span class="params">(<span class="keyword">long</span> s)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// assert (s &amp; ABITS) &gt;= RFULL;</span></span><br><span class="line">       <span class="keyword">if</span> ((s &amp; ABITS) == RFULL) &#123;</span><br><span class="line">           <span class="comment">// RBITS = 2^7 - 1</span></span><br><span class="line">           <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, s | RBITS)) &#123;</span><br><span class="line">               ++readerOverflow;</span><br><span class="line">               state = s;</span><br><span class="line">               <span class="keyword">return</span> s;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((LockSupport.nextSecondarySeed() &amp;</span><br><span class="line">                 OVERFLOW_YIELD_RATE) == <span class="number">0</span>)</span><br><span class="line">           Thread.yield();</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>首先明确获取读锁并不是互斥的，而是通过cas操作去尝试获取。其次是通过自旋去尝试获取锁，对于头部位置的节点总是在自旋等待锁。<br><a name="75vA9"></a></p><h3 id="unlockRead"><a href="#unlockRead" class="headerlink" title="unlockRead"></a>unlockRead</h3><p>接下来看一下时如何释放读锁的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If the lock state matches the given stamp, releases the</span></span><br><span class="line"><span class="comment"> * non-exclusive lock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stamp a stamp returned by a read-lock operation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalMonitorStateException if the stamp does</span></span><br><span class="line"><span class="comment"> * not match the current state of this lock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockRead</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s, m; WNode h;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// SBITS=~(2^7-1),低8位的掩码</span></span><br><span class="line">        <span class="comment">// 如果写锁的状态发生过变更</span></span><br><span class="line">        <span class="keyword">if</span> (((s = state) &amp; SBITS) != (stamp &amp; SBITS) ||</span><br><span class="line">            <span class="comment">// 或stamp目前表示没有锁，或state表示目前没有锁</span></span><br><span class="line">            (stamp &amp; ABITS) == <span class="number">0L</span> || (m = s &amp; ABITS) == <span class="number">0L</span> || m == WBIT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="comment">// 读锁小于RFULL=126</span></span><br><span class="line">        <span class="keyword">if</span> (m &lt; RFULL) &#123;</span><br><span class="line">            <span class="comment">// cas state-=1</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, s - RUNIT)) &#123;</span><br><span class="line">                <span class="comment">// 最后一把锁，且队列头节点不为空，头节点状态也不是初始状态(WAITING状态)</span></span><br><span class="line">                <span class="keyword">if</span> (m == RUNIT &amp;&amp; (h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 则释放h.next等待的线程节点</span></span><br><span class="line">                    release(h);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目前的写锁状态时溢出的，需要对readerOverflow进行处理，看下面该方法的解析</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tryDecReaderOverflow(s) != <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tries to decrement readerOverflow.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s a reader overflow stamp: (s &amp; ABITS) &gt;= RFULL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> new stamp on success, else zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">tryDecReaderOverflow</span><span class="params">(<span class="keyword">long</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert (s &amp; ABITS) &gt;= RFULL;</span></span><br><span class="line">    <span class="comment">// state读锁状态满了</span></span><br><span class="line">    <span class="keyword">if</span> ((s &amp; ABITS) == RFULL) &#123;</span><br><span class="line">        <span class="comment">// 获取spinlock，即"自旋锁"，正常应该时state=127</span></span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, s | RBITS)) &#123;</span><br><span class="line">            <span class="keyword">int</span> r; <span class="keyword">long</span> next;</span><br><span class="line">            <span class="keyword">if</span> ((r = readerOverflow) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                readerOverflow = r - <span class="number">1</span>;</span><br><span class="line">                next = s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next = s - RUNIT;</span><br><span class="line">             <span class="comment">// state为volatile，有barrier，加上上边那个127</span></span><br><span class="line">            <span class="comment">//所以readerOverflow的可见性原子性得以保证</span></span><br><span class="line">             <span class="comment">// state=126</span></span><br><span class="line">             state = next;</span><br><span class="line">             <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可能会放弃CPU时钟</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((LockSupport.nextSecondarySeed() &amp;</span><br><span class="line">              OVERFLOW_YIELD_RATE) == <span class="number">0</span>)</span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="dNEBL"></a></p><h1 id="Writing-Mode"><a href="#Writing-Mode" class="headerlink" title="Writing Mode"></a>Writing Mode</h1><p><a name="PztzD"></a></p><h3 id="writeLock"><a href="#writeLock" class="headerlink" title="writeLock"></a>writeLock</h3><p>读锁状态也是也是在state上表示，除了表示读锁状态的低7位，剩下的高25位都表示写锁状态。第8位为1表示写锁被占用，否则表示未被占用，写锁状态时往上递增的，也就是说获取读锁state需要+WBIT，释放也是+WBIT。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">writeLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> s, next;  <span class="comment">// bypass acquireWrite in fully unlocked case only</span></span><br><span class="line">       <span class="comment">// ABITS=2^8-1=255</span></span><br><span class="line">       <span class="keyword">return</span> ((((s = state) &amp; ABITS) == <span class="number">0L</span> &amp;&amp;</span><br><span class="line">                <span class="comment">// WBIT=2^7=128</span></span><br><span class="line">                U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + WBIT)) ?</span><br><span class="line">               <span class="comment">// 如果低8位为0，且cas state+=WBIT成功，即表示获取读锁成功</span></span><br><span class="line">               <span class="comment">// 否则进入acquireWrite(false,0L),这个方法也是在无锁状态下才会获取写锁成功</span></span><br><span class="line">               next : acquireWrite(<span class="keyword">false</span>, <span class="number">0L</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法时跟acquireRead一样，较长，也比较复杂,不过做的事情比较简单</span></span><br><span class="line"><span class="comment">// 就是自旋等待写锁，或者入队阻塞等待唤醒</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">acquireWrite</span><span class="params">(<span class="keyword">boolean</span> interruptible, <span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">       WNode node = <span class="keyword">null</span>, p;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> spins = -<span class="number">1</span>;;) &#123; <span class="comment">// spin while enqueuing</span></span><br><span class="line">           <span class="keyword">long</span> m, s, ns;</span><br><span class="line">           <span class="comment">// 无锁状态,则尝试获取写锁</span></span><br><span class="line">           <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) == <span class="number">0L</span>) &#123;</span><br><span class="line">               <span class="comment">// state += WBIT（2^7=128）</span></span><br><span class="line">               <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, ns = s + WBIT))</span><br><span class="line">                   <span class="keyword">return</span> ns;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 自旋等待</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="comment">// 如果是写锁且当前队列仅有一个写锁节点(也就是这个节点持有锁)，则自旋尝试获取锁</span></span><br><span class="line">               <span class="comment">// 否则就入队囖</span></span><br><span class="line">               spins = (m == WBIT &amp;&amp; wtail == whead) ? SPINS : <span class="number">0</span>;</span><br><span class="line">           <span class="comment">// 自旋</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span>)</span><br><span class="line">                   <span class="comment">// 随机，原因应该是上边提过的那个</span></span><br><span class="line">                   --spins;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 自旋结束，如队列为空则初始化队列</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((p = wtail) == <span class="keyword">null</span>) &#123; <span class="comment">// initialize queue</span></span><br><span class="line">               WNode hd = <span class="keyword">new</span> WNode(WMODE, <span class="keyword">null</span>);</span><br><span class="line">               <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, WHEAD, <span class="keyword">null</span>, hd))</span><br><span class="line">                   wtail = hd;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 构造当前节点入队</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">               node = <span class="keyword">new</span> WNode(WMODE, p);</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (node.prev != p)</span><br><span class="line">               <span class="comment">// CLH队列，需要指定一下prev</span></span><br><span class="line">               node.prev = p;</span><br><span class="line">           <span class="comment">// 入队</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, WTAIL, p, node)) &#123;</span><br><span class="line">               p.next = node;</span><br><span class="line">               <span class="comment">// 成功入队，就需要进入下面的for循环，进入"深度自旋"</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> spins = -<span class="number">1</span>;;) &#123;</span><br><span class="line">           WNode h, np, pp; <span class="keyword">int</span> ps;</span><br><span class="line">           <span class="comment">// 前驱就是头结点，那么就一直在这儿自旋尝试获取锁</span></span><br><span class="line">           <span class="keyword">if</span> ((h = whead) == p) &#123;</span><br><span class="line">               <span class="comment">// 自旋</span></span><br><span class="line">               <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)</span><br><span class="line">                   <span class="comment">// HEAD_SPINS = 2^10，先自旋少一点意思意思</span></span><br><span class="line">                   spins = HEAD_SPINS;</span><br><span class="line">               <span class="comment">// MAX_HEAD_SPINS = 2^16</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; MAX_HEAD_SPINS)</span><br><span class="line">                   <span class="comment">// 如果一直没有获取到锁，自旋的时间是指数型增长，直到MAX_HEAD_SPINS</span></span><br><span class="line">                   spins &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">               <span class="comment">// 一轮自旋</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> k = spins;;) &#123; <span class="comment">// spin at head</span></span><br><span class="line">                   <span class="keyword">long</span> s, ns;</span><br><span class="line">                   <span class="comment">// state上并无锁状态</span></span><br><span class="line">                   <span class="keyword">if</span> (((s = state) &amp; ABITS) == <span class="number">0L</span>) &#123;</span><br><span class="line">                       <span class="comment">// 则去尝试获取，cas state+=WBIT</span></span><br><span class="line">                       <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s,</span><br><span class="line">                                                ns = s + WBIT)) &#123;</span><br><span class="line">                           <span class="comment">// 获取成功，将当前节点node置为带头大哥</span></span><br><span class="line">                           whead = node;</span><br><span class="line">                           <span class="comment">// GC</span></span><br><span class="line">                           node.prev = <span class="keyword">null</span>;</span><br><span class="line">                           <span class="keyword">return</span> ns;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 随机递减</span></span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                            --k &lt;= <span class="number">0</span>)</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 当前节点并不是太子，登不了基，前边排着队呢</span></span><br><span class="line">           <span class="comment">// 头节点上的cowait，有些可能过时了，可以尝试唤醒</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (h != <span class="keyword">null</span>) &#123; <span class="comment">// help release stale waiters</span></span><br><span class="line">               WNode c; Thread w;</span><br><span class="line">               <span class="comment">// 挨个唤醒在head上的reader链表，看看当前能不能获取读锁</span></span><br><span class="line">               <span class="keyword">while</span> ((c = h.cowait) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;</span><br><span class="line">                       (w = c.thread) != <span class="keyword">null</span>)</span><br><span class="line">                       U.unpark(w);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果当前头结点未改变</span></span><br><span class="line">           <span class="keyword">if</span> (whead == h) &#123;</span><br><span class="line">               <span class="comment">// 前驱改变，清空已经失效的节点</span></span><br><span class="line">               <span class="keyword">if</span> ((np = node.prev) != p) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (np != <span class="keyword">null</span>)</span><br><span class="line">                       (p = np).next = node;   <span class="comment">// stale</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 更新前驱节点状态为WAITING，0-&gt;WAITING</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((ps = p.status) == <span class="number">0</span>)</span><br><span class="line">                   U.compareAndSwapInt(p, WSTATUS, <span class="number">0</span>, WAITING);</span><br><span class="line">               <span class="comment">// 清空已经取消的节点</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (ps == CANCELLED) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((pp = p.prev) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       node.prev = pp;</span><br><span class="line">                       pp.next = node;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">long</span> time; <span class="comment">// 0 argument to park means no timeout</span></span><br><span class="line">                   <span class="keyword">if</span> (deadline == <span class="number">0L</span>)</span><br><span class="line">                       time = <span class="number">0L</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">                       <span class="comment">// 同acquireRead里的解析</span></span><br><span class="line">                       <span class="keyword">return</span> cancelWaiter(node, node, <span class="keyword">false</span>);</span><br><span class="line">                   Thread wt = Thread.currentThread();</span><br><span class="line">                   U.putObject(wt, PARKBLOCKER, <span class="keyword">this</span>);</span><br><span class="line">                   node.thread = wt;</span><br><span class="line">                   <span class="comment">// 未被cancel</span></span><br><span class="line">                   <span class="keyword">if</span> (p.status &lt; <span class="number">0</span></span><br><span class="line">                           <span class="comment">// 前驱节点不为头结点，或锁状态为仍然被持有,当锁置为可获取状态时，如果不是队列头部的节点，那么也可以进入park</span></span><br><span class="line">                           &amp;&amp; (p != h || (state &amp; ABITS) != <span class="number">0L</span>)</span><br><span class="line">                           <span class="comment">// 头结点未改变</span></span><br><span class="line">                           &amp;&amp; whead == h</span><br><span class="line">                           <span class="comment">// 前驱仍是p</span></span><br><span class="line">                           &amp;&amp; node.prev == p)</span><br><span class="line">                       <span class="comment">// 则park阻塞</span></span><br><span class="line">                       U.park(<span class="keyword">false</span>, time);  <span class="comment">// emulate LockSupport.park</span></span><br><span class="line">                   <span class="comment">// 从阻塞中唤醒</span></span><br><span class="line">                   node.thread = <span class="keyword">null</span>;</span><br><span class="line">                   U.putObject(wt, PARKBLOCKER, <span class="keyword">null</span>);</span><br><span class="line">                   <span class="keyword">if</span> (interruptible &amp;&amp; Thread.interrupted())</span><br><span class="line">                       <span class="keyword">return</span> cancelWaiter(node, node, <span class="keyword">true</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>由此可见，写锁的获取也是通过自旋，如果队列里有排队的节点，那么入队，保证个公平公正，这也是CLH队列的作用的地方。并不会有开始说的写锁饥饿的现象。<br><a name="uU7CM"></a></p><h3 id="unlockWrite"><a href="#unlockWrite" class="headerlink" title="unlockWrite"></a>unlockWrite</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果stamp是当前锁状态，并且表示持有写锁，那么释放写锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockWrite</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    WNode h;</span><br><span class="line">    <span class="keyword">if</span> (state != stamp || (stamp &amp; WBIT) == <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// ORIGIN = 128 &lt;&lt; 1 = 256</span></span><br><span class="line">    state = (stamp += WBIT) == <span class="number">0L</span> ? ORIGIN : stamp;</span><br><span class="line">    <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// status由WATING-&gt;0，剔除队列中cancel的节点</span></span><br><span class="line">        <span class="comment">// 并且唤醒下一等待节点线程，如果有的话</span></span><br><span class="line">        release(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="UmcCd"></a></p><h3 id="upgrade"><a href="#upgrade" class="headerlink" title="upgrade"></a>upgrade</h3><p>文章开头的示例中，第三个示例就是读锁升级写锁的例子。在ReentranReadWriteLock中，写锁可以降级为读锁，而StampedLock可以由读锁能直接升级为写锁。首先是需要持有读锁(readLock)，接着会尝试升级写锁(<em>tryConvertToWriteLock</em>)，如果升级成功，则直接操作业务并在最后释放锁(unlock)，否则需要释放读锁(unlockRead)获取写锁(writeLock)。我们主要来看_tryConvertToWriteLock_和unlock，其它的逻辑都已经在上边讨论过了。来看看具体是怎么实现的吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * If the lock state matches the given stamp, performs one of</span></span><br><span class="line"><span class="comment">    * the following actions. If the stamp represents holding a write</span></span><br><span class="line"><span class="comment">    * lock, returns it.  Or, if a read lock, if the write lock is</span></span><br><span class="line"><span class="comment">    * available, releases the read lock and returns a write stamp.</span></span><br><span class="line"><span class="comment">    * Or, if an optimistic read, returns a write stamp only if</span></span><br><span class="line"><span class="comment">    * immediately available. This method returns zero in all other</span></span><br><span class="line"><span class="comment">    * cases.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> stamp a stamp</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> a valid write stamp, or zero on failure</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 上边说的很明白了：</span></span><br><span class="line"><span class="comment">    * 1.如果stamp已经表示写锁，则直接返回</span></span><br><span class="line"><span class="comment">    * 2.如果是读锁，会看看写锁是不是可获取，如果可以则会释放读锁返回写锁的stamp</span></span><br><span class="line"><span class="comment">    * 3.如果是乐观读锁，会立即返回写锁当且仅当目前时间点写锁可取</span></span><br><span class="line"><span class="comment">    * 4.其他情况就都只会返回0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryConvertToWriteLock</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> a = stamp &amp; ABITS, m, s, next;</span><br><span class="line">       <span class="comment">// stamp和state表示写锁状态相同</span></span><br><span class="line">       <span class="keyword">while</span> (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) &#123;</span><br><span class="line">           <span class="comment">// 锁状态（低8位）目前并不持有任何锁</span></span><br><span class="line">           <span class="keyword">if</span> ((m = s &amp; ABITS) == <span class="number">0L</span>) &#123;</span><br><span class="line">               <span class="comment">// stamp表示有读锁，与state不一致，则整个方法返回0</span></span><br><span class="line">               <span class="keyword">if</span> (a != <span class="number">0L</span>)</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="comment">// 尝试获取写锁(目前state并无锁)</span></span><br><span class="line">               <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + WBIT))</span><br><span class="line">                   <span class="keyword">return</span> next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 写锁位已被占用，即写锁已被占用</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (m == WBIT) &#123;</span><br><span class="line">               <span class="comment">// 并不是当前stamp获取的当前写锁</span></span><br><span class="line">               <span class="comment">// 即写锁被其他线程占有</span></span><br><span class="line">               <span class="keyword">if</span> (a != m)</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="comment">// 如果已持有写锁，则直接返回</span></span><br><span class="line">               <span class="keyword">return</span> stamp;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 当前读锁升级为写锁</span></span><br><span class="line">           <span class="comment">// 目前state上仅有一个读锁状态位，且stamp上是有锁额</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (m == RUNIT &amp;&amp; a != <span class="number">0L</span>) &#123;</span><br><span class="line">               <span class="comment">// 则尝试释放读锁，加写锁</span></span><br><span class="line">               <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s,</span><br><span class="line">                                        next = s - RUNIT + WBIT))</span><br><span class="line">                   <span class="keyword">return</span> next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="comment">// 其他情况一概返回0</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * If the lock state matches the given stamp, releases the</span></span><br><span class="line"><span class="comment">    * corresponding mode of the lock.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> stamp a stamp returned by a lock operation</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalMonitorStateException if the stamp does</span></span><br><span class="line"><span class="comment">    * not match the current state of this lock</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果stamp确实是当前的"邮戳"(相当于邮票上的邮戳，与state上对比),则释放对应的锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> a = stamp &amp; ABITS, m, s; WNode h;</span><br><span class="line">       <span class="comment">// 写锁状态未改变</span></span><br><span class="line">       <span class="keyword">while</span> (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) &#123;</span><br><span class="line">           <span class="comment">// 低8位，等于0表示未获取任何锁</span></span><br><span class="line">           <span class="keyword">if</span> ((m = s &amp; ABITS) == <span class="number">0L</span>)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="comment">// 写锁被获取</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (m == WBIT) &#123;</span><br><span class="line">               <span class="comment">// 改变</span></span><br><span class="line">               <span class="keyword">if</span> (a != m)</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               state = (s += WBIT) == <span class="number">0L</span> ? ORIGIN : s;</span><br><span class="line">               <span class="comment">// 唤醒队列</span></span><br><span class="line">               <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                   <span class="comment">// unpark h.next</span></span><br><span class="line">                   release(h);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 未持有任何锁，a&gt;=WBIT表示stamp表示持有写锁，但是目前m!=WBIT，表示写锁已经被释放</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">0L</span> || a &gt;= WBIT)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="comment">// 接下来就是读锁的释放了</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; RFULL) &#123;</span><br><span class="line">               <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, s - RUNIT)) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (m == RUNIT &amp;&amp; (h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                       release(h);</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (tryDecReaderOverflow(s) != <span class="number">0L</span>)</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><a name="aUhDM"></a></p><h1 id="Optimistic-Reading-Mode"><a href="#Optimistic-Reading-Mode" class="headerlink" title="Optimistic Reading Mode"></a>Optimistic Reading Mode</h1><p>示例中的第二个例子就是乐观读。先尝试获取读锁(<em>tryOptimisticRead</em>)，接着校验(validate)下stamp是否变更，如果校验通过未发生变更则直接进行下一步，否则需要获取读锁(readLock)并操作完成之后释放(unlockRead)读锁。主要来看看_tryOptimisticRead和_validate，其它的流程逻辑参考前边的讨论。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a stamp that can later be validated, or zero</span></span><br><span class="line"><span class="comment">    * if exclusively locked.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> a stamp, or zero if exclusively locked</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果当前并无任何写锁被持有，则返回写锁状态(高25位)，否则返回0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryOptimisticRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> s;</span><br><span class="line">       <span class="comment">// SBITS = ~(2^7 - 1) WBIT = 2^8</span></span><br><span class="line">       <span class="keyword">return</span> (((s = state) &amp; WBIT) == <span class="number">0L</span>) ? (s &amp; SBITS) : <span class="number">0L</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns true if the lock has not been exclusively acquired</span></span><br><span class="line"><span class="comment">    * since issuance of the given stamp. Always returns false if the</span></span><br><span class="line"><span class="comment">    * stamp is zero. Always returns true if the stamp represents a</span></span><br><span class="line"><span class="comment">    * currently held lock. Invoking this method with a value not</span></span><br><span class="line"><span class="comment">    * obtained from &#123;<span class="doctag">@link</span> #tryOptimisticRead&#125; or a locking method</span></span><br><span class="line"><span class="comment">    * for this lock has no defined effect or result.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> stamp a stamp</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the lock has not been exclusively acquired</span></span><br><span class="line"><span class="comment">    * since issuance of the given stamp; else false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 方法体很小，但是方法注释倒是挺长的嘛</span></span><br><span class="line"><span class="comment">    * 其实就是验证stamp和当前state的锁状态是否一致</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// load barrier，保证state的可见性</span></span><br><span class="line">       U.loadFence();</span><br><span class="line">       <span class="comment">// SBITS = ~(2^7 - 1)</span></span><br><span class="line">       <span class="keyword">return</span> (stamp &amp; SBITS) == (state &amp; SBITS);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如上，tryOptimisticRead并不会去尝试获取读锁(即不会更改state)，而是通过validate验证写锁状态是否在这期间改变过，如果未改变，则可以认为可以共享读锁，否则(即写线程操作过数据)需要实际去获取读锁。<br><a name="L3X6g"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有以下几点值得我们注意一下：</p><ul><li>读写锁状态在一个volatile long型变量上表示，低7位表示读锁状态，溢出的读锁状态用readerOverflow表示，高25位表示写锁，并且写锁是序列递增的；</li><li>申请锁时，使用了大量自旋操作。如果是在队列头部位置的等待线程节点，会一致自旋下去。否则当前线程节点会入队进行阻塞等待，虽然读和写具体的入队方式可能有点差别。通过这样的方式，不仅避免了饥饿现象，一定程度行还体现了公平性；</li><li>读锁是共享的，写锁是互斥的。此外读锁还有种乐观读的方式，即尝试获取锁时，并不会更改当前读锁状态，而是通过验证期间写锁状态是否被更改的方式保证数据一致。此外还有一个读锁升级的功能，这是跟ReentrantReadWriteLock的区别。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;bnvsh&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;作者&lt;em&gt;Doug
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JDK" scheme="https://blog.dengxf.cn/tags/JDK/"/>
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读之ReentrantReadWriteLock</title>
    <link href="https://blog.dengxf.cn/4ba3385f.html"/>
    <id>https://blog.dengxf.cn/4ba3385f.html</id>
    <published>2019-05-12T04:59:29.000Z</published>
    <updated>2019-06-27T09:48:04.179Z</updated>
    
    <content type="html"><![CDATA[<p><a name="OCsKr"></a></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>作者<em>Doug Lea_如此描述这个类：An implementation of {@link java.util.concurrent.locks.ReadWriteLock} supporting similar  semantics to {@link java.util.concurrent.locks.ReentrantLock}.<br>ReentratReadWriteLock是一个可重入的读写锁，实现了ReadWriteLock接口，具有与ReentrantLock同样的语义。此外，ReentrantReadWriteLock只支持_65535个可重入写锁和65535个读锁，以及其他一些特性，如下示例中的特性。</em></p></blockquote><p>接着看一下使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锁降级，write -&gt; read</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">   Object data;</span><br><span class="line">   <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">   <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     rwl.readLock().lock();</span><br><span class="line">     <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">       <span class="comment">// Must release read lock before acquiring write lock</span></span><br><span class="line">       rwl.readLock().unlock();</span><br><span class="line">       rwl.writeLock().lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Recheck state because another thread might have</span></span><br><span class="line">         <span class="comment">// acquired write lock and changed state before we did.</span></span><br><span class="line">         <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">           data = ...</span><br><span class="line">           cacheValid = <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></span><br><span class="line">         rwl.readLock().lock();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       use(data);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       rwl.readLock().unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for a large collection,and concurrently accessed.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RWDictionary</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Data&gt; m = <span class="keyword">new</span> TreeMap&lt;String, Data&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">      r.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.get(key); &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String[] allKeys() &#123;</span><br><span class="line">      r.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.keySet().toArray(); &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">put</span><span class="params">(String key, Data value)</span> </span>&#123;</span><br><span class="line">      w.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.put(key, value); &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      w.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123; m.clear(); &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上示例就是ReentrantReadWriteLock的基础用法了。另外的一些用法即特性，如WriteLock也有newCondition的api，写锁降级，可重入，写锁线程能获取读锁但反过来却不行，等等特性。<br><a name="rqF5g"></a></p><h1 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h1><p>内部共有三个变量，实现java.util.concurrent.locks.Lock接口的ReadLock和WriteLock；以及继承自AQS的抽象类Sync实例，FairSync和NonfairSync继承自Sync，表示该锁具备公平/非公平语义，有一个带boolean参数的构造函数，根据这个boolean参数决定sync为哪个子类实例。<br>在展开加解锁流程前，先看一下上述提起的内部类。<br><a name="CgifB"></a></p><h3 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h3><p>内部类Sync继承自AQS，主要功能是通过这个类提供：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 高16位才表示共享锁个数，即读锁个数，低位表示写锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">  <span class="comment">// 一个SHARED_UNIT表示一个读锁，加读锁即：state+=SHARED_UNIT</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">  <span class="comment">// 最大的读锁个数</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 互斥锁掩码，即写锁掩码</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/** Returns the number of shared holds represented in count  */</span></span><br><span class="line">  <span class="comment">// 读锁个数，无符号右移，高位值</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line">  <span class="comment">// 写锁个数,低位值</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * A counter for per-thread read hold counts.</span></span><br><span class="line"><span class="comment">         * Maintained as a ThreadLocal; cached in cachedHoldCounter</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  <span class="comment">// 线程持有锁个数</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ThreadLocal subclass. Easiest to explicitly define for sake</span></span><br><span class="line"><span class="comment">         * of deserialization mechanics.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  <span class="comment">// 注意是继承自TheadLocal,各个线程维护各自的holdCounter</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">            <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存上一线程的holder，便于release,大概率会节省ThreadLocal的检索次数</span></span><br><span class="line">  <span class="comment">// 因为一般情况下是，上一线程release，下一线程acquire</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line"></span><br><span class="line">        Sync() &#123;</span><br><span class="line">            readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">            setState(getState()); <span class="comment">// ensures visibility of readHolds</span></span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">            <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (free)</span><br><span class="line">              <span class="comment">// 所有写锁已经完全释放</span></span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough:</span></span><br><span class="line"><span class="comment">             * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">             *    and owner is a different thread, fail.</span></span><br><span class="line"><span class="comment">             * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">             *    happen if count is already nonzero.)</span></span><br><span class="line"><span class="comment">             * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">             *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">             *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">             *    and set owner.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                  <span class="comment">// w == 0说明已经有读锁存在了</span></span><br><span class="line">                  <span class="comment">// current != getExclusiveOwnerThread() 说明写锁已经被其他线程持有</span></span><br><span class="line">                  <span class="comment">// 以上两种情况都会失败</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                  <span class="comment">// 超过了最大锁限制</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                <span class="comment">// Reentrant acquire</span></span><br><span class="line">              <span class="comment">// 可重入</span></span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 子类(FairSync or NonfairSync)实现writerShouldBlock</span></span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">// 设置当前线程为owner</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                  <span class="comment">// 已经全部释放</span></span><br><span class="line">                    firstReader = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    firstReaderHoldCount--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">int</span> count = rh.count;</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                  <span class="comment">// 该线程不再持有读锁，那么需要清理ThreadLocal</span></span><br><span class="line">                    readHolds.remove();</span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// count 减1</span></span><br><span class="line">                --rh.count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">              <span class="comment">// cas state -= SHARED_UNIT</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">                    <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">                    <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">                  <span class="comment">// 如果读并发过大，这里会始终return false,最终造成写线程饥饿</span></span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough:</span></span><br><span class="line"><span class="comment">             * 1. If write lock held by another thread, fail.</span></span><br><span class="line"><span class="comment">             * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">             *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">             *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">             *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">             *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">             *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">             *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">             *    the more typical non-reentrant case.</span></span><br><span class="line"><span class="comment">             * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">             *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">             *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">              <span class="comment">// 写锁已经被其他线程持有</span></span><br><span class="line">              <span class="comment">// 如果被当前线程持有，则往下接着执行</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">          <span class="comment">// readerShouldBlock有Sync子类(FairSync or NonfairSync)实现</span></span><br><span class="line">          <span class="comment">// 注意这里，公平锁的时候，读写锁都是公平的，先来后到</span></span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                <span class="comment">// cas state += SHARED_UNIT</span></span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// 初始获取读锁</span></span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 如果cas失败</span></span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This code is in part redundant with that in</span></span><br><span class="line"><span class="comment">             * tryAcquireShared but is simpler overall by not</span></span><br><span class="line"><span class="comment">             * complicating tryAcquireShared with interactions between</span></span><br><span class="line"><span class="comment">             * retries and lazily reading hold counts.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// 写锁已经被持有</span></span><br><span class="line">                    <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                      <span class="comment">// 并不是当前线程持有写锁</span></span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                  <span class="comment">// 否则那么是当前线程持有写锁，往下接着执行</span></span><br><span class="line">                    <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">                    <span class="comment">// would cause deadlock.</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">                  <span class="comment">// 队列里已经有其他线程节点，具体情况，取决于是Fair 还是 NonFair</span></span><br><span class="line">                    <span class="comment">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class="line">                    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                      <span class="comment">// 相当于重入</span></span><br><span class="line">                        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                                rh = readHolds.get();</span><br><span class="line">                              <span class="comment">// 不再持有读锁的线程节点，需要清理ThreadLocal</span></span><br><span class="line">                                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                                    readHolds.remove();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                      <span class="comment">// 已经清理了，那么需要重新入队</span></span><br><span class="line">                      <span class="comment">// 否则向下执行(重入)</span></span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                  <span class="comment">// 超过了最大读锁限制</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">              <span class="comment">// cas state += SHARED_UNIT</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                  <span class="comment">// 未有线程持有读锁</span></span><br><span class="line">                    <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                        firstReader = current;</span><br><span class="line">                        firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                        firstReaderHoldCount++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.set(rh);</span><br><span class="line">                        rh.count++;</span><br><span class="line">                        cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ... 省略其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8159625535654395037L</span>;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 抢占式</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">/* As a heuristic to avoid indefinite writer starvation,</span></span><br><span class="line"><span class="comment">             * block if the thread that momentarily appears to be head</span></span><br><span class="line"><span class="comment">             * of queue, if one exists, is a waiting writer.  This is</span></span><br><span class="line"><span class="comment">             * only a probabilistic effect since a new reader will not</span></span><br><span class="line"><span class="comment">             * block if there is a waiting writer behind other enabled</span></span><br><span class="line"><span class="comment">             * readers that have not yet drained from the queue.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">          <span class="comment">// from AQS</span></span><br><span class="line">            <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from AQS 当前queue下一节点是否互斥节点</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node h, s;</span><br><span class="line"><span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">(s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">!s.isShared()         &amp;&amp;</span><br><span class="line">s.thread != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2274990926593161451L</span>;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// from AQS，解析见下</span></span><br><span class="line"><span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from AQS</span></span><br><span class="line"><span class="comment">// 是否有前驱节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">          <span class="comment">// h.next 为null，可以理解为有前驱，因为head为上一刚刚释放锁的最后节点</span></span><br><span class="line">          <span class="comment">// 其实也可以理解为目前队列里没有节点</span></span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同样，也是利用AQS的state变量来标识锁的个数，不同的是，ReentrantReadWriteLock利用高16位表示读锁，低16位表示写锁。两个抽象方法writerShouldBlock和ReaderShouldBlock，子类FairSync和NonfairSync通过实现这两个方法来提供公平/非公平锁的功能。<br><a name="r3u6p"></a></p><h3 id="ReadLock"><a href="#ReadLock" class="headerlink" title="ReadLock"></a>ReadLock</h3><p>实现java.util.concurrent.locks.Lock接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">locks</span>.<span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires the read lock.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Acquires the read lock if the write lock is not held by</span></span><br><span class="line"><span class="comment">     * another thread and returns immediately.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the write lock is held by another thread then</span></span><br><span class="line"><span class="comment">     * the current thread becomes disabled for thread scheduling</span></span><br><span class="line"><span class="comment">     * purposes and lies dormant until the read lock has been acquired.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 见上Sync的该方法的解析</span></span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Attempts to release this lock.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the number of readers is now zero then the lock</span></span><br><span class="line"><span class="comment">     * is made available for write lock attempts.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 见上Sync的该方法的解析</span></span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> java.util.concurrent.locks.<span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略其他代码，有兴趣可以自行研读源码</span></span><br><span class="line">  <span class="comment">// like lockInterruptibly tryLock tryLock(long timeout, TimeUnit unit)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReadLock是不支持newCondition这一api的。<br><a name="sm03a"></a></p><h3 id="WriteLock"><a href="#WriteLock" class="headerlink" title="WriteLock"></a>WriteLock</h3><p>同样，WriteLock也是实现了java.util.concurrent.locks.Lock接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">locks</span>.<span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 见上Sync解析</span></span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 见上Sync解析</span></span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> java.util.concurrent.locks.<span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WriteLock是支持newCondition api的，这一api是构造一个AQS的内部类实例，具体可以看我之前的<a href="https://blog.dengxf.cn/b484f60f.html#ReentrantLock-newCondition">文章</a>。<a name="jpMHh"></a></p><h1 id="WriteLock-lock"><a href="#WriteLock-lock" class="headerlink" title="WriteLock.lock"></a>WriteLock.lock</h1><p>先看一下写锁的加锁流程。<br>WriteLock.lock()调用内部类Sync的acquire(1)方法，acquire方法AQS提供的一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// from AQS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryAcquire from Sync 如果已经有读锁或者写锁已经被其他线程持有，则返回false</span></span><br><span class="line">      <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">          <span class="comment">// 尝试获取写锁失败，则入队一个EXCLUSIVE互斥节点</span></span><br><span class="line">          acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">          selfInterrupt();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from AQS</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// tryAcquire from Sync,解析见上</span></span><br><span class="line">              <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 设置当前节点为头结点</span></span><br><span class="line">                  setHead(node);</span><br><span class="line">                  p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                  failed = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span> interrupted;</span><br><span class="line">              &#125;</span><br><span class="line">            <span class="comment">// 更改node的status为SIGNAL</span></span><br><span class="line">              <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                  <span class="comment">// park的地方</span></span><br><span class="line">                  parkAndCheckInterrupt())</span><br><span class="line">                  interrupted = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (failed)</span><br><span class="line">              cancelAcquire(node);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可见写锁加锁过程就是对state变量进行操作的过程，公平/非公平锁主要是通过writerShouldBlock这个方法，非公平这个方法直接返回false，也就是抢占式地去获取锁，而公平则是会查看队列里是否有前驱，如有则失败。<br><a name="PrALw"></a></p><h1 id="WriteLock-unlock"><a href="#WriteLock-unlock" class="headerlink" title="WriteLock.unlock"></a>WriteLock.unlock</h1><p>接着是写锁的解锁过程。<br>同样，也是调用Sync内部方法release(1),release也为AQS的一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// tryRelease from Sync,见上解析</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">      <span class="comment">// 在acquire的阻塞位置已经将waitStatus更新为SIGNAL了</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">          <span class="comment">// 这个方法其实真正唤醒的是h.next</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="LTLJu"></a></p><h1 id="ReadLock-lock"><a href="#ReadLock-lock" class="headerlink" title="ReadLock.lock"></a>ReadLock.lock</h1><p>方法内部调用的是AQS的acquireShared(1)方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryAcquireShared见上Sync解析</span></span><br><span class="line">      <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 见下</span></span><br><span class="line">          doAcquireShared(arg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from AQS</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在队列尾部添加一SHARED节点</span></span><br><span class="line">      <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">      <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">              <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 见上Sync解析</span></span><br><span class="line">                  <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                  <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 设置当前节点为头头结点</span></span><br><span class="line">                    <span class="comment">// 并唤醒下一节点</span></span><br><span class="line">                      setHeadAndPropagate(node, r);</span><br><span class="line">                      p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                      <span class="keyword">if</span> (interrupted)</span><br><span class="line">                          selfInterrupt();</span><br><span class="line">                      failed = <span class="keyword">false</span>;</span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            <span class="comment">// 更新前驱节点waitStatus为SIGNAL</span></span><br><span class="line">              <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                  <span class="comment">// park</span></span><br><span class="line">                  parkAndCheckInterrupt())</span><br><span class="line">                  interrupted = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (failed)</span><br><span class="line">              cancelAcquire(node);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>结合Sync的解析，读锁的获取过程就是对state这一变量的操作过程。解析还是很清晰的，具体过程可以看一下解析。<br><a name="n5So2"></a></p><h1 id="ReadLock-unlock"><a href="#ReadLock-unlock" class="headerlink" title="ReadLock.unlock"></a>ReadLock.unlock</h1><p>unlock调用的仍是AQS内部方法，releaseShared(1):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryReleaseShared from Sync,见上解析</span></span><br><span class="line">    <span class="comment">// 如果读线程并发大，那么tryReleaseShared总会返回false，则始终不会执行到doReleaseShared，则造成写线程饥饿</span></span><br><span class="line">      <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 见下</span></span><br><span class="line">          doReleaseShared();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from AQS</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">       * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">       * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">       * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">       * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">       * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">       * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">       * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">       * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          Node h = head;</span><br><span class="line">          <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">              <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">              <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 阻塞前已经将waitStatus更新为SIGNAL</span></span><br><span class="line">                  <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                      <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 唤醒h.next</span></span><br><span class="line">                  unparkSuccessor(h);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                       !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                  <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可见，解锁读锁，是对state操作，state-=_SHARED_UNIT，_接着再查看队列是否有等待节点，如有则需唤醒。<br><a name="Bc30g"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>state内部变量的高16位表示所有线程持有读锁个数，低16位表示持有写锁个数</li><li>读写锁都为可重入的</li><li>写锁为互斥锁，同时持有线程持有读锁。加解锁过程均为cas操作state变量。加锁过程state+=1,解锁过程state-=1。加锁时如果其它线程持有锁，则往队列里添加一个EXCLUSIVE节点表示当前线程等待写锁，并在当前位置park住等待唤醒，解锁时，如果队列里有等待节点则需要唤醒节点对应线程</li><li>读锁为共享锁，多个线程能同时获得读锁。加锁过程即为state+=SHARED_UNIT(2^16)。加解锁过程是cas操作state变量高16位。加锁过程为state+=2^16,解锁过程state-=2^16。加锁时如果其它线程持有写锁，则往队列里添加一个SHARED节点标识当前线程等待读锁，并在当前位置park住等待唤醒，解锁时如果队列里有等待节点则需唤醒对应节点线程</li><li>能看到，无论Fari还是Nonfair，写锁的获取都有可能因为读锁阻塞，在一定情况下，造成了获取写锁的线程饥饿的现象</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;OCsKr&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;作者&lt;em&gt;Doug
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JDK" scheme="https://blog.dengxf.cn/tags/JDK/"/>
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读之ReentrantLok</title>
    <link href="https://blog.dengxf.cn/b484f60f.html"/>
    <id>https://blog.dengxf.cn/b484f60f.html</id>
    <published>2019-05-08T07:34:45.000Z</published>
    <updated>2019-06-27T09:48:04.183Z</updated>
    
    <content type="html"><![CDATA[<p><a name="gKJPL"></a></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>作者<em>Doug Lea_如此描述这个类：_A reentrant mutual exclusion {</em><strong>@link **<em>java.util.concurrent.locks.Lock} with the same basic behavior and semantics as the implicit monitor lock accessed using {</em></strong>@code **<em>synchronized} methods and statements, but with extended capabilities.</em><br>ReentrantLock是继承_java.util.concurrent.locks.Lock_的可重入互斥锁，它具有跟隐式监视器锁(Synchronized)同样语义，用于锁定一个方法或代码块，除此之外，它还有一些额外的功能。<br>ReentrantLock锁，只能被一个线程持有，如果该线程持有的同时尝试去获取该ReentrantLock，会立即返回。当一个线程获取ReentrantLock，即调用lock时，只有当该锁未被其它线程持有时才能成功。<br>看一下源码中的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     lock.lock();  <span class="comment">// block until condition holds</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// ... method body</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，还有个lock.newCondition api可以使用，看下面用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Y</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            condition.signal();</span><br><span class="line">            <span class="comment">// or condition.signalAll()</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，condition使用需在持有lock时。<br><a name="iSDmY"></a></p><h1 id="ReentrantLock-lock"><a href="#ReentrantLock-lock" class="headerlink" title="ReentrantLock.lock"></a>ReentrantLock.lock</h1><p>还是结合示例，看看整个流程是怎么串起来的。<br>有如下两个构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造时通过传入一个boolean参数，可以实例化一个公平Lock。而这里的FairSync和NonfairSync是继承自内部类Sync，而Sync则继承自AQS。如下代码：<br><strong>Sync类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5179523762034025860L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs &#123;<span class="doctag">@link</span> java.util.concurrent.locks.Lock#lock&#125;. The main reason for subclassing</span></span><br><span class="line"><span class="comment">     * is to allow fast path for nonfair version.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">// 子类实现这个方法，以提供公平/非公平锁的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment">     * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">// 非公平地尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">      <span class="comment">// 利用AQS中的state变量表示锁的获取次数</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 目前所无持有者</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">              <span class="comment">// 设置当前owner线程</span></span><br><span class="line">              <span class="comment">// setExclusiveOwnerThread方法为AbstractOwnableSynchronizer类的方法</span></span><br><span class="line">              <span class="comment">// 该类就一个私有变量Thread exclusiveOwnerThread</span></span><br><span class="line">              <span class="comment">// 用于表示互斥资源的互斥持有线程</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">          <span class="comment">// 当前线程为锁的持有线程，即可重入</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">          <span class="comment">// 直接设置state</span></span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 否则获取失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 尝试释放</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 只有state==0时，才能认为锁可以被释放</span></span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">// 设置owner线程为null</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 设置state</span></span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">        <span class="comment">// we don't need to do so to check if current thread is owner</span></span><br><span class="line">        <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// for api ReentranLock.newCondition</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Methods relayed from outer class</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="keyword">null</span> : getExclusiveOwnerThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 锁是否被持有，即需判断state是否等于0</span></span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reconstitutes the instance from a stream (that is, deserializes it).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部抽象类Sync继承Sync，实现了一些基础功能，内部有个抽象方法lock。子类实现这个方法可提供公平/非公平锁的功能。<br><strong>NonFairSync类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">       * acquire on failure.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cas 操作state</span></span><br><span class="line">          <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            <span class="comment">// 获取成功，设置当前线程为owner线程</span></span><br><span class="line">              setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// state 不等于0， 锁已经被其他线程持有</span></span><br><span class="line">            <span class="comment">// acquire为AQS内方法，如下解析</span></span><br><span class="line">              acquire(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// non fair模式，是直接调用Sync类的nonfairTryAcquire方法，如上Sync类的解析</span></span><br><span class="line">          <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from AQS</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryAcquire为FairSync/NonfairSync重写方法</span></span><br><span class="line">      <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">          <span class="comment">// 构造一个node入链表</span></span><br><span class="line">          acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">          selfInterrupt();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from AQS</span></span><br><span class="line"><span class="comment">// 给定mode构建node节点，入链表，返回当前节点</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">      Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">      <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">      Node pred = tail;</span><br><span class="line">      <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">          node.prev = pred;</span><br><span class="line">          <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">              pred.next = node;</span><br><span class="line">              <span class="keyword">return</span> node;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      enq(node);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from AQS</span></span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 前驱为头结点</span></span><br><span class="line">            <span class="comment">// tryAcquire为FairSync/NonfairSync重写方法</span></span><br><span class="line">              <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 已获取，设置当前node为head</span></span><br><span class="line">                <span class="comment">// 唤醒总是唤醒头结点的下一节点线程</span></span><br><span class="line">                  setHead(node);</span><br><span class="line">                  p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                  failed = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span> interrupted;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                  <span class="comment">// 这里阻塞 LockSupport.park</span></span><br><span class="line">                  parkAndCheckInterrupt())</span><br><span class="line">                  interrupted = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (failed)</span><br><span class="line">              cancelAcquire(node);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>FairSync类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 与Non fair的区别</span></span><br><span class="line">      <span class="comment">// 调用AQS的acquire</span></span><br><span class="line">      <span class="comment">// 即先判断锁是否被持有，有没有前驱，如果持有是不是当前线程</span></span><br><span class="line">      <span class="comment">// 然后再根据判断情况构造节点加入链表尾部，并阻塞。</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 与non fair 区别：是否有前驱，如有则获取失败</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码分析，非公平锁，通过cas操作state去获取锁，即0-&gt;1，如果获取失败，则再次尝试(cas操作state，持有者是否为当前线程)，如果仍然获取失败，则构造一个node并接入链表尾部，并阻塞当前线程直到被唤醒。公平锁则不会直接去获取锁，而是在非公平锁基础上，会先查看链表是否有前驱，有则阻塞并构造新节点加入链表尾部。<br>辅助下面的图看源码可能会有帮助。<br>非公平锁：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1557397519449-44579018-1466-417e-99ac-f805f6dd8e9b.png#align=left&display=inline&height=664&name=image.png&originHeight=664&originWidth=970&size=45553&status=done&width=970" alt="image.png">公平锁：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1557397587930-ff5c28f0-e41d-4caf-8929-2e6c72da04c5.png#align=left&display=inline&height=539&name=image.png&originHeight=539&originWidth=933&size=37854&status=done&width=933" alt="image.png"><br><a name="bVccP"></a></p><h1 id="ReentrantLock-unlock"><a href="#ReentrantLock-unlock" class="headerlink" title="ReentrantLock.unlock"></a>ReentrantLock.unlock</h1><p>释放锁的逻辑相对获取锁要简短很多。unlock方法就是调用AQS的release方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 尝试释放锁 Sync实现tryRelease,见如上Sync类解析</span></span><br><span class="line">  <span class="comment">// 即state减arg,如果state减为0，则释放锁（owner线程置null）</span></span><br><span class="line">  <span class="comment">// 另外，这里AQS的state表示持有锁的次数</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">      <span class="comment">// 释放成功</span></span><br><span class="line">        Node h = head;</span><br><span class="line">      <span class="comment">// 头结点不为空，说明当前线程入过链表，所以并且头结点的状态应该是SIGNAL</span></span><br><span class="line">      <span class="comment">// shouldParkAfterFailedAcquire这里修改node的状态</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">          <span class="comment">// 唤醒下一节点线程，还记得获取锁的时候，线程节点入链表之后阻塞的位置是哪里吗？</span></span><br><span class="line">          <span class="comment">// 在AQS里的acquireQueued这个方法</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="dz9kr"></a></p><h1 id="ReentrantLock-newCondition"><a href="#ReentrantLock-newCondition" class="headerlink" title="ReentrantLock.newCondition"></a>ReentrantLock.newCondition</h1><p>接下来看一下newCondition这个api的内部流程是什么样的。<br>ReentrantLock.newCondition方法内部调用Sync类实现的newCondition方法，而这个方法是实例化一个AQS的ConditionObject类对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">/** First node of condition queue. */</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">      <span class="comment">/** Last node of condition queue. */</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">// 添加一个condition节点，见下面该方法解析</span></span><br><span class="line">          Node node = addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放所有获取次数记录，置state为0，见下面该方法解析</span></span><br><span class="line">        <span class="comment">// 注意这里，调用condition.await时，是在lock块内</span></span><br><span class="line">          <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">          <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// isOnSyncQueue判断是否在Sync队列里，见下面该方法解析</span></span><br><span class="line">          <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// 阻塞在这里，直到signal唤醒</span></span><br><span class="line">            <span class="comment">// signal唤醒后，isOnSyncQueue返回true，调出循环</span></span><br><span class="line">              LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">              <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">// acquireQueued见上面Sync对应方法解析，方法里的这里的queue指Sync的队列</span></span><br><span class="line">        <span class="comment">// 这个队列会在signal唤醒时构造</span></span><br><span class="line">          <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">              interruptMode = REINTERRUPT;</span><br><span class="line">          <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">              unlinkCancelledWaiters();</span><br><span class="line">          <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">              reportInterruptAfterWait(interruptMode);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Node t = lastWaiter;</span><br><span class="line">          <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">          <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">              unlinkCancelledWaiters();</span><br><span class="line">              t = lastWaiter;</span><br><span class="line">          &#125;</span><br><span class="line">          Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">          <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">              firstWaiter = node;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              t.nextWaiter = node;</span><br><span class="line">          lastWaiter = node;</span><br><span class="line">          <span class="keyword">return</span> node;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除一些取消的节点</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Node t = firstWaiter;</span><br><span class="line">          Node trail = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">              Node next = t.nextWaiter;</span><br><span class="line">              <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                  t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                      firstWaiter = next;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                      trail.nextWaiter = next;</span><br><span class="line">                  <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                      lastWaiter = trail;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 上一节点</span></span><br><span class="line">                  trail = t;</span><br><span class="line">              t = next;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">          Node first = firstWaiter;</span><br><span class="line">          <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">              doSignal(first);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">          Node first = firstWaiter;</span><br><span class="line">          <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">              doSignalAll(first);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 省略其他代码</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from AQS</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">// 置state为0</span></span><br><span class="line">          <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">              failed = <span class="keyword">false</span>;</span><br><span class="line">              <span class="keyword">return</span> savedState;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (failed)</span><br><span class="line">              node.waitStatus = Node.CANCELLED;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放，置state -= arg，结合上下文，也就是state=0</span></span><br><span class="line">      <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">          Node h = head;</span><br><span class="line">        <span class="comment">// 这里h为null，waitState为CONDITION</span></span><br><span class="line">        <span class="comment">// 因为condition的api使用要求都在lock块内，所以h必定为null</span></span><br><span class="line">          <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">              unparkSuccessor(h);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// node是否在Sync等待队列里(也就是调用了condition.signal，将waitStatus置为SIGNAL)</span></span><br><span class="line"><span class="comment">// 根据waitStatus以及队列元素比较</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * node.prev can be non-null, but not yet on queue because</span></span><br><span class="line"><span class="comment">       * the CAS to place it on queue can fail. So we have to</span></span><br><span class="line"><span class="comment">       * traverse from tail to make sure it actually made it.  It</span></span><br><span class="line"><span class="comment">       * will always be near the tail in calls to this method, and</span></span><br><span class="line"><span class="comment">       * unless the CAS failed (which is unlikely), it will be</span></span><br><span class="line"><span class="comment">       * there, so we hardly ever traverse much.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>await方法的比较复杂，需要仔细梳理下，并且结合signal的流程才能清晰起来。<br>以下为signal的流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果本线程不是持有锁线程，则throw</span></span><br><span class="line">          <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="comment">// 还记得吗，firstWaiter为condition队列里的头结点</span></span><br><span class="line">          Node first = firstWaiter;</span><br><span class="line">          <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 唤醒，结合上边await的流程看</span></span><br><span class="line">            <span class="comment">// 就是改变waitStatus，以及入Sync队列</span></span><br><span class="line">              doSignal(first);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">                  lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">              first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// transferForSIgnal改变first状态，并入Sync队列</span></span><br><span class="line">          &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                   (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from AQS</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">       * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">       * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">       * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    <span class="comment">// 入队，Sync的队列</span></span><br><span class="line">      Node p = enq(node);</span><br><span class="line">      <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">// 将waitStatus置为SIGNAL</span></span><br><span class="line">      <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">          LockSupport.unpark(node.thread);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>signal流程大致就是这样，signalAll其实就是从Condition头结点firstWaiter开始依次调用transferForSignal方法，大同小异。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;gKJPL&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;作者&lt;em&gt;Doug Lea_如此描述这个类：_A
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JDK" scheme="https://blog.dengxf.cn/tags/JDK/"/>
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读之Semaphore</title>
    <link href="https://blog.dengxf.cn/61e94ea2.html"/>
    <id>https://blog.dengxf.cn/61e94ea2.html</id>
    <published>2019-05-04T22:11:57.000Z</published>
    <updated>2019-06-27T09:48:04.183Z</updated>
    
    <content type="html"><![CDATA[<p><a name="U1hgY"></a></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>作者_Doug Lea_如此描述这个类：A counting semaphore.  Conceptually, a semaphore maintains a set of permits.<br>顾名思义。计数信号量，它维护许可数量。acquire一个许可阻塞至池里有可用许可，release一个许可即往池里添加一个许可。<br>如下为源码中示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AVAILABLE = <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Semaphore available = <span class="keyword">new</span> Semaphore(MAX_AVAILABLE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     available.acquire();</span><br><span class="line">     <span class="keyword">return</span> getNextAvailableItem();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putItem</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (markAsUnused(x))</span><br><span class="line">       available.release();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Not a particularly efficient data structure; just for demo</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span> Object[] items = ... whatever kinds of items being managed</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_AVAILABLE];</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Object <span class="title">getNextAvailableItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">          used[i] = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">return</span> items[i];</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// not reached</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">markAsUnused</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">       <span class="keyword">if</span> (item == items[i]) &#123;</span><br><span class="line">          <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，示例中用到的api就两个，即acquire和release，意为获取一个许可及释放一个许可。<br><a name="WJ47a"></a></p><h1 id="Sync变量"><a href="#Sync变量" class="headerlink" title="Sync变量"></a>Sync变量</h1><p>内部抽象类Sync继承自AQS，用AQS中的volatile int state变量表示许可数量。Sync的子类有两个版本，fair和nonfair。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">      <span class="comment">// state 表示当前许可数量</span></span><br><span class="line">        setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非公平式获取许可，cas操作，state减去acquires</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">          <span class="comment">// 注意这里remaining &lt; 0</span></span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放许可就是state + releases</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> next = current + releases;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">            <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 非公平式获取许可，调用父类（Sync）的nonfairTryAcquireShared</span></span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">// 先查看有没有前驱在阻塞等着获取许可，如果有，当前线程获取失败</span></span><br><span class="line">          <span class="comment">// 这就是跟非公平的区别</span></span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync的两个子类，NonfairSync和FairSync，分别表示在获取许可时是非公平式（抢占式）和公平式。<br><a name="Oqmwt"></a></p><h1 id="Semaphore-acquire"><a href="#Semaphore-acquire" class="headerlink" title="Semaphore.acquire"></a>Semaphore.acquire</h1><p>获取许可，调用Sync.acquireSharedInterruptibly(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">  <span class="comment">// 调用内部实现类tryAcquireShared</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 池中许可数量小于0，即state&lt;0</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// 在链表尾部添加一个node表示当前阻塞的节点</span></span><br><span class="line">  <span class="comment">// 注意头结点为一个标识节点，如下addWaiter方法</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">// 前驱</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">              <span class="comment">// 调用内部类（fair or nonfair）实现tryAcquireShared，获取许可</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// 许可数量恢复&gt;0，设置当前节点为头节点并且唤醒下一节点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 没有许可可获取，阻塞在这里，等待唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 链表中没有前驱</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">              <span class="comment">// 先要设置一个"空"头结点</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意，当没有阻塞的节点时，即链表为空，这时往链表添加节点时是往一个”空”头节点后添加。唤醒时，在阻塞位置恢复再次循环，如果前驱是头结点且当前池中有许可，那么设置当前节点为头结点，并唤醒下一节点，否则再次阻塞。<br><a name="oYWC0"></a></p><h1 id="Semaphore-release"><a href="#Semaphore-release" class="headerlink" title="Semaphore.release"></a>Semaphore.release</h1><p>调用Sync.releaseShared(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// sync中的tryReleaseShared, state += arg</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">      <span class="comment">// 如果有阻塞的节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">          <span class="comment">// 阻塞时，在shouldParkAfterFailedAcquire这个方法里，将node的前驱已经设置为SIGNAL</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">              <span class="comment">// 唤醒h的下一节点，如下unparkSuccessor分析</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;      </span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 从后往前找，去掉已经cancel的节点，见AQS类waitStatus的可取类型</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">      <span class="comment">// 唤醒node的下一可用节点</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唤醒时总是唤醒头结点的下一节点。注意waitStatus这个状态，在阻塞时，会在shouldParkAfterFailedAcquire这个方法里，将当前阻塞节点的前缀设置为SIGNAL。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;U1hgY&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;作者_Doug Lea_如此描述这个类：A counting
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JDK" scheme="https://blog.dengxf.cn/tags/JDK/"/>
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读之CyclicBarrier</title>
    <link href="https://blog.dengxf.cn/97e68def.html"/>
    <id>https://blog.dengxf.cn/97e68def.html</id>
    <published>2019-05-03T22:40:33.000Z</published>
    <updated>2019-06-27T09:48:04.183Z</updated>
    
    <content type="html"><![CDATA[<p><a name="LPm8j"></a></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>_作者Doug Lea_如此描述这个类：A synchronization aid that allows a set of threads to all wait for  each other to reach a common barrier point.<br>这也是一个多线程协调的辅助工具类。barrier可翻译为栅栏，顾名思义，这个类控制先到的线程则在”栅栏”处等待其他线程，直到所有线程都到达，再接着往下执行。此外，CyclicBarrier如其名，是循环可复用的。<br>如下是源码中给出的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solver</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> N;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">float</span>[][] data;</span><br><span class="line">   <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> myRow;</span><br><span class="line">     Worker(<span class="keyword">int</span> row) &#123; myRow = row; &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">while</span> (!done()) &#123;</span><br><span class="line">         processRow(myRow);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 等待一行处理结束</span></span><br><span class="line">           barrier.await();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (BrokenBarrierException ex) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Solver</span><span class="params">(<span class="keyword">float</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">     data = matrix;</span><br><span class="line">     N = matrix.length;</span><br><span class="line">     <span class="comment">// 所有行处理完，再merge</span></span><br><span class="line">     Runnable barrierAction =</span><br><span class="line">       <span class="keyword">new</span> Runnable() &#123; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; mergeRows(...); &#125;&#125;;</span><br><span class="line">     barrier = <span class="keyword">new</span> CyclicBarrier(N, barrierAction);</span><br><span class="line"></span><br><span class="line">     List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;Thread&gt;(N);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">       Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(i));</span><br><span class="line">       threads.add(thread);</span><br><span class="line">       thread.start();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// wait until done</span></span><br><span class="line">     <span class="keyword">for</span> (Thread thread : threads)</span><br><span class="line">       thread.join();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如以上示例，并行处理每行矩阵元素，待所有行处理结束再对每行处理结果进行合并。<br><a name="hn33q"></a></p><h1 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h1><p>//  可重入锁控制对barrier的访问<br>private final ReentrantLock lock = new ReentrantLock();<br>// 控制线程阻塞，直到所有线程”到达”<br>private final Condition trip = lock.newCondition();<br>// 多少个参与方(线程)<br>private final int parties;<br>// 到达栅栏后执行的线程<br>private final Runnable barrierCommand;<br>// 内部类表示目前是哪一代<br>private Generation generation = new Generation()<br>// 还有几个参与方(线程)在未到达<br>private int count;</p><p>Generation为内部类，当触发栅栏或者重置，generation就会改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 标识栅栏有没有被"踢翻"</span></span><br><span class="line">    <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a name="qJUEu"></a># CyclicBarrier.await由源码中的示例代码，await是CyclicBarrier的主要起作用的方法。<br>首先先看一下构造方法中对内部变量的初始化：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">      <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="comment">// 初始parties个线程</span></span><br><span class="line">      <span class="keyword">this</span>.count = parties;</span><br><span class="line">      <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>构造方法里就初始化了三个变量，分别是表示多少个线程的parties、还有多少个线程未到达的count、后置线程barrierCommand。<br>await方法是调用内部私有方法dowait:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">        TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 当前代</span></span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">          <span class="comment">// 抱歉，栅栏已经被踢翻了</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">          <span class="comment">// 线程中断了，需要唤醒所有线程</span></span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">          <span class="comment">// 所有线程已到达</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                  <span class="comment">// 后置线程</span></span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">              <span class="comment">// 重置状态并唤醒所有线程</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                  <span class="comment">// condition.await 调用AQS里的Condition实现类</span></span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                  <span class="comment">// 允许只等待一定时间</span></span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">              <span class="comment">// 物是人非，已经不是睡之前的时代了</span></span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CyclicBarrier利用ReentrantLock控制对barrier的加锁访问，ReentrantLock.condition控制线程的阻塞唤醒。内部类Generation表示栅栏的一次生命周期，而每次栅栏被踢翻，generation要换代，即CyclicBarrier是可循环复用的。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;LPm8j&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;_作者Doug Lea_如此描述这个类：A
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JDK" scheme="https://blog.dengxf.cn/tags/JDK/"/>
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读之CountDownLatch</title>
    <link href="https://blog.dengxf.cn/bdd3aaa7.html"/>
    <id>https://blog.dengxf.cn/bdd3aaa7.html</id>
    <published>2019-05-01T05:02:39.000Z</published>
    <updated>2019-06-27T09:48:04.183Z</updated>
    
    <content type="html"><![CDATA[<p><a name="nDtHU"></a></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>_作者Doug Lea_如此描述这个类：A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.</p></blockquote><p>这是一个多线程协调的辅助类。源码中给出的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">     CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();</span><br><span class="line"></span><br><span class="line">     doSomethingElse();            <span class="comment">// don't let run yet</span></span><br><span class="line">     startSignal.countDown();      <span class="comment">// let all threads proceed</span></span><br><span class="line">     doSomethingElse();</span><br><span class="line">     doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">   Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">     <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line">     <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       startSignal.await();</span><br><span class="line">       doWork();</span><br><span class="line">       doneSignal.countDown();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>通过示例对CountDownLatch的使用场景应该有个清晰的认识。即当有需要线程等待，直到在其他线程的一系列操作完成之后，再接着往下执行。<br><a name="lqsge"></a></p><h1 id="Sync变量"><a href="#Sync变量" class="headerlink" title="Sync变量"></a>Sync变量</h1><p>Sync类是CountDownLatch的一个内部类，继承自 <code>AbstractQueuedSynchronizer</code> ，也就是常说的AQS。内部类重写了AQS的 <code>tryAcquireShared</code> 和 <code>tryReleaseShared</code> 两个方法。此外Sync的构造函数带一个int参数，在构造函数内调用了AQS的 <code>setState</code> 方法，这个方法是对AQS的内部一个int volatile变量赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在上边的示例中，我们用到了 <code>CountDownLatch</code> 的 <code>await</code> 方法和 <code>countDown</code> 方法，CountDownLatch的功能也就是通过这两个方法实现。这两个方法其实也就是调用sync。<br><a name="Wmmj6"></a></p><h1 id="CountDownLatch-await"><a href="#CountDownLatch-await" class="headerlink" title="CountDownLatch.await"></a>CountDownLatch.await</h1><p><strong>功能</strong>：当前线程等待，直到state等于0，或该线程interrupt。<br>该方法就是调用 <code>sync.acquireSharedInterruptibly(1)</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">  <span class="comment">// 调用实现类Sync的tryAcquireShared</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// state 不等于 0 则执行</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// 用一个链表来表示需要"wait"的线程，在链表尾部加入一个node</span></span><br><span class="line">  <span class="comment">// 注意 如果head == null ,则初始化一个head，令head.next = node</span></span><br><span class="line">  <span class="comment">// 所以能理解state==0,一一唤醒所有等待的线程时，是唤醒头结点的下一节点所表示的线程</span></span><br><span class="line">  <span class="comment">// 这样就达到了唤醒所有线程的目的</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">// 前驱</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">          <span class="comment">// 如果当前节点为头节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">              <span class="comment">// 调用CountDownLatch实现类里的tryAcquireShared</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// 当state == 0时，设置node为头结点</span></span><br><span class="line">                  <span class="comment">// 并且唤醒(LockSupport.unpark)node下一节点的所表示的线程</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// wait，直到state == 0 时被唤醒（LockSupport.unpark）</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结：CountDownLatch.await就是调用LockSupport.park阻塞当前线程，并用一链表表示所有阻塞的线程，方便唤醒时一一唤醒。<br><a name="QRD9K"></a></p><h1 id="CountDownLatch-countDown"><a href="#CountDownLatch-countDown" class="headerlink" title="CountDownLatch.countDown"></a>CountDownLatch.countDown</h1><p>功能：令state减1，但state为0时，唤醒所有等待线程。<br>该方法是调用 <code>sync.releaseShared(1)</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 调用实现类Sync的tryReleaseShared</span></span><br><span class="line">     <span class="comment">// state减1</span></span><br><span class="line">       <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">         <span class="comment">// 当state减为0时</span></span><br><span class="line">           doReleaseShared();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒等待链表的头结点的下一节点</span></span><br><span class="line"><span class="comment">// 下一节点唤醒后在doAcquireSharedInterruptibly这个方法中继续循环</span></span><br><span class="line"><span class="comment">// 直到执行setHeadAndPropagate，在此方法中又会调用doReleaseShared,唤醒接下来的节点</span></span><br><span class="line"><span class="comment">// 依次一一唤醒，直到唤醒所有等待线程节点</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">        * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">        * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">        * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">        * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">        * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">        * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">        * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">        * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Node h = head;</span><br><span class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">               <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">               <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                 <span class="comment">// cas头结点状态为初始状态</span></span><br><span class="line">                   <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                       <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                   <span class="comment">// 此方法中是唤醒头结点的下一线程节点</span></span><br><span class="line">                 unparkSuccessor(h);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                   <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">           &#125;</span><br><span class="line">         <span class="comment">// 如果线程节点改变重新循环</span></span><br><span class="line">           <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒node下一线程节点</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">        * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">        * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">       <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">           compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">        * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">        * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">        * non-cancelled successor.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       Node s = node.next;</span><br><span class="line">       <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           s = <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">// node后继节点可能为null或cancel</span></span><br><span class="line">           <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">               <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                   s = t;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">         <span class="comment">// 唤醒节点s表示线程</span></span><br><span class="line">           LockSupport.unpark(s.thread);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch源码分析的整个流程就是这样。CountDownLatch的功能是基于AQS展开，在后续的JUC的分析文章中还可以看到AQS的身影。谢谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;nDtHU&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;_作者Doug
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JDK" scheme="https://blog.dengxf.cn/tags/JDK/"/>
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>QMQ源码分析之Actor</title>
    <link href="https://blog.dengxf.cn/93d6d117.html"/>
    <id>https://blog.dengxf.cn/93d6d117.html</id>
    <published>2019-03-22T19:00:16.000Z</published>
    <updated>2019-06-27T09:48:04.195Z</updated>
    
    <content type="html"><![CDATA[<p><a name="df368884"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>QMQ有关actor的一篇<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1bmFyY29ycC9xbXEvYmxvYi9tYXN0ZXIvZG9jcy9jbi9hY3Rvci5tZA==" title="https://github.com/qunarcorp/qmq/blob/master/docs/cn/actor.md">文章<i class="fa fa-external-link"></i></span>阐述了actor的应用场景。即client消费消息的请求会先进入一个RequestQueue，在client消费消息时，往往存在多个主题、多个消费组共享一个RequestQueue消费消息。在这个Queue中，存在不同主题的有不同消费组数量，以及不同消费组有不同consumer数量，那么就会存在抢占资源的情况。举个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1bmFyY29ycC9xbXEvYmxvYi9tYXN0ZXIvZG9jcy9jbi9hY3Rvci5tZA==" title="https://github.com/qunarcorp/qmq/blob/master/docs/cn/actor.md">文章<i class="fa fa-external-link"></i></span>中的例子，一个主题下有两个消费组A和B，A有100个consumer，B有200个consumer，那么在RequestQueue中来自B的请求可能会多于A，这个时候就存在消费unfair的情况，所以需要隔离不同主题不同消费组以保证fair。除此之外，当consumer消费能力不足，造成broker消息堆积，这个时候就会导致consumer所在消费组总在消费”老消息”，影响全局整体的一个消费能力。因为”老消息”不会存在page cache中，这个时候很可能就会从磁盘load，那么表现是RequestQueue中来自消费”老消息”消费组的请求处理时间过长，影响到其他主题消费组的消费，因此这个时候也需要做策略来避免不同消费组的相互影响。所以QMQ就有了actor机制，以消除各个消费组之间因消费能力不同、consumer数量不同而造成的相互影响各自的消费能力。</p></blockquote><p><a name="PullMessageWorker"></a></p><h1 id="PullMessageWorker"><a href="#PullMessageWorker" class="headerlink" title="PullMessageWorker"></a>PullMessageWorker</h1><p>要了解QMQ的actor模式是如何起作用的，就要先来看看Broker是如何处理消息拉取请求的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PullMessageWorker</span> <span class="keyword">implements</span> <span class="title">ActorSystem</span>.<span class="title">Processor</span>&lt;<span class="title">PullMessageProcessor</span>.<span class="title">PullEntry</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 消息存储层</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageStoreWrapper store;</span><br><span class="line">    <span class="comment">// actor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ActorSystem actorSystem;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ConcurrentMap&lt;String, Object&gt;&gt; subscribers;</span><br><span class="line"></span><br><span class="line">    PullMessageWorker(MessageStoreWrapper store, ActorSystem actorSystem) &#123;</span><br><span class="line">        <span class="keyword">this</span>.store = store;</span><br><span class="line">        <span class="keyword">this</span>.actorSystem = actorSystem;</span><br><span class="line">        <span class="keyword">this</span>.subscribers = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pull</span><span class="params">(PullMessageProcessor.PullEntry pullEntry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// subject+group作actor调度粒度</span></span><br><span class="line">        <span class="keyword">final</span> String actorPath = ConsumerGroupUtils.buildConsumerGroupKey(pullEntry.subject, pullEntry.group);</span><br><span class="line">        <span class="comment">// actor调度</span></span><br><span class="line">        actorSystem.dispatch(actorPath, pullEntry, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(PullMessageProcessor.PullEntry entry</span></span></span><br><span class="line"><span class="function"><span class="params">                           , ActorSystem.Actor&lt;PullMessageProcessor.PullEntry&gt; self)</span> </span>&#123;</span><br><span class="line">        QMon.pullQueueTime(entry.subject, entry.group, entry.pullBegin);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始处理请求的时候就过期了，那么就直接不处理了，也不返回任何东西给客户端，客户端等待超时</span></span><br><span class="line">        <span class="comment">//因为出现这种情况一般是server端排队严重，暂时挂起客户端可以避免情况恶化</span></span><br><span class="line">        <span class="comment">// deadline机制，如果QMQ认为这个消费请求来不及处理，那么就直接返回，避免雪崩</span></span><br><span class="line">      <span class="keyword">if</span> (entry.expired()) &#123;</span><br><span class="line">            QMon.pullExpiredCountInc(entry.subject, entry.group);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.isInValid()) &#123;</span><br><span class="line">            QMon.pullInValidCountInc(entry.subject, entry.group);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 存储层find消息</span></span><br><span class="line">        <span class="keyword">final</span> PullMessageResult pullMessageResult = store.findMessages(entry.pullRequest);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pullMessageResult == PullMessageResult.FILTER_EMPTY ||</span><br><span class="line">                pullMessageResult.getMessageNum() &gt; <span class="number">0</span></span><br><span class="line">                || entry.isPullOnce()</span><br><span class="line">                || entry.isTimeout()) &#123;</span><br><span class="line">            entry.processMessageResult(pullMessageResult);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 没有拉取到消息，那么挂起该actor</span></span><br><span class="line">        self.suspend();</span><br><span class="line">      <span class="comment">// timer task，在超时前唤醒actor</span></span><br><span class="line">        <span class="keyword">if</span> (entry.setTimerOnDemand()) &#123;</span><br><span class="line">            QMon.suspendRequestCountInc(entry.subject, entry.group);</span><br><span class="line">          <span class="comment">// 订阅消息，一有消息来就唤醒该actor</span></span><br><span class="line">            subscribe(entry.subject, entry.group);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 已经超时，那么即刻唤醒调度</span></span><br><span class="line">        self.resume();</span><br><span class="line">        entry.processNoMessageResult();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(String subject, String group)</span> </span>&#123;</span><br><span class="line">        ConcurrentMap&lt;String, Object&gt; map = subscribers.get(subject);</span><br><span class="line">        <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">            map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">            map = ObjectUtils.defaultIfNull(subscribers.putIfAbsent(subject, map), map);</span><br><span class="line">        &#125;</span><br><span class="line">        map.putIfAbsent(group, HOLDER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有消息来就唤醒订阅的subscriber</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remindNewMessages</span><span class="params">(<span class="keyword">final</span> String subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ConcurrentMap&lt;String, Object&gt; map = <span class="keyword">this</span>.subscribers.get(subject);</span><br><span class="line">        <span class="keyword">if</span> (map == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String group : map.keySet()) &#123;</span><br><span class="line">            map.remove(group);</span><br><span class="line">            <span class="keyword">this</span>.actorSystem.resume(ConsumerGroupUtils.buildConsumerGroupKey(subject, group));</span><br><span class="line">            QMon.resumeActorCountInc(subject, group);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActorSystem内定义的处理接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ActorSystem</span>.<span class="title">Processor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">process</span><span class="params">(T message, Actor&lt;T&gt; self)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能看除在这里起作用的是这个 <code>actorSystem</code> 。 <code>PullMessageWorker</code> 继承了 <code>ActorSystem.Processor</code> ，所以真正处理拉取请求的是这个接口里的 <code>process</code> 方法。请求到达 <code>pullMessageWorker</code> ，worker将该次请求交给 <code>actorSystem</code> 调度，调度到这次请求时，worker还有个根据拉取结果做反应的策略，即如果暂时没有消息，那么 <code>suspend</code> ，以一个timer task定时 <code>resume</code> ；如果在timer task执行之前有消息进来，那么也会即时 <code>resume</code> 。<br><a name="ActorSystem"></a></p><h1 id="ActorSystem"><a href="#ActorSystem" class="headerlink" title="ActorSystem"></a>ActorSystem</h1><p>接下来就看看ActorSystem里边是如何做到 <strong>公平调度</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActorSystem</span> </span>&#123;</span><br><span class="line"><span class="comment">// 内部维护的是一个ConcurrentMap，key即PullMessageWorker里的subject+group</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Actor&gt; actors;</span><br><span class="line">    <span class="comment">// 执行actor的executor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor executor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger actorsCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActorSystem</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name, Runtime.getRuntime().availableProcessors() * <span class="number">4</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActorSystem</span><span class="params">(String name, <span class="keyword">int</span> threads, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.actorsCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="comment">// 这里根据fair参数初始化一个优先级队列作为executor的参数，处理关于前言里说的"老消息"的情况</span></span><br><span class="line">        BlockingQueue&lt;Runnable&gt; queue = fair ? <span class="keyword">new</span> PriorityBlockingQueue&lt;&gt;() : <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.executor = <span class="keyword">new</span> ThreadPoolExecutor(threads, threads, <span class="number">60</span>, TimeUnit.MINUTES, queue, <span class="keyword">new</span> NamedThreadFactory(<span class="string">"actor-sys-"</span> + name));</span><br><span class="line">        <span class="keyword">this</span>.actors = Maps.newConcurrentMap();</span><br><span class="line">        QMon.dispatchersGauge(name, actorsCount::doubleValue);</span><br><span class="line">        QMon.actorSystemQueueGauge(name, () -&gt; (<span class="keyword">double</span>) executor.getQueue().size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，用一个线程池处理actor的调度执行，这个线程池里的队列是一个优先级队列。优先级队列存储的元素是Actor。关于Actor我们稍后来看，先来看一下 <code>ActorSystem</code> 的处理调度流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PullMessageWorker调用的就是这个方法</span></span><br><span class="line">   <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(String actorPath, E msg, Processor&lt;E&gt; processor)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 取得actor</span></span><br><span class="line">       Actor&lt;E&gt; actor = createOrGet(actorPath, processor);</span><br><span class="line">     <span class="comment">// 在后文Actor定义里能看到，actor内部维护一个queue，这里actor仅仅是offer(msg)</span></span><br><span class="line">       actor.dispatch(msg);</span><br><span class="line">     <span class="comment">// 执行调度</span></span><br><span class="line">       schedule(actor, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无消息时，则会挂起</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">(String actorPath)</span> </span>&#123;</span><br><span class="line">       Actor actor = actors.get(actorPath);</span><br><span class="line">       <span class="keyword">if</span> (actor == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       actor.suspend();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有消息则恢复，可以理解成线程的"就绪状态"</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">(String actorPath)</span> </span>&#123;</span><br><span class="line">       Actor actor = actors.get(actorPath);</span><br><span class="line">       <span class="keyword">if</span> (actor == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       actor.resume();</span><br><span class="line">     <span class="comment">// 立即调度，可以留意一下那个false</span></span><br><span class="line">     <span class="comment">// 当actor是"可调度状态"时，这个actor是否能调度是取决于actor的queue是否有消息</span></span><br><span class="line">       schedule(actor, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> &lt;E&gt; <span class="function">Actor&lt;E&gt; <span class="title">createOrGet</span><span class="params">(String actorPath, Processor&lt;E&gt; processor)</span> </span>&#123;</span><br><span class="line">       Actor&lt;E&gt; actor = actors.get(actorPath);</span><br><span class="line">       <span class="keyword">if</span> (actor != <span class="keyword">null</span>) <span class="keyword">return</span> actor;</span><br><span class="line"></span><br><span class="line">       Actor&lt;E&gt; add = <span class="keyword">new</span> Actor&lt;&gt;(<span class="keyword">this</span>.name, actorPath, <span class="keyword">this</span>, processor, DEFAULT_QUEUE_SIZE);</span><br><span class="line">       Actor&lt;E&gt; old = actors.putIfAbsent(actorPath, add);</span><br><span class="line">       <span class="keyword">if</span> (old == <span class="keyword">null</span>) &#123;</span><br><span class="line">           LOG.info(<span class="string">"create actorSystem: &#123;&#125;"</span>, actorPath);</span><br><span class="line">           actorsCount.incrementAndGet();</span><br><span class="line">           <span class="keyword">return</span> add;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> old;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将actor入队的地方</span></span><br><span class="line">   <span class="keyword">private</span> &lt;E&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">schedule</span><span class="params">(Actor&lt;E&gt; actor, <span class="keyword">boolean</span> hasMessageHint)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 如果actor不能调度，则ret false</span></span><br><span class="line">       <span class="keyword">if</span> (!actor.canBeSchedule(hasMessageHint)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     <span class="comment">// 设置actor为"可调度状态"</span></span><br><span class="line">       <span class="keyword">if</span> (actor.setAsScheduled()) &#123;</span><br><span class="line">         <span class="comment">// 提交时间，和actor执行总耗时共同决定在队列里的优先级</span></span><br><span class="line">           actor.submitTs = System.currentTimeMillis();</span><br><span class="line">         <span class="comment">// 入队，入的是线程池里的优先级队列</span></span><br><span class="line">           <span class="keyword">this</span>.executor.execute(actor);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="comment">// actor.setAsScheduled()里，这里是actor已经是可调度状态，那么没必要再次入队</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>actorSystem维护一个线程池，线程池队列具有优先级，队列存储元素是actor。actor的粒度是subject+group。Actor是一个Runnable，且因为是优先级队列的存储元素所以需继承Comparable接口（队列并没有传_Comparator参数_），并且actor有四种状态，初始状态、可调度状态、挂起状态、调度状态（这个状态其实不存在，但是暂且这么叫以帮助理解）。<br>接下来看看Actor这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Actor</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Comparable</span>&lt;<span class="title">Actor</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 初始状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Open = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 可调度状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Scheduled = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 掩码，二进制表示:11 与Open和Scheduled作&amp;运算 </span></span><br><span class="line">  <span class="comment">// shouldScheduleMask&amp;currentStatus != Open 则为不可置为调度状态（当currentStatus为挂起状态或调度状态）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> shouldScheduleMask = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> shouldNotProcessMask = ~<span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 挂起状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> suspendUnit = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//每个actor至少执行的时间片</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUOTA = <span class="number">5</span>;</span><br><span class="line">  <span class="comment">// status属性内存偏移量，用Unsafe操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> statusOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            statusOffset = Unsafe.instance.objectFieldOffset(Actor.class.getDeclaredField(<span class="string">"status"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String systemName;</span><br><span class="line">    <span class="keyword">final</span> ActorSystem actorSystem;</span><br><span class="line">  <span class="comment">// actor内部维护的queue，后文简单分析下</span></span><br><span class="line">    <span class="keyword">final</span> BoundedNodeQueue&lt;E&gt; queue;</span><br><span class="line">  <span class="comment">// ActorSystem内部定义接口，PullMessageWorker实现的就是这个接口，用于真正业务逻辑处理的地方</span></span><br><span class="line">    <span class="keyword">final</span> Processor&lt;E&gt; processor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="comment">// 一个actor执行总耗时</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> total;</span><br><span class="line">  <span class="comment">// actor执行提交时间，即actor入队时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> submitTs;</span><br><span class="line">    <span class="comment">//通过Unsafe操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    Actor(String systemName, String name, ActorSystem actorSystem, Processor&lt;E&gt; processor, <span class="keyword">final</span> <span class="keyword">int</span> queueSize) &#123;</span><br><span class="line">        <span class="keyword">this</span>.systemName = systemName;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.actorSystem = actorSystem;</span><br><span class="line">        <span class="keyword">this</span>.processor = processor;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> BoundedNodeQueue&lt;&gt;(queueSize);</span><br><span class="line"></span><br><span class="line">        QMon.actorQueueGauge(systemName, name, () -&gt; (<span class="keyword">double</span>) queue.count());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队，是actor内部的队列</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dispatch</span><span class="params">(E message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.add(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// actor执行的地方</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        String old = Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().setName(systemName + <span class="string">"-"</span> + name);</span><br><span class="line">            <span class="keyword">if</span> (shouldProcessMessage()) &#123;</span><br><span class="line">                processMessages();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> duration = System.currentTimeMillis() - start;</span><br><span class="line">          <span class="comment">// 每次actor执行的耗时累加到total</span></span><br><span class="line">            total += duration;</span><br><span class="line">            QMon.actorProcessTime(name, duration);</span><br><span class="line"></span><br><span class="line">            Thread.currentThread().setName(old);</span><br><span class="line">          <span class="comment">// 设置为"空闲状态"，即初始状态 (currentStatus &amp; ~Scheduled)</span></span><br><span class="line">            setAsIdle();</span><br><span class="line">          <span class="comment">// 进行下一次调度</span></span><br><span class="line">            <span class="keyword">this</span>.actorSystem.schedule(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> deadline = System.currentTimeMillis() + QUOTA;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            E message = queue.peek();</span><br><span class="line">            <span class="keyword">if</span> (message == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">          <span class="comment">// 处理业务逻辑</span></span><br><span class="line">            <span class="keyword">boolean</span> process = processor.process(message, <span class="keyword">this</span>);</span><br><span class="line">          <span class="comment">// 失败，该message不会出队，等待下一次调度</span></span><br><span class="line">          <span class="comment">// 如pullMessageWorker中没有消息时将actor挂起</span></span><br><span class="line">            <span class="keyword">if</span> (!process) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 出队</span></span><br><span class="line">            queue.pollNode();</span><br><span class="line">          <span class="comment">// 每个actor只有QUOTA个时间片的执行时间</span></span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= deadline) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">shouldProcessMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 能够真正执行业务逻辑的判断</span></span><br><span class="line">      <span class="comment">// 一种场景是，针对挂起状态，由于没有拉取到消息该actor置为挂起状态</span></span><br><span class="line">      <span class="comment">// 自然就没有抢占时间片的必要了</span></span><br><span class="line">        <span class="keyword">return</span> (currentStatus() &amp; shouldNotProcessMask) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 能否调度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canBeSchedule</span><span class="params">(<span class="keyword">boolean</span> hasMessageHint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = currentStatus();</span><br><span class="line">        <span class="keyword">if</span> (s == Open || s == Scheduled) <span class="keyword">return</span> hasMessageHint || !queue.isEmpty();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = currentStatus();</span><br><span class="line">            <span class="keyword">int</span> next = s &lt; suspendUnit ? s : s - suspendUnit;</span><br><span class="line">            <span class="keyword">if</span> (updateStatus(s, next)) <span class="keyword">return</span> next &lt; suspendUnit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = currentStatus();</span><br><span class="line">            <span class="keyword">if</span> (updateStatus(s, s + suspendUnit)) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">setAsScheduled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = currentStatus();</span><br><span class="line">          <span class="comment">// currentStatus为非Open状态，则ret false</span></span><br><span class="line">            <span class="keyword">if</span> ((s &amp; shouldScheduleMask) != Open) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">// 更新actor状态为调度状态</span></span><br><span class="line">            <span class="keyword">if</span> (updateStatus(s, s | Scheduled)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAsIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = currentStatus();</span><br><span class="line">          <span class="comment">// 更新actor状态位不可调度状态，(这里可以理解为更新为初始状态Open)</span></span><br><span class="line">            <span class="keyword">if</span> (updateStatus(s, s &amp; ~Scheduled)) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">currentStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 根据status在内存中的偏移量取得status</span></span><br><span class="line">        <span class="keyword">return</span> Unsafe.instance.getIntVolatile(<span class="keyword">this</span>, statusOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateStatus</span><span class="params">(<span class="keyword">int</span> oldStatus, <span class="keyword">int</span> newStatus)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Unsafe 原子操作，处理status的轮转变更</span></span><br><span class="line">        <span class="keyword">return</span> Unsafe.instance.compareAndSwapInt(<span class="keyword">this</span>, statusOffset, oldStatus, newStatus);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 决定actor在优先级队列里的优先级的地方</span></span><br><span class="line">  <span class="comment">// 先看总耗时，以达到动态限速，保证执行"慢"的请求（已经堆积的消息拉取请求）在后执行</span></span><br><span class="line">  <span class="comment">// 其次看提交时间，先提交的actor先执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Actor o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = Long.compare(total, o.total);</span><br><span class="line">        <span class="keyword">return</span> result == <span class="number">0</span> ? Long.compare(submitTs, o.submitTs) : result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Actor&lt;?&gt; actor = (Actor&lt;?&gt;) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(systemName, actor.systemName) &amp;&amp;</span><br><span class="line">                Objects.equals(name, actor.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(systemName, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Actor实现了<code>Comparable</code>，在优先级队列里优先级是Actor里的total和submitTs共同决定的。total是actor执行总耗时，submitTs是调度时间。那么对于处理较慢的actor自然就会在队列里相对”尾部”位置，这时就做到了根据actor的执行耗时的一个动态限速。Actor利用Unsafe机制来控制各个状态的轮转原子性更新的，且每个actor执行时间可以简单理解为5个时间片。<br>其实工作进行到这里就可以结束了，但是抱着研究的态度，不妨接着往下看看。<br>Actor内部维护一个Queue，这个Queue是自定义的，是一个<em>Lock-free bounded non-blocking multiple-producer single-consumer queue。JDK里的QUEUE多数都是用锁控制，不用锁，猜测也应该是用Unsafe 原子操作实现。那么来看看吧：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedNodeQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头结点、尾节点在内存中的偏移量</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> enqOffset, deqOffset;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">static</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              enqOffset = Unsafe.instance.objectFieldOffset(BoundedNodeQueue.class.getDeclaredField(<span class="string">"_enqDoNotCallMeDirectly"</span>));</span><br><span class="line">              deqOffset = Unsafe.instance.objectFieldOffset(BoundedNodeQueue.class.getDeclaredField(<span class="string">"_deqDoNotCallMeDirectly"</span>));</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(t);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line">      <span class="comment">// 尾节点，通过enqOffset操作</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">volatile</span> Node&lt;T&gt; _enqDoNotCallMeDirectly;</span><br><span class="line">      <span class="comment">// 头结点，通过deqOffset操作</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">volatile</span> Node&lt;T&gt; _deqDoNotCallMeDirectly;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="title">BoundedNodeQueue</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"AbstractBoundedNodeQueue.capacity must be &gt;= 0"</span>);</span><br><span class="line">          <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">          <span class="keyword">final</span> Node&lt;T&gt; n = <span class="keyword">new</span> Node&lt;T&gt;();</span><br><span class="line">          setDeq(n);</span><br><span class="line">          setEnq(n);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取尾节点</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> Node&lt;T&gt; <span class="title">getEnq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// getObjectVolatile这种方式保证拿到的都是最新数据</span></span><br><span class="line">          <span class="keyword">return</span> (Node&lt;T&gt;) Unsafe.instance.getObjectVolatile(<span class="keyword">this</span>, enqOffset);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置尾节点，仅在初始化时用</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setEnq</span><span class="params">(Node&lt;T&gt; n)</span> </span>&#123;</span><br><span class="line">          Unsafe.instance.putObjectVolatile(<span class="keyword">this</span>, enqOffset, n);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casEnq</span><span class="params">(Node&lt;T&gt; old, Node&lt;T&gt; nju)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// cas，循环设置，直到成功</span></span><br><span class="line">          <span class="keyword">return</span> Unsafe.instance.compareAndSwapObject(<span class="keyword">this</span>, enqOffset, old, nju);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取头结点</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> Node&lt;T&gt; <span class="title">getDeq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> (Node&lt;T&gt;) Unsafe.instance.getObjectVolatile(<span class="keyword">this</span>, deqOffset);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅在初始化时用</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setDeq</span><span class="params">(Node&lt;T&gt; n)</span> </span>&#123;</span><br><span class="line">          Unsafe.instance.putObjectVolatile(<span class="keyword">this</span>, deqOffset, n);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cas设置头结点</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casDeq</span><span class="params">(Node&lt;T&gt; old, Node&lt;T&gt; nju)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> Unsafe.instance.compareAndSwapObject(<span class="keyword">this</span>, deqOffset, old, nju);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与其叫count，不如唤作index，但是是否应该考虑溢出的情况？</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">final</span> Node&lt;T&gt; lastNode = getEnq();</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> lastNodeCount = lastNode.count;</span><br><span class="line">          <span class="keyword">return</span> lastNodeCount - getDeq().count;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> the maximum capacity of this queue</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> capacity;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> T value)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (Node&lt;T&gt; n = <span class="keyword">null</span>; ; ) &#123;</span><br><span class="line">              <span class="keyword">final</span> Node&lt;T&gt; lastNode = getEnq();</span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">int</span> lastNodeCount = lastNode.count;</span><br><span class="line">              <span class="keyword">if</span> (lastNodeCount - getDeq().count &lt; capacity) &#123;</span><br><span class="line">                  <span class="comment">// Trade a branch for avoiding to create a new node if full,</span></span><br><span class="line">                  <span class="comment">// and to avoid creating multiple nodes on write conflict á la Be Kind to Your GC</span></span><br><span class="line">                  <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      n = <span class="keyword">new</span> Node&lt;T&gt;();</span><br><span class="line">                      n.value = value;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  n.count = lastNodeCount + <span class="number">1</span>; <span class="comment">// Piggyback on the HB-edge between getEnq() and casEnq()</span></span><br><span class="line"></span><br><span class="line">                  <span class="comment">// Try to putPullLogs the node to the end, if we fail we continue loopin'</span></span><br><span class="line">                  <span class="comment">// 相当于 </span></span><br><span class="line">                <span class="comment">// enq -&gt; next = new Node(value); enq = neq -&gt; next;</span></span><br><span class="line">                  <span class="keyword">if</span> (casEnq(lastNode, n)) &#123;</span><br><span class="line">                    <span class="comment">// 注意一下这个Node.setNext方法</span></span><br><span class="line">                      lastNode.setNext(n);</span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// Over capacity—couldn't add the node</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// enq == deq 即为empty</span></span><br><span class="line">          <span class="keyword">return</span> getEnq() == getDeq();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Removes the first element of this queue if any</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> the value of the first element of the queue, null if empty</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">final</span> Node&lt;T&gt; n = pollNode();</span><br><span class="line">          <span class="keyword">return</span> (n != <span class="keyword">null</span>) ? n.value : <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Node&lt;T&gt; n = peekNode();</span><br><span class="line">          <span class="keyword">return</span> (n != <span class="keyword">null</span>) ? n.value : <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Node&lt;T&gt; <span class="title">peekNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">              <span class="keyword">final</span> Node&lt;T&gt; deq = getDeq();</span><br><span class="line">              <span class="keyword">final</span> Node&lt;T&gt; next = deq.next();</span><br><span class="line">              <span class="keyword">if</span> (next != <span class="keyword">null</span> || getEnq() == deq)</span><br><span class="line">                  <span class="keyword">return</span> next;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Removes the first element of this queue if any</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> the `Node` of the first element of the queue, null if empty</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Node&lt;T&gt; <span class="title">pollNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">              <span class="keyword">final</span> Node&lt;T&gt; deq = getDeq();</span><br><span class="line">              <span class="keyword">final</span> Node&lt;T&gt; next = deq.next();</span><br><span class="line">              <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (casDeq(deq, next)) &#123;</span><br><span class="line">                      deq.value = next.value;</span><br><span class="line">                      deq.setNext(<span class="keyword">null</span>);</span><br><span class="line">                      next.value = <span class="keyword">null</span>;</span><br><span class="line">                      <span class="keyword">return</span> deq;</span><br><span class="line">                  &#125; <span class="comment">// else we retry (concurrent consumers)</span></span><br><span class="line">                <span class="comment">// 比较套路的cas操作，就不多说了</span></span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getEnq() == deq) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// If we got a null and head meets tail, we are empty</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        </span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">static</span> &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  nextOffset = Unsafe.instance.objectFieldOffset(Node.class.getDeclaredField(<span class="string">"_nextDoNotCallMeDirectly"</span>));</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(t);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">protected</span> T value;</span><br><span class="line">          <span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br><span class="line">          <span class="comment">// 也是利用偏移量操作</span></span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">volatile</span> Node&lt;T&gt; _nextDoNotCallMeDirectly;</span><br><span class="line"></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Node&lt;T&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> (Node&lt;T&gt;) Unsafe.instance.getObjectVolatile(<span class="keyword">this</span>, nextOffset);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(<span class="keyword">final</span> Node&lt;T&gt; newNext)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这里有点讲究，下面分析下</span></span><br><span class="line">              Unsafe.instance.putOrderedObject(<span class="keyword">this</span>, nextOffset, newNext);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如上代码，是通过属性在内存的偏移量，结合cas原子操作来进行更新赋值等操作，以此来实现lock-free，这是比较常规的套路。值得一说的是Node里的setNext方法，这个方法的调用是在cas节点后，对”上一位置”的next节点进行赋值。而这个方法使用的是 <code>Unsafe.instance.putOrderedObject</code> ，要说这个putOrderedObject ，就不得不说MESI，缓存一致性协议。如volatile，当进行写操作时，它是依靠storeload barrier来实现其他线程对此的可见性。而 <code>putOrderedObject</code> 也是依靠内存屏障，只不过是 <code>storestore barrier</code> 。storestore是比storeload快速的一种内存屏障。在硬件层面，内存屏障分两种：Load-Barrier和Store-Barrier。Load-Barrier是让高速缓存中的数据失效，强制重新从主内存加载数据；Store-Barrier是让写入高速缓存的数据更新写入主内存，对其他线程可见。而java层面的四种内存屏障无非是硬件层面的两种内存屏障的组合而已。那么可见，storestore barrier自然比storeload barrier快速。那么有一个问题，我们可不可以在这里也用cas操作呢？答案是可以，但没必要。你可以想想这里为什么没必要。<br>谢谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;df368884&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;QMQ有关actor的一篇&lt;span
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="MQ" scheme="https://blog.dengxf.cn/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>QMQ源码分析之delay-server篇【三】</title>
    <link href="https://blog.dengxf.cn/4c5184d3.html"/>
    <id>https://blog.dengxf.cn/4c5184d3.html</id>
    <published>2019-03-10T01:18:34.000Z</published>
    <updated>2019-06-27T09:48:04.195Z</updated>
    
    <content type="html"><![CDATA[<p><a name="df368884"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>上篇我们分析了QMQ delay-server关于存储的部分，这一篇我们会对投递的源码进行分析。</p></blockquote><p><a name="31cb9169"></a></p><h1 id="投递"><a href="#投递" class="headerlink" title="投递"></a>投递</h1><p>投递的相关内容在WheelTickManager这个类。提前加载schedule_log、wheel根据延迟时间到时进行投递等相关工作都在这里完成。而关于真正进行投递的相关类是在sender这个包里。<br><a name="wheel"></a></p><h2 id="wheel"><a href="#wheel" class="headerlink" title="wheel"></a>wheel</h2><p>wheel包里一共就三个类文件， <code>HashWheelTimer</code> 、 <code>WheelLoadCursor</code> 、 <code>WheelTickManager</code> ， <code>WheelTickManager</code> 就应该是wheel加载文件，wheel中的消息到时投递的管理器； <code>WheelLoadCursor</code> 应该就是上一篇中提到的schedule_log文件加载到哪里的cursor标识；那么 <code>HashWheelTimer</code> 就是一个辅助工具类，简单理解成Java中的 <code>ScheduledExecutorService</code> ，可理解成是根据延迟消息的延迟时间进行投递的timer，所以这里不对这个工具类做更多解读，我们更关心MQ逻辑。<br>首先来看提前一定时间加载schedule_log，这里的提前一定时间是多长时间呢？这个是根据需要配置的，比如schedule_log的刻度自定义配置为1h，提前加载时间配置为30min，那么在2019-02-10 17:30就应该加载2019021018这个schedule_log。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!isStarted()) &#123;</span><br><span class="line">           sender.init();</span><br><span class="line">           <span class="comment">// hash wheel timer,内存中的wheel</span></span><br><span class="line">           timer.start();</span><br><span class="line">           started.set(<span class="keyword">true</span>);</span><br><span class="line">           <span class="comment">// 根据dispatch log,从上次投递结束的地方恢复开始投递</span></span><br><span class="line">           recover();</span><br><span class="line">           <span class="comment">// 加载线程，用于加载schedule_log</span></span><br><span class="line">           loadScheduler.scheduleWithFixedDelay(<span class="keyword">this</span>::load, <span class="number">0</span>, config.getLoadSegmentDelayMinutes(), TimeUnit.MINUTES);</span><br><span class="line">           LOGGER.info(<span class="string">"wheel started."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>recover</code> 这个方法，会根据dispatch log中的投递记录，找到上一次最后投递的位置，在delay-server重启的时候，wheel会根据这个位置恢复投递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      LOGGER.info(<span class="string">"wheel recover..."</span>);</span><br><span class="line">    <span class="comment">// 最新的dispatch log segment</span></span><br><span class="line">      DispatchLogSegment currentDispatchedSegment = facade.latestDispatchSegment();</span><br><span class="line">      <span class="keyword">if</span> (currentDispatchedSegment == <span class="keyword">null</span>) &#123;</span><br><span class="line">          LOGGER.warn(<span class="string">"load latest dispatch segment null"</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> latestOffset = currentDispatchedSegment.getSegmentBaseOffset();</span><br><span class="line">      DispatchLogSegment lastSegment = facade.lowerDispatchSegment(latestOffset);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> != lastSegment) doRecover(lastSegment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据最新的dispatch log segment进行恢复投递</span></span><br><span class="line">      doRecover(currentDispatchedSegment);</span><br><span class="line">      LOGGER.info(<span class="string">"wheel recover done. currentOffset:&#123;&#125;"</span>, latestOffset);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRecover</span><span class="params">(DispatchLogSegment dispatchLogSegment)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> segmentBaseOffset = dispatchLogSegment.getSegmentBaseOffset();</span><br><span class="line">      ScheduleSetSegment setSegment = facade.loadScheduleLogSegment(segmentBaseOffset);</span><br><span class="line">      <span class="keyword">if</span> (setSegment == <span class="keyword">null</span>) &#123;</span><br><span class="line">          LOGGER.error(<span class="string">"load schedule index error,dispatch segment:&#123;&#125;"</span>, segmentBaseOffset);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到一个关于已投递记录的set</span></span><br><span class="line">      LongHashSet dispatchedSet = loadDispatchLog(dispatchLogSegment);</span><br><span class="line">    <span class="comment">// 根据这个set，将最新的dispatch log segment中未投递的消息add in wheel。</span></span><br><span class="line">      WheelLoadCursor.Cursor loadCursor = facade.loadUnDispatch(setSegment, dispatchedSet, <span class="keyword">this</span>::refresh);</span><br><span class="line">      <span class="keyword">int</span> baseOffset = loadCursor.getBaseOffset();</span><br><span class="line">    <span class="comment">// 记录cursor</span></span><br><span class="line">      loadingCursor.shiftCursor(baseOffset, loadCursor.getOffset());</span><br><span class="line">      loadedCursor.shiftCursor(baseOffset);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>恢复基本就是以上的这些内容，接下来看看是如何加载的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提前一定时间加载到下一 delay segment</span></span><br><span class="line">      <span class="keyword">long</span> next = System.currentTimeMillis() + config.getLoadInAdvanceTimesInMillis();</span><br><span class="line">      <span class="keyword">int</span> prepareLoadBaseOffset = resolveSegment(next);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加载到prepareLoadBaseOffset这个delay segment</span></span><br><span class="line">          loadUntil(prepareLoadBaseOffset);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">          LOGGER.debug(<span class="string">"load segment interrupted"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadUntil</span><span class="params">(<span class="keyword">int</span> until)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 当前wheel已加载到baseOffset</span></span><br><span class="line">      <span class="keyword">int</span> loadedBaseOffset = loadedCursor.baseOffset();</span><br><span class="line">    <span class="comment">// 如已加载到until，则break</span></span><br><span class="line">      <span class="comment">// have loaded</span></span><br><span class="line">      <span class="keyword">if</span> (loadedBaseOffset &gt; until) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 加载失败，则break</span></span><br><span class="line">          <span class="comment">// wait next turn when loaded error.</span></span><br><span class="line">          <span class="keyword">if</span> (!loadUntilInternal(until)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前并没有until这个delay segment，即loading cursor小于until</span></span><br><span class="line">          <span class="comment">// load successfully(no error happened) and current wheel loading cursor &lt; until</span></span><br><span class="line">          <span class="keyword">if</span> (loadingCursor.baseOffset() &lt; until) &#123;</span><br><span class="line">            <span class="comment">// 阻塞，直到thresholdTime+blockingExitTime</span></span><br><span class="line">            <span class="comment">// 即如果提前blockingExitTime还未有until这个delay segment的消息进来，则退出</span></span><br><span class="line">              <span class="keyword">long</span> thresholdTime = System.currentTimeMillis() + config.getLoadBlockingExitTimesInMillis();</span><br><span class="line">              <span class="comment">// exit in a few minutes in advance</span></span><br><span class="line">              <span class="keyword">if</span> (resolveSegment(thresholdTime) &gt;= until) &#123;</span><br><span class="line">                  loadingCursor.shiftCursor(until);</span><br><span class="line">                  loadedCursor.shiftCursor(until);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 避免cpu load过高</span></span><br><span class="line">          Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125; <span class="keyword">while</span> (loadedCursor.baseOffset() &lt; until);</span><br><span class="line"></span><br><span class="line">      LOGGER.info(<span class="string">"wheel load until &#123;&#125; &lt;= &#123;&#125;"</span>, loadedCursor.baseOffset(), until);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>根据配置的提前加载时间，内存中的wheel会提前加载schedule_log，加载是在一个while循环里，直到加载到until delay segment才退出，如果当前没有until 这个delay segment，那么会在配置的 <code>blockingExitTime</code> 时间退出该循环，而为了避免cpu load过高，这里会在每次循环间隔设置100ms sleep。这里加载为什么是在while循环里？以及为什么sleep 100ms，sleep 500ms 或者1s可不可以？以及为什么要设置个blockingExitTime呢？下面的分析之后，应该就能回答这些问题了。主要考虑两种情况，一种是当之前一直没有delay segment或者delay segment是间隔存在的，比如delay segment刻度为1h，2019031001和2019031004之间的2019031002及2019031003不存在这种之类的delay segment不存在的情况，另一种是当正在加载delay segment的时候，位于该segment的延迟消息正在被加载，这种情况是有可能丢消息的。所以这里加载是在一个循环里，以及设置了两个cursor，即loading cursor，和loaded cursor。一个表示正在加载，一个表示已经加载。此外，上面每次循环sleep 100ms，可不可以sleep 500ms or 1s？答案是可以，只是消息是否能容忍500ms 或者1s的延迟。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">loadUntilInternal</span><span class="params">(<span class="keyword">int</span> until)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = resolveStartIndex();</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= until) &#123;</span><br><span class="line">            ScheduleSetSegment segment = facade.loadScheduleLogSegment(index);</span><br><span class="line">            <span class="keyword">if</span> (segment == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextIndex = facade.higherScheduleBaseOffset(index);</span><br><span class="line">                <span class="keyword">if</span> (nextIndex &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                index = nextIndex;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体加载某个segment的地方</span></span><br><span class="line">            loadSegment(segment);</span><br><span class="line">            <span class="keyword">int</span> nextIndex = facade.higherScheduleBaseOffset(index);</span><br><span class="line">            <span class="keyword">if</span> (nextIndex &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            index = nextIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        LOGGER.error(<span class="string">"wheel load segment failed,currentSegmentOffset:&#123;&#125; until:&#123;&#125;"</span>, loadedCursor.baseOffset(), until, e);</span><br><span class="line">        QMon.loadSegmentFailed();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadSegment</span><span class="params">(ScheduleSetSegment segment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> baseOffset = segment.getSegmentBaseOffset();</span><br><span class="line">        <span class="keyword">long</span> offset = segment.getWrotePosition();</span><br><span class="line">        <span class="keyword">if</span> (!loadingCursor.shiftCursor(baseOffset, offset)) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"doLoadSegment error,shift loadingCursor failed,from &#123;&#125;-&#123;&#125; to &#123;&#125;-&#123;&#125;"</span>, loadingCursor.baseOffset(), loadingCursor.offset(), baseOffset, offset);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WheelLoadCursor.Cursor loadedCursorEntry = loadedCursor.cursor();</span><br><span class="line">        <span class="comment">// have loaded</span></span><br><span class="line">        <span class="comment">// 已经加载</span></span><br><span class="line">        <span class="keyword">if</span> (baseOffset &lt; loadedCursorEntry.getBaseOffset()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startOffset = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// last load action happened error</span></span><br><span class="line">        <span class="comment">// 如果上次加载失败，则从上一次的位置恢复加载</span></span><br><span class="line">        <span class="keyword">if</span> (baseOffset == loadedCursorEntry.getBaseOffset() &amp;&amp; loadedCursorEntry.getOffset() &gt; -<span class="number">1</span>)</span><br><span class="line">            startOffset = loadedCursorEntry.getOffset();</span><br><span class="line"></span><br><span class="line">        LogVisitor&lt;ScheduleIndex&gt; visitor = segment.newVisitor(startOffset, config.getSingleMessageLimitSize());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loadedCursor.shiftCursor(baseOffset, startOffset);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> currentOffset = startOffset;</span><br><span class="line">            <span class="comment">// 考虑一种情况，当前delay segment正在append消息，所以是while，而loaded cursor的offset也是没加载一个消息更新的</span></span><br><span class="line">            <span class="keyword">while</span> (currentOffset &lt; offset) &#123;</span><br><span class="line">                Optional&lt;ScheduleIndex&gt; recordOptional = visitor.nextRecord();</span><br><span class="line">                <span class="keyword">if</span> (!recordOptional.isPresent()) <span class="keyword">break</span>;</span><br><span class="line">                ScheduleIndex index = recordOptional.get();</span><br><span class="line">                currentOffset = index.getOffset() + index.getSize();</span><br><span class="line">                refresh(index);</span><br><span class="line">                loadedCursor.shiftOffset(currentOffset);</span><br><span class="line">            &#125;</span><br><span class="line">            loadedCursor.shiftCursor(baseOffset);</span><br><span class="line">            LOGGER.info(<span class="string">"loaded segment:&#123;&#125; &#123;&#125;"</span>, loadedCursor.baseOffset(), currentOffset);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            visitor.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Metrics.timer(<span class="string">"loadSegmentTimer"</span>).update(System.currentTimeMillis() - start, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得上一篇我们提到过，存储的时候，如果这个消息位于正在被wheel加载segment中，那么这个消息应该是会被加载到wheel中的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">iterateCallback</span><span class="params">(<span class="keyword">final</span> ScheduleIndex index)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> scheduleTime = index.getScheduleTime();</span><br><span class="line">      <span class="keyword">long</span> offset = index.getOffset();</span><br><span class="line">      <span class="comment">// 主要看一下这个canAdd</span></span><br><span class="line">      <span class="keyword">if</span> (wheelTickManager.canAdd(scheduleTime, offset)) &#123;</span><br><span class="line">          wheelTickManager.addWHeel(index);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 就是cursor起作用的地方了</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canAdd</span><span class="params">(<span class="keyword">long</span> scheduleTime, <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">      WheelLoadCursor.Cursor currentCursor = loadingCursor.cursor();</span><br><span class="line">      <span class="keyword">int</span> currentBaseOffset = currentCursor.getBaseOffset();</span><br><span class="line">      <span class="keyword">long</span> currentOffset = currentCursor.getOffset();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据延迟时间确定该消息位于哪个segment</span></span><br><span class="line">      <span class="keyword">int</span> baseOffset = resolveSegment(scheduleTime);</span><br><span class="line">      <span class="comment">// 小于当前loading cursor,则put int wheel</span></span><br><span class="line">      <span class="keyword">if</span> (baseOffset &lt; currentBaseOffset) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正在加载</span></span><br><span class="line">      <span class="keyword">if</span> (baseOffset == currentBaseOffset) &#123;</span><br><span class="line">      <span class="comment">// 根据cursor的offset判断</span></span><br><span class="line">          <span class="keyword">return</span> currentOffset &lt;= offset;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><a name="sender"></a></p><h2 id="sender"><a href="#sender" class="headerlink" title="sender"></a>sender</h2><p>sender包里结构如下图：<br><br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1552225820958-e8c18683-a57d-4d74-af71-33a29ce43376.png#align=left&display=inline&height=146&name=image.png&originHeight=146&originWidth=245&size=6507&status=done&width=245" alt="image.png"><br>通过brokerGroup做分组，根据组批量发送，发送时是多线程发送，每个组互不影响，发送时也会根据实时broker的weight进行选择考虑broker进行发送。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(ScheduleIndex index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!BrokerRoleManager.isDelayMaster()) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> add;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">long</span> waitTime = Math.abs(sendWaitTime);</span><br><span class="line">           <span class="comment">// 入队</span></span><br><span class="line">           <span class="keyword">if</span> (waitTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               add = batchExecutor.addItem(index, waitTime, TimeUnit.MILLISECONDS);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               add = batchExecutor.addItem(index);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!add) &#123;</span><br><span class="line">           reject(index);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;ScheduleIndex&gt; indexList)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 发送处理逻辑在senderExecutor里</span></span><br><span class="line">           senderExecutor.execute(indexList, <span class="keyword">this</span>, brokerService);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           LOGGER.error(<span class="string">"send message failed,messageSize:&#123;&#125; will retry"</span>, indexList.size(), e);</span><br><span class="line">           retry(indexList);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下为senderExecutor内容</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> List&lt;ScheduleIndex&gt; indexList, <span class="keyword">final</span> SenderGroup.ResultHandler handler, <span class="keyword">final</span> BrokerService brokerService)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 分组</span></span><br><span class="line">       Map&lt;SenderGroup, List&lt;ScheduleIndex&gt;&gt; groups = groupByBroker(indexList, brokerService);</span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;SenderGroup, List&lt;ScheduleIndex&gt;&gt; entry : groups.entrySet()) &#123;</span><br><span class="line">           doExecute(entry.getKey(), entry.getValue(), handler);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExecute</span><span class="params">(<span class="keyword">final</span> SenderGroup group, <span class="keyword">final</span> List&lt;ScheduleIndex&gt; list, <span class="keyword">final</span> SenderGroup.ResultHandler handler)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 分组发送</span></span><br><span class="line">       group.send(list, sender, handler);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到，投递时是根据server broker进行分组投递。看一下 <code>SenderGroup</code> 这个类<br><br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1552226236558-1141d53b-a8d0-495b-a1ec-6fa7eb8d7310.png#align=left&display=inline&height=420&name=image.png&originHeight=420&originWidth=781&size=92662&status=done&width=781" alt="image.png"><br>可以看到，每个组的投递是多线程，互不影响，不会存在某个组的server挂掉，导致其他组无法投递。并且这里如果存在某个组无法投递，重试时会选择其它的server broker进行重试。与此同时，在选择组时，会根据每个server broker的weight进行综合考量，即当前server broker有多少消息量要发送。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体发送的地方</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Sender sender, ResultHandler handler, BrokerGroupInfo groupInfo, String groupName, List&lt;ScheduleIndex&gt; list)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">          List&lt;ScheduleSetRecord&gt; records = store.recoverLogRecord(list);</span><br><span class="line">          QMon.loadMsgTime(System.currentTimeMillis() - start);</span><br><span class="line"></span><br><span class="line">          Datagram response = sendMessages(records, sender);</span><br><span class="line">          release(records);</span><br><span class="line">          monitor(list, groupName);</span><br><span class="line">          <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">              handler.fail(list);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">int</span> responseCode = response.getHeader().getCode();</span><br><span class="line">              <span class="keyword">final</span> Map&lt;String, SendResult&gt; resultMap = getSendResult(response);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (resultMap == <span class="keyword">null</span> || responseCode != CommandCode.SUCCESS) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (responseCode == CommandCode.BROKER_REJECT || responseCode == CommandCode.BROKER_ERROR) &#123;</span><br><span class="line">                    <span class="comment">// 该组熔断  </span></span><br><span class="line">                    groupInfo.markFailed();</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  monitorSendFail(list, groupInfo.getGroupName());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重试</span></span><br><span class="line">                  handler.fail(list);</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              Set&lt;String&gt; failedMessageIds = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">              <span class="keyword">boolean</span> brokerRefreshed = <span class="keyword">false</span>;</span><br><span class="line">              <span class="keyword">for</span> (Map.Entry&lt;String, SendResult&gt; entry : resultMap.entrySet()) &#123;</span><br><span class="line">                  <span class="keyword">int</span> resultCode = entry.getValue().getCode();</span><br><span class="line">                  <span class="keyword">if</span> (resultCode != MessageProducerCode.SUCCESS) &#123;</span><br><span class="line">                      failedMessageIds.add(entry.getKey());</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (!brokerRefreshed &amp;&amp; resultCode == MessageProducerCode.BROKER_READ_ONLY) &#123;</span><br><span class="line">                      groupInfo.markFailed();</span><br><span class="line">                      brokerRefreshed = <span class="keyword">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (!brokerRefreshed) groupInfo.markSuccess();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// dispatch log 记录在这里产生</span></span><br><span class="line">              handler.success(records, failedMessageIds);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          LOGGER.error(<span class="string">"sender group send batch failed,broker:&#123;&#125;,batch size:&#123;&#125;"</span>, groupName, list.size(), e);</span><br><span class="line">          handler.fail(list);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>就是以上这些，关于QMQ的delay-server源码分析就是这些了，如果以后有机会会分析一下QMQ的其他模块源码，谢谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;df368884&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;上篇我们分析了QMQ
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="MQ" scheme="https://blog.dengxf.cn/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>QMQ源码分析之delay-server篇【二】</title>
    <link href="https://blog.dengxf.cn/14f2781.html"/>
    <id>https://blog.dengxf.cn/14f2781.html</id>
    <published>2019-03-02T01:35:59.000Z</published>
    <updated>2019-06-27T09:48:04.199Z</updated>
    
    <content type="html"><![CDATA[<p><a name="df368884"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>本来是固定时间周六更博，但是昨天临时失恋了，所以心情不好，晚了一天。那么上一篇我们梳理了下QMQ延迟消息的主要功能，这一篇在此基础上，对照着功能分析一下源码。</p></blockquote><p><a name="74fc4edb"></a></p><h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><p>要了解delay-server源码的一个整体结构，需要我们跟着源码，从初始化开始简单先过一遍。重试工作都在startup这个包里，而这个包只有一个ServerWrapper类。<img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1551520273789-e28ea7fb-b86e-4c50-ba21-66bbf9a2f123.png#align=left&display=inline&height=668&name=image.png&originHeight=668&originWidth=1207&size=86215&status=done&width=1207" alt="image.png"><br>结合上一篇的内容，通过这个类就基本能看到delay的一个源码结构。delay-server基于netty，init方法完成初始化工作（端口默认为20801、心跳、wheel等），register方法是向meta-server发起请求，获取自己自己的<code>角色</code>为 <code>delay</code> ，并开始和meta-server的心跳。startServer方法是开始HashWheel的转动，从上次结束的位置继续message_log的回放，开启netty server。另外在做准备工作时知道QMQ是基于一主一从一备的方式，关于这个sync方法，是开启监听一个端口回应<code>同步拉取</code>动作，如果是从节点还要开始向主节点发起<code>同步拉取</code>动作。当这一切都完成了，那么online方法就执行，表示delay开始上线提供服务了。总结一下两个要点，QMQ是基于netty进行通信，并且采用一主一从一备的方式。<br><a name="a39cf1ca"></a></p><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p>关于存储在之前我们也讨论了，delay-server接收到延迟消息，会顺序append到message_log，之后再对message_log进行回放，以生成schedule_log。所以关于存储我们需要关注两个东西，一个是message_log的存储，另一个是schedule_log的生成。<br><a name="message_log"></a></p><h2 id="message-log"><a href="#message-log" class="headerlink" title="message_log"></a>message_log</h2><p>其实 <code>message_log</code> 的生成很简单，就是顺序append。主要逻辑在 <code>qunar.tc.qmq.delay.receiver.Receiver</code> 这个类里，大致流程就是关于QMQ自定义协议的一个反序列化，然后再对序列化的单个消息进行存储。如图：<img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1551598452729-dfd480c5-fa43-4b60-b81a-221e3950acb1.png#align=left&display=inline&height=615&name=image.png&originHeight=615&originWidth=1141&size=114348&status=done&width=1141" alt="image.png"><br>主要逻辑在途中标红方法 <code>doInvoke</code> 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInvoke</span><span class="params">(ReceivedDelayMessage message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 注：这里是进行append的地方</span></span><br><span class="line">      ReceivedResult result = facade.appendMessageLog(message);</span><br><span class="line">      offer(message, result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">       error(message, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delay存储层相关逻辑都在facade这个类里，初始化时类似消息的校验等工作也都在这里，而message_log的相关操作都在 <code>messageLog</code> 里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> AppendMessageRecordResult <span class="title">append</span><span class="params">(RawMessageExtend record)</span> </span>&#123;</span><br><span class="line">       AppendMessageResult&lt;Long&gt; result;</span><br><span class="line">       <span class="comment">// 注：当前最新的一个segment</span></span><br><span class="line">       LogSegment segment = logManager.latestSegment();</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == segment) &#123;</span><br><span class="line">           segment = logManager.allocNextSegment();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == segment) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageRecordResult(PutMessageStatus.CREATE_MAPPED_FILE_FAILED, <span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：真正进行append的动作是messageAppender</span></span><br><span class="line">       result = segment.append(record, messageAppender);</span><br><span class="line">       <span class="keyword">switch</span> (result.getStatus()) &#123;</span><br><span class="line">           <span class="keyword">case</span> MESSAGE_SIZE_EXCEEDED:</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageRecordResult(PutMessageStatus.MESSAGE_ILLEGAL, <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">case</span> END_OF_FILE:</span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">null</span> == logManager.allocNextSegment()) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageRecordResult(PutMessageStatus.CREATE_MAPPED_FILE_FAILED, <span class="keyword">null</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> append(record);</span><br><span class="line">           <span class="keyword">case</span> SUCCESS:</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageRecordResult(PutMessageStatus.SUCCESS, result);</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageRecordResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 看一下这个appender，也可以通过这里能看到QMQ的delay message 格式定义</span></span><br><span class="line">   <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayRawMessageAppender</span> <span class="keyword">implements</span> <span class="title">MessageAppender</span>&lt;<span class="title">RawMessageExtend</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer workingBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> AppendMessageResult&lt;Long&gt; <span class="title">doAppend</span><span class="params">(<span class="keyword">long</span> baseOffset, ByteBuffer targetBuffer, <span class="keyword">int</span> freeSpace, RawMessageExtend message)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 这个lock这里影响不大</span></span><br><span class="line">           lock.lock();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               workingBuffer.clear();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">final</span> String messageId = message.getHeader().getMessageId();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">byte</span>[] messageIdBytes = messageId.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">               <span class="keyword">final</span> String subject = message.getHeader().getSubject();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">byte</span>[] subjectBytes = subject.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">long</span> startWroteOffset = baseOffset + targetBuffer.position();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> recordSize = recordSizeWithCrc(messageIdBytes.length, subjectBytes.length, message.getBodySize());</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (recordSize &gt; config.getSingleMessageLimitSize()) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult&lt;&gt;(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED, startWroteOffset, freeSpace, <span class="keyword">null</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               workingBuffer.flip();</span><br><span class="line">               <span class="keyword">if</span> (recordSize != freeSpace &amp;&amp; recordSize + MIN_RECORD_BYTES &gt; freeSpace) &#123;</span><br><span class="line">               <span class="comment">// 填充</span></span><br><span class="line">                   workingBuffer.limit(freeSpace);</span><br><span class="line">                   workingBuffer.putInt(MESSAGE_LOG_MAGIC_V1);</span><br><span class="line">                   workingBuffer.put(MessageLogAttrEnum.ATTR_EMPTY_RECORD.getCode());</span><br><span class="line">                   workingBuffer.putLong(System.currentTimeMillis());</span><br><span class="line">                   targetBuffer.put(workingBuffer.array(), <span class="number">0</span>, freeSpace);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult&lt;&gt;(AppendMessageStatus.END_OF_FILE, startWroteOffset, freeSpace, <span class="keyword">null</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">int</span> headerSize = recordSize - message.getBodySize();</span><br><span class="line">                   workingBuffer.limit(headerSize);</span><br><span class="line">                   workingBuffer.putInt(MESSAGE_LOG_MAGIC_V2);</span><br><span class="line">                   workingBuffer.put(MessageLogAttrEnum.ATTR_MESSAGE_RECORD.getCode());</span><br><span class="line">                   workingBuffer.putLong(System.currentTimeMillis());</span><br><span class="line">                   <span class="comment">// 注意这里，是schedule_time ，即延迟时间</span></span><br><span class="line">                   workingBuffer.putLong(message.getScheduleTime());</span><br><span class="line">                   <span class="comment">// sequence,每个brokerGroup应该是唯一的</span></span><br><span class="line">                   workingBuffer.putLong(sequence.incrementAndGet());</span><br><span class="line">                   workingBuffer.putInt(messageIdBytes.length);</span><br><span class="line">                   workingBuffer.put(messageIdBytes);</span><br><span class="line">                   workingBuffer.putInt(subjectBytes.length);</span><br><span class="line">                   workingBuffer.put(subjectBytes);</span><br><span class="line">                   workingBuffer.putLong(message.getHeader().getBodyCrc());</span><br><span class="line">                   workingBuffer.putInt(message.getBodySize());</span><br><span class="line">                   targetBuffer.put(workingBuffer.array(), <span class="number">0</span>, headerSize);</span><br><span class="line">                   targetBuffer.put(message.getBody().nioBuffer());</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">long</span> payloadOffset = startWroteOffset + headerSize;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult&lt;&gt;(AppendMessageStatus.SUCCESS, startWroteOffset, recordSize, payloadOffset);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>以上基本就是message_log的存储部分，接下来我们来看message_log的回放生成schedule_log。<br><a name="schedule_log"></a></p><h2 id="schedule-log"><a href="#schedule-log" class="headerlink" title="schedule_log"></a>schedule_log</h2><p>MessageLogReplayer这个类就是控制回放的地方。那么考虑一个问题，下一次重启的时候，我们该从哪里进行回放？QMQ是会有一个回放的offset，这个offset会定时刷盘，下次重启的时候会从这个offset位置开始回放。细节可以看一下下面这段代码块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> LogVisitor&lt;LogRecord&gt; visitor = facade.newMessageLogVisitor(iterateFrom.longValue());</span><br><span class="line">adjustOffset(visitor);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> Optional&lt;LogRecord&gt; recordOptional = visitor.nextRecord();</span><br><span class="line">    <span class="keyword">if</span> (recordOptional.isPresent() &amp;&amp; recordOptional.get() == DelayMessageLogVisitor.EMPTY_LOG_RECORD) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    recordOptional.ifPresent((record) -&gt; &#123;</span><br><span class="line">    <span class="comment">// post以进行存储</span></span><br><span class="line">        dispatcher.post(record);</span><br><span class="line">        <span class="keyword">long</span> checkpoint = record.getStartWroteOffset() + record.getRecordSize();</span><br><span class="line">        <span class="keyword">this</span>.cursor.addAndGet(record.getRecordSize());</span><br><span class="line">        facade.updateIterateOffset(checkpoint);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">iterateFrom.add(visitor.visitedBufferSize());</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    LOGGER.warn(<span class="string">"message log iterate sleep interrupted"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里除了offset还有个cursor，这是为了防止回放失败，sleep 5ms后再次回放的时候从cursor位置开始，避免重复消息。那么我们看一下dispatcher.post这个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(LogRecord event)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里是schedule_log</span></span><br><span class="line">      AppendLogResult&lt;ScheduleIndex&gt; result = facade.appendScheduleLog(event);</span><br><span class="line">      <span class="keyword">int</span> code = result.getCode();</span><br><span class="line">      <span class="keyword">if</span> (MessageProducerCode.SUCCESS != code) &#123;</span><br><span class="line">          LOGGER.error(<span class="string">"appendMessageLog schedule log error,log:&#123;&#125; &#123;&#125;,code:&#123;&#125;"</span>, event.getSubject(), event.getMessageId(), code);</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> AppendException(<span class="string">"appendScheduleLogError"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先看这里</span></span><br><span class="line">      iterateCallback.apply(result.getAdditional());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如以上代码，我们看略过schedule_log的存储，看一下那个callback是几个意思:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">iterateCallback</span><span class="params">(<span class="keyword">final</span> ScheduleIndex index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 延迟时间</span></span><br><span class="line">      <span class="keyword">long</span> scheduleTime = index.getScheduleTime();</span><br><span class="line">      <span class="comment">// 这个offset是startOffset,即在delay_segment中的这个消息的起始位置</span></span><br><span class="line">      <span class="keyword">long</span> offset = index.getOffset();</span><br><span class="line">      <span class="comment">// 是否add到内存中的HashWheel</span></span><br><span class="line">      <span class="keyword">if</span> (wheelTickManager.canAdd(scheduleTime, offset)) &#123;</span><br><span class="line">          wheelTickManager.addWHeel(index);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的意思是，delay-server接收到消息，会判断一下这个消息是否需要add到内存中的wheel中，以防止丢消息。大家记着有这个事情，在投递小节中我们回过头来再说这里。那么回到 <code>facade.appendScheduleLog</code> 这个方法，schedule_log相关操作在scheduleLog里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RecordResult&lt;T&gt; <span class="title">append</span><span class="params">(LogRecord record)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> scheduleTime = record.getScheduleTime();</span><br><span class="line">      <span class="comment">// 这里是根据延迟时间定位对应的delaySegment的</span></span><br><span class="line">      DelaySegment&lt;T&gt; segment = locateSegment(scheduleTime);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == segment) &#123;</span><br><span class="line">          segment = allocNewSegment(scheduleTime);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == segment) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> NopeRecordResult(PutMessageStatus.CREATE_MAPPED_FILE_FAILED);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体动作在append里</span></span><br><span class="line">      <span class="keyword">return</span> retResult(segment.append(record, appender));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>留意 <code>locateSegment</code> 这个方法，它是根据延迟时间定位 <code>DelaySegment</code> ，比如如果延迟时间是2019-03-03 16:00:00，那么就会定位到201903031600这个DelaySegment（注：这里贴的代码不是最新的，最新的是 <code>DelaySegment</code> 的刻度是可以配置，到分钟级别）。同样，具体动作也是 <code>appender</code> 做的，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AppendRecordResult&lt;ScheduleSetSequence&gt; <span class="title">appendLog</span><span class="params">(LogRecord log)</span> </span>&#123;</span><br><span class="line">        workingBuffer.clear();</span><br><span class="line">        workingBuffer.flip();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] subjectBytes = log.getSubject().getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] messageIdBytes = log.getMessageId().getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">int</span> recordSize = getRecordSize(log, subjectBytes.length, messageIdBytes.length);</span><br><span class="line">        workingBuffer.limit(recordSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> scheduleTime = log.getScheduleTime();</span><br><span class="line">        <span class="keyword">long</span> sequence = log.getSequence();</span><br><span class="line">        workingBuffer.putLong(scheduleTime);</span><br><span class="line">        <span class="comment">// message_log中的sequence</span></span><br><span class="line">        workingBuffer.putLong(sequence);</span><br><span class="line">        workingBuffer.putInt(log.getPayloadSize());</span><br><span class="line">        workingBuffer.putInt(messageIdBytes.length);</span><br><span class="line">        workingBuffer.put(messageIdBytes);</span><br><span class="line">        workingBuffer.putInt(subjectBytes.length);</span><br><span class="line">        workingBuffer.put(subjectBytes);</span><br><span class="line">        workingBuffer.put(log.getRecord());</span><br><span class="line">        workingBuffer.flip();</span><br><span class="line">        ScheduleSetSequence record = <span class="keyword">new</span> ScheduleSetSequence(scheduleTime, sequence);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendRecordResult&lt;&gt;(AppendMessageStatus.SUCCESS, <span class="number">0</span>, recordSize, workingBuffer, record);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里也能看到schedule_log的消息格式。</p><p><strong>发现就写了个存储篇幅就已经挺大了，投递涉及到的内容可能更多，那么关于投递就开个下一篇吧。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;df368884&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="MQ" scheme="https://blog.dengxf.cn/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>QMQ源码分析之delay-server篇【一】</title>
    <link href="https://blog.dengxf.cn/3159cb59.html"/>
    <id>https://blog.dengxf.cn/3159cb59.html</id>
    <published>2019-02-23T01:26:24.000Z</published>
    <updated>2019-06-27T09:48:04.199Z</updated>
    
    <content type="html"><![CDATA[<p><a name="df368884"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>QMQ是一款去哪儿网内部使用多年的mq。不久前(大概1-2年前)已在携程投入生产大规模使用，年前这款mq也开源了出来。关于<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1bmFyY29ycC9xbXE=" title="https://github.com/qunarcorp/qmq">QMQ<i class="fa fa-external-link"></i></span>的相关设计文章可以看<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1bmFyY29ycC9xbXEvdHJlZS9tYXN0ZXIvZG9jcy9jbg==" title="https://github.com/qunarcorp/qmq/tree/master/docs/cn">这里<i class="fa fa-external-link"></i></span>。在这里，我假设你已经对QMQ前世今生以及其设计和实现等背景知识已经有了一个较为全面的认识。</p></blockquote><p><a name="f2aee0d8"></a></p><h2 id="我的阅读姿势"><a href="#我的阅读姿势" class="headerlink" title="我的阅读姿势"></a>我的阅读姿势</h2><p>对一款开源产品愈来愈感兴趣，想要了解一款开源产品更多的技术细节的时候，最好的方式自然是去阅读她的源码。那么一个正确阅读开源软件源码的姿势是什么呢？我觉得这完全就像一个相亲过程：</p><ol><li>媒婆介绍相亲对象基本信息。这一定是前提。很多人都忽视了这一个步骤。在这个步骤中，要去了解这款开源软件是用来做什么的？解决了什么问题？如何解决这些问题的？所处地位？其实就是what,why,how,where四个问题。要是在阅读源码前能准备下这四个问题的答案，那么接下来阅读源码的工作将更有效果。</li><li>见面，喝茶，对媒婆所言一探究竟。这个时候我们要去认识下软件的整体结构，例如，包结构，依赖轻重，主要功能是哪些在哪里等。此外还要去验证下”媒婆所言”是否属实，我们要自己操作运行一下，对这个”姑娘”有一个基础认识。</li><li>约会。有以上基础认识之后，就要深入源码一探究竟。针对各功能点(主要是第一个步骤中谈到的解决的什么问题即why)各条线深入下去，最后贯穿起来，形成一个闭环。</li><li>自由发挥。这个时候就看缘分了，对上眼就成了contributor，对不上眼也能多个朋友多条路不是。</li></ol><p><a name="31762d66"></a></p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>对于delay-server，官方已经有了一些<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvX05XRW1rdTd2UkF1NWNjLW1LRHhLQQ==" title="https://mp.weixin.qq.com/s/_NWEmku7vRAu5cc-mKDxKA">介绍<i class="fa fa-external-link"></i></span>。记住，官方通常是最卖力的那个”媒婆”。qmq-delay-server其实主要做的是转发工作。所谓转发，就是delay-server做的就是个存储和投递的工作。怎么理解，就是qmq-client会对消息进行一个路由，即实时消息投递到实时server，延迟消息往delay-server投递，多说一句，这个路由的功能是由qmq-meta-server提供。投递到delay-server的消息会存下来，到时间之后再进行投递。现在我们知道了<code>存储</code>和<code>投递</code>是delay-server主要的两个功能点。那么我们挨个击破:<br><a name="a39cf1ca"></a></p><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>假如让我们来设计实现一个delay-server，存储部分我们需要解决什么问题？我觉得主要是要解决到期投递的<code>到期</code>问题。我们可以用传统db做，但是这个性能肯定是上不去的。我们也可以用基于LSM树的RocksDB。或者，干脆直接用文件存储。QMQ是用文件存储的。而用文件存储是怎么解决<code>到期</code>问题的呢？delay-server接收到延迟消息，就将消息append到message_log中，然后再通过回放这个message_log得到schedule_log，此外还有一个dispatch _log用于记录投递记录。QMQ还有个跟投递相关的存储设计，即两层HashWheel。第一层位于磁盘上，例如，以一个小时一个刻度一个文件，我们叫delay_message_segment，如延迟时间为2019年02月23日 19:00 至2019年02月23日 20:00为延迟消息将被存储在2019022319。并且这个刻度是可以配置调整的。第二层HashWheel位于内存中。也是以一个时间为刻度，比如500ms，加载进内存中的延迟消息文件会根据延迟时间hash到一个HashWheel中，第二层的wheel涉及更多的是下一小节的<strong>投递</strong>。貌似存储到这里就结束了，然而还有一个问题，目前当投递的时候我们需要将一个delay_message_segment加载进内存中，而假如我们提前一个刻度加载进一个delay_message_segment到内存中的hashwheel，比如在2019年02月23日 18:00加载2019022319这个segment文件，那么一个hashwheel中就会存在两个delay_message_segment，而这个时候所占内存是非常大的，所以这是完全不可接收的。所以，QMQ引入了一个数据结构，叫schedule_index，即消息索引，存储的内容为消息的索引，我们加载到内存的是这个schedule_index，在真正投递的时候再根据索引查到消息体进行投递。<br><a name="31cb9169"></a></p><h4 id="投递"><a href="#投递" class="headerlink" title="投递"></a>投递</h4><p>解决了存储，那么到期的延迟消息如何投递呢？如在上一小节<strong>存储</strong>中所提到的，内存中的hashwheel会提前一段时间加载delay_schedule_index，这个时间自然也是可以配置的。而在hashwheel中，默认每500ms会tick一次，这个500ms也是可以根据用户需求配置的。而在投递的时候，QMQ根据实时broker进行分组多线程投递，如果某一broker离线不可用，导致投递失败，delay-server会将延迟消息投递在其他<code>存活</code>的实时broker。其实这里对于实时的broker应该有一个关于投递消息权重的，现在delay-server没有考虑到这一点，不过我看已经有一个pr解决了这个问题，只是官方还没有时间看这个问题。除此之外，QMQ还考虑到了要是当前延迟消息所属的delay_segment已经加载到内存中的hashwheel了，这个时候消息应该是直接投递或也应加载到hashwheel中的。这里需要考虑的情况还是比较多的，比如考虑delay_segment正在加载、已经加载、加载完成等情况，对于这种情况，QMQ用了两个cursor来表示hashwheel加载到哪个delay_segment以及加载到对应segment的什么offset了，这里还是挺复杂的，这里的代码逻辑在<code>WheelTickManager</code>这个类。</p><hr><p>我们先来看一看整体结构<br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550935854945-5930d1df-0316-4e07-8d51-4f794093200f.png#align=left&display=inline&height=746&name=image.png&originHeight=746&originWidth=1366&size=265433&status=done&width=1366" alt="image.png"><br>以功能划分的包结构，算是比较清晰。cleaner是日志清理工作相关，receiver是接收消息相关，sender是投递相关，store是存储相关，sync是同步备份相关，wheel则是hashwheel相关。</p><p><strong>关于QMQ源码阅读前的准备工作就先做到这里，下一篇我们就深入源码分析以上提到的各个细节。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;df368884&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="MQ" scheme="https://blog.dengxf.cn/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>如何科学上网？</title>
    <link href="https://blog.dengxf.cn/8c46c59b.html"/>
    <id>https://blog.dengxf.cn/8c46c59b.html</id>
    <published>2019-02-14T18:54:09.000Z</published>
    <updated>2019-06-27T09:48:04.199Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为了给我们提供一个<code>安全</code>的网络环境，所以先驱前辈们建立了一堵墙。总有些<code>调皮</code> <code>好奇</code>的孩子想要翻过墙去看看墙那边的世界。但是存在风险，需谨慎。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550203371840-7da7ce17-8331-4d90-9a69-0e2e66e5d844.png#align=left&display=inline&height=368&name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190215120239.png&originHeight=948&originWidth=1920&size=59975&width=746" alt="微信图片_20190215120239.png"><br>共有下面两种方式供选择：<br><a name="50c84e82"></a></p><h2 id="利用VPN"><a href="#利用VPN" class="headerlink" title="利用VPN"></a>利用VPN</h2><p><a name="aa2c9140"></a></p><h4 id="免费"><a href="#免费" class="headerlink" title="免费"></a>免费</h4><p>免费的vpn有很多，但是速度、稳定性和流量限制是基本不能满足需要的，所以就不推荐了。<br><a name="b00379d1"></a></p><h4 id="收费"><a href="#收费" class="headerlink" title="收费"></a>收费</h4><p>收费的vpn一般都在每月10元左右，并且足够稳定。另外，建议大家选择国外的vpn，国内的vpn产商说不定哪天就跑路什么的。在这里，推荐ExpressVPN和PureVPN。前者比较知名，也比较<code>稳健</code>，价格大概在每月$7+；后者也相对比较好用，每月大概在$3+，说是有中国用户的专线。<br>详情可<span class="exturl" data-url="aHR0cHM6Ly93d3cudnBuZGFkYS5jb20vYmVzdC12cG5zLWZvci1jaGluYS1jbi8=" title="https://www.vpndada.com/best-vpns-for-china-cn/">参考<i class="fa fa-external-link"></i></span>。<a name="a27e687d"></a></p><h2 id="自建代理"><a href="#自建代理" class="headerlink" title="自建代理"></a>自建代理</h2><p>喜欢掌握主动权的我，倾向于采用自建代理的方案。综合来看自建代理都是最实惠，最可控的方案。<br><a name="96f439d6"></a></p><h4 id="购买VPS"><a href="#购买VPS" class="headerlink" title="购买VPS"></a>购买VPS</h4><p>目前VPS产商有两家做的最大，分别是BandwagonHost(搬瓦工)和Vultr。有篇<span class="exturl" data-url="aHR0cHM6Ly9mbHl6eWJsb2cuY29tL2JhbmR3YWdvbmhvc3QtdnVsdHItY29tcGFyaXNvbi8=" title="https://flyzyblog.com/bandwagonhost-vultr-comparison/">文章<i class="fa fa-external-link"></i></span>对比了这两家厂商的产品。<br>购买VPS都是有优惠的，<span class="exturl" data-url="aHR0cDovL2JhbndhZ29uZy5jbi8=" title="http://banwagong.cn/">搬瓦工<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cHM6Ly93d3cudnVsdHJ5aHcuY24v" title="https://www.vultryhw.cn/">Vultr<i class="fa fa-external-link"></i></span>。<br>因为搬瓦工比较老牌，老而弥坚，所以我选择的是它。如果你不喜欢老而弥<code>坚</code>的东西，选择了Vultr，那么请移步看<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3RhY2tjYy5jb20vMjAxOC8xMS8wOC9zc3ItdnBzLw==" title="https://www.stackcc.com/2018/11/08/ssr-vps/">搭建SSR<i class="fa fa-external-link"></i></span>。购买时注意是不是支持中国专线，如果没注意，那么购买成功之后也是可以更改线路的。购买完成，你会受到一封邮件，里边有ip port password等信息，连接上vps，安装完一些基础工具(wget等)，就可以开干了。<br><a name="8cc36ea8"></a></p><h4 id="搭建代理"><a href="#搭建代理" class="headerlink" title="搭建代理"></a>搭建代理</h4><p>现在用的最多的就是<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoYWRvd3NvY2tz" title="https://github.com/shadowsocks">shadowsocks<i class="fa fa-external-link"></i></span>，以及其衍生版本<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoYWRvd3NvY2tzci1iYWNrdXA=" title="https://github.com/shadowsocksr-backup">shadowsocks r<i class="fa fa-external-link"></i></span>。我选择的是shadowsockr。这里有个<span class="exturl" data-url="aHR0cHM6Ly9zc3IudG9vbHMv" title="https://ssr.tools/">ssr<i class="fa fa-external-link"></i></span>工具网站，客户端，一键安装脚本在这里都能找到。</p><ol><li>ssh连接上vps</li><li>依次运行下边三条命令：<br></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x shadowsocks-all.sh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure><ol><li>接下来按照提示，选择参数安装即可，步骤大概为：<ol><li>选择版本，建议ShadowsocksR</li><li>设置SSR密码</li><li>选择SSR服务器端口</li><li>选择加密方式<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/261134/1550223183058-b27b72ac-027a-4550-8273-f8516e1c1f1b.jpeg#align=left&display=inline&height=290&name=2018-07-12_154549.jpg&originHeight=290&originWidth=446&size=23089&width=446" alt="2018-07-12_154549.jpg"><br>如这里选择chacha20，输入对应序号12即可。</li><li>选择协议<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/261134/1550223232353-b1c4eea1-8116-4bab-b3ae-366e0c83982d.jpeg#align=left&display=inline&height=230&name=2018-07-12_154640.jpg&originHeight=230&originWidth=420&size=23545&width=420" alt="2018-07-12_154640.jpg"><br>如这里选择auth_aes128_md5，输入对应序号5即可</li><li>选择混淆方式<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/261134/1550223307214-0422bcaf-06ae-4139-b639-8958cb161b0a.jpeg#align=left&display=inline&height=182&name=2018-07-12_154714.jpg&originHeight=182&originWidth=392&size=18147&width=392" alt="2018-07-12_154714.jpg"><br>如这里选择http_simple，输入对应序号2即可</li><li>参数设置完成，任意键开始安装，静静等待。</li><li><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/261134/1550223377785-43bafaa1-6fd7-4030-a2a6-030421a377ae.jpeg#align=left&display=inline&height=325&name=2018-07-12_155328.jpg&originHeight=325&originWidth=644&size=39392&width=644" alt="2018-07-12_155328.jpg"><br>安装完成，你会看到以上信息，记录下来，待会儿会用到。你也可以在下图文件夹下的config.json看到。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550223556002-311135cd-fbdb-4c3c-9bf7-1d7f02b25dc5.png#align=left&display=inline&height=272&name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190215173855.png&originHeight=272&originWidth=556&size=4809&width=556" alt="微信图片_20190215173855.png"><br><br><a name="e4dba1fd"></a><h4 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a>客户端安装</h4><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoYWRvd3NvY2tzcnIvc2hhZG93c29ja3NyLWNzaGFycC9yZWxlYXNlcw==" title="https://github.com/shadowsocksrr/shadowsocksr-csharp/releases">windows<i class="fa fa-external-link"></i></span> 下载<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Fpbnl1aGFuZy9TaGFkb3dzb2Nrc1gtTkctUi9yZWxlYXNlcw==" title="https://github.com/qinyuhang/ShadowsocksX-NG-R/releases">mac<i class="fa fa-external-link"></i></span>下载<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoYWRvd3NvY2tzcnIvc2hhZG93c29ja3NyLWFuZHJvaWQvcmVsZWFzZXM=" title="https://github.com/shadowsocksrr/shadowsocksr-android/releases">andriod<i class="fa fa-external-link"></i></span>下载 或者在应用商城看一下有没有shadowsocks-r(或者ssr)客户端下载<br>ios 免费的App可以用Potatso Lite，不过应该需要<span class="exturl" data-url="aHR0cHM6Ly9zc3IudG9vbHMvMTA0" title="https://ssr.tools/104">申请<i class="fa fa-external-link"></i></span>一下美国AppleID<br>安装完毕，输入安装完毕让你记下的那些信息(在/etc/shadowsocks-r/config.json，或者在刚才安装的目录下找到shadowsocks-all.log文件里也有相关信息)。另外，ssr客户端支持二维码扫描，剪贴板导入等方式，很方便，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550225021512-044ebcee-5e88-4073-b67d-3630d915b71b.png#align=left&display=inline&height=106&name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190215180301.png&originHeight=106&originWidth=238&size=19155&width=238" alt="微信图片_20190215180301.png"><br>安卓上效果如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550225391948-1810ccd1-1ab2-412f-99a9-0fc3c3dcabb5.png#align=left&display=inline&height=846&name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190215180933.png&originHeight=846&originWidth=531&size=565850&width=531" alt="微信图片_20190215180933.png"><br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550225391033-e95f0c13-f1be-4b8e-8b21-686736e93f04.png#align=left&display=inline&height=840&name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190215180822.png&originHeight=840&originWidth=423&size=164845&width=423" alt="微信图片_20190215180822.png"><br>好了，安卓和ios设备现在基本都能上网了。但是pc端还需要一个东西，即chrome的一个插件，<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3dpdGNoeW9tZWdhLmNvbS8=" title="https://www.switchyomega.com/">swithy omega<i class="fa fa-external-link"></i></span>。下载插件添加到chrome完毕，配置如下图：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550225813408-a0996f52-f174-414e-86b0-4587373541ee.png#align=left&display=inline&height=349&name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190215181638.png&originHeight=899&originWidth=1920&size=74173&width=746" alt="微信图片_20190215181638.png"><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550225813437-708b1d32-c8d5-4df9-99ac-636e21e35f9b.png#align=left&display=inline&height=349&name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190215181642.png&originHeight=899&originWidth=1920&size=41237&width=746" alt="微信图片_20190215181642.png"></li></ol></li></ol><p>其中的规则列表网址：<span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2dmd2xpc3QvZ2Z3bGlzdC9tYXN0ZXIvZ2Z3bGlzdC50eHQ=" title="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt<i class="fa fa-external-link"></i></span> 详情可以参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dmd2xpc3QvZ2Z3bGlzdA==" title="https://github.com/gfwlist/gfwlist">gfwlist<i class="fa fa-external-link"></i></span></p><p>就是这些，你可以科学上网了。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;为了给我们提供一个&lt;code&gt;安全&lt;/code&gt;的网络环境，所以先驱前辈们建立了一堵墙。总有些&lt;code&gt;调皮&lt;/code&gt;
        
      
    
    </summary>
    
      <category term="工具" scheme="https://blog.dengxf.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="科学上网" scheme="https://blog.dengxf.cn/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>2018年终总结</title>
    <link href="https://blog.dengxf.cn/59ca7e41.html"/>
    <id>https://blog.dengxf.cn/59ca7e41.html</id>
    <published>2018-12-31T08:00:00.000Z</published>
    <updated>2019-06-27T09:47:19.712Z</updated>
    
    <content type="html"><![CDATA[<p align="center">__又到年底，然而今年并不打算再写年终总结。__</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p
        
      
    
    </summary>
    
      <category term="生活" scheme="https://blog.dengxf.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="杂谈" scheme="https://blog.dengxf.cn/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
