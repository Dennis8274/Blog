<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>泊客</title>
  
  <subtitle>心之所向</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.dengxf.cn/"/>
  <updated>2019-05-05T07:11:07.919Z</updated>
  <id>https://blog.dengxf.cn/</id>
  
  <author>
    <name>邓旭峰</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDK源码阅读之Semaphore</title>
    <link href="https://blog.dengxf.cn/61e94ea2.html"/>
    <id>https://blog.dengxf.cn/61e94ea2.html</id>
    <published>2019-05-04T22:11:57.000Z</published>
    <updated>2019-05-05T07:11:07.919Z</updated>
    
    <content type="html"><![CDATA[<p><a name="U1hgY"></a></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>作者<em>Doug Lea</em>如此描述这个类：A counting semaphore.  Conceptually, a semaphore maintains a set of permits.<br>顾名思义。计数信号量，它维护令牌数量。acquire一个令牌阻塞至池里有可用令牌，release一个令牌即往池里添加一个令牌。<br>如下为源码中示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AVAILABLE = <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Semaphore available = <span class="keyword">new</span> Semaphore(MAX_AVAILABLE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     available.acquire();</span><br><span class="line">     <span class="keyword">return</span> getNextAvailableItem();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putItem</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (markAsUnused(x))</span><br><span class="line">       available.release();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Not a particularly efficient data structure; just for demo</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span> Object[] items = ... whatever kinds of items being managed</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_AVAILABLE];</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Object <span class="title">getNextAvailableItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">          used[i] = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">return</span> items[i];</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// not reached</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">markAsUnused</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">       <span class="keyword">if</span> (item == items[i]) &#123;</span><br><span class="line">          <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，示例中用到的api就两个，即acquire和release，意为获取一个许可及释放一个许可。<br><a name="WJ47a"></a></p><h1 id="Sync变量"><a href="#Sync变量" class="headerlink" title="Sync变量"></a>Sync变量</h1><p>内部抽象类Sync继承自AQS，用AQS中的volatile int state变量表示许可数量。Sync的子类有两个版本，fair和nonfair。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">      <span class="comment">// state 表示当前许可数量</span></span><br><span class="line">        setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非公平式获取许可，cas操作，state减去acquires</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">          <span class="comment">// 注意这里remaining &lt; 0</span></span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放许可就是state + releases</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> next = current + releases;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">            <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 非公平式获取许可，调用父类（Sync）的nonfairTryAcquireShared</span></span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">// 先查看有没有前驱在阻塞等着获取许可，如果有，当前线程获取失败</span></span><br><span class="line">          <span class="comment">// 这就是跟非公平的区别</span></span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync的两个子类，NonfairSync和FairSync，分别表示在获取许可时是非公平式（抢占式）和公平式。<br><a name="Oqmwt"></a></p><h1 id="Semaphore-acquire"><a href="#Semaphore-acquire" class="headerlink" title="Semaphore.acquire"></a>Semaphore.acquire</h1><p>获取许可，调用Sync.acquireSharedInterruptibly(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">  <span class="comment">// 调用内部实现类tryAcquireShared</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 池中许可数量小于0，即state&lt;0</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// 在链表尾部添加一个node表示当前阻塞的节点</span></span><br><span class="line">  <span class="comment">// 注意头结点为一个标识节点，如下addWaiter方法</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">// 前驱</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">              <span class="comment">// 调用内部类（fair or nonfair）实现tryAcquireShared，获取许可</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// 许可数量恢复&gt;0，设置当前节点为头节点并且唤醒下一节点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 没有许可可获取，阻塞在这里，等待唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 链表中没有前驱</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">              <span class="comment">// 先要设置一个"空"头结点</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意，当没有阻塞的节点时，即链表为空，这时往链表添加节点时是往一个”空”头节点后添加。唤醒时，在阻塞位置恢复再次循环，如果前驱是头结点且当前池中有许可，那么设置当前节点为头结点，并唤醒下一节点，否则再次阻塞。<br><a name="oYWC0"></a></p><h1 id="Semaphore-release"><a href="#Semaphore-release" class="headerlink" title="Semaphore.release"></a>Semaphore.release</h1><p>调用Sync.releaseShared(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// sync中的tryReleaseShared, state += arg</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">      <span class="comment">// 如果有阻塞的节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">          <span class="comment">// 阻塞时，在shouldParkAfterFailedAcquire这个方法里，将node的前驱已经设置为SIGNAL</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">              <span class="comment">// 唤醒h的下一节点，如下unparkSuccessor分析</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;      </span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 从后往前找，去掉已经cancel的节点，见AQS类waitStatus的可取类型</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">      <span class="comment">// 唤醒node的下一可用节点</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唤醒时总是唤醒头结点的下一节点。注意waitStatus这个状态，在阻塞时，会在shouldParkAfterFailedAcquire这个方法里，将当前阻塞节点的前缀设置为SIGNAL。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;U1hgY&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;作者&lt;em&gt;Doug Lea&lt;/em&gt;如此描述这个类：A
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JDK" scheme="https://blog.dengxf.cn/tags/JDK/"/>
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读之CyclicBarrier</title>
    <link href="https://blog.dengxf.cn/97e68def.html"/>
    <id>https://blog.dengxf.cn/97e68def.html</id>
    <published>2019-05-03T22:40:33.000Z</published>
    <updated>2019-05-05T07:11:07.923Z</updated>
    
    <content type="html"><![CDATA[<p><a name="LPm8j"></a></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p><em>作者Doug Lea</em>如此描述这个类：A synchronization aid that allows a set of threads to all wait for  each other to reach a common barrier point.<br>这也是一个多线程协调的辅助工具类。barrier可翻译为栅栏，顾名思义，这个类控制先到的线程则在”栅栏”处等待其他线程，直到所有线程都到达，再接着往下执行。此外，CyclicBarrier如其名，是循环可复用的。<br>如下是源码中给出的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solver</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> N;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">float</span>[][] data;</span><br><span class="line">   <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> myRow;</span><br><span class="line">     Worker(<span class="keyword">int</span> row) &#123; myRow = row; &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">while</span> (!done()) &#123;</span><br><span class="line">         processRow(myRow);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 等待一行处理结束</span></span><br><span class="line">           barrier.await();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (BrokenBarrierException ex) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Solver</span><span class="params">(<span class="keyword">float</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">     data = matrix;</span><br><span class="line">     N = matrix.length;</span><br><span class="line">     <span class="comment">// 所有行处理完，再merge</span></span><br><span class="line">     Runnable barrierAction =</span><br><span class="line">       <span class="keyword">new</span> Runnable() &#123; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; mergeRows(...); &#125;&#125;;</span><br><span class="line">     barrier = <span class="keyword">new</span> CyclicBarrier(N, barrierAction);</span><br><span class="line"></span><br><span class="line">     List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;Thread&gt;(N);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">       Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(i));</span><br><span class="line">       threads.add(thread);</span><br><span class="line">       thread.start();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// wait until done</span></span><br><span class="line">     <span class="keyword">for</span> (Thread thread : threads)</span><br><span class="line">       thread.join();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如以上示例，并行处理每行矩阵元素，待所有行处理结束再对每行处理结果进行合并。<br><a name="hn33q"></a></p><h1 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h1><p>//  可重入锁控制对barrier的访问<br>private final ReentrantLock lock = new ReentrantLock();<br>// 控制线程阻塞，直到所有线程”到达”<br>private final Condition trip = lock.newCondition();<br>// 多少个参与方(线程)<br>private final int parties;<br>// 到达栅栏后执行的线程<br>private final Runnable barrierCommand;<br>// 内部类表示目前是哪一代<br>private Generation generation = new Generation()<br>// 还有几个参与方(线程)在未到达<br>private int count;</p><p>Generation为内部类，当触发栅栏或者重置，generation就会改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 标识栅栏有没有被"踢翻"</span></span><br><span class="line">    <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><a name="qJUEu"></a></p><h1 id="CyclicBarrier-await"><a href="#CyclicBarrier-await" class="headerlink" title="CyclicBarrier.await"></a>CyclicBarrier.await</h1><p>由源码中的示例代码，await是CyclicBarrier的主要起作用的方法。<br>首先先看一下构造方法中对内部变量的初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">      <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="comment">// 初始parties个线程</span></span><br><span class="line">      <span class="keyword">this</span>.count = parties;</span><br><span class="line">      <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>构造方法里就初始化了三个变量，分别是表示多少个线程的parties、还有多少个线程未到达的count、后置线程barrierCommand。<br>await方法是调用内部私有方法dowait:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">        TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 当前代</span></span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">          <span class="comment">// 抱歉，栅栏已经被踢翻了</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">          <span class="comment">// 线程中断了，需要唤醒所有线程</span></span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">          <span class="comment">// 所有线程已到达</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                  <span class="comment">// 后置线程</span></span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">              <span class="comment">// 重置状态并唤醒所有线程</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                  <span class="comment">// condition.await 调用AQS里的Condition实现类</span></span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                  <span class="comment">// 允许只等待一定时间</span></span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">              <span class="comment">// 物是人非，已经不是睡之前的时代了</span></span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CyclicBarrier利用ReentrantLock控制对barrier的加锁访问，ReentrantLock.condition控制线程的阻塞唤醒。内部类Generation表示栅栏的一次生命周期，而每次栅栏被踢翻，generation要换代，即CyclicBarrier是可循环复用的。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;LPm8j&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;&lt;em&gt;作者Doug Lea&lt;/em&gt;如此描述这个类：A
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JDK" scheme="https://blog.dengxf.cn/tags/JDK/"/>
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读之CountDownLatch</title>
    <link href="https://blog.dengxf.cn/bdd3aaa7.html"/>
    <id>https://blog.dengxf.cn/bdd3aaa7.html</id>
    <published>2019-05-01T05:02:39.000Z</published>
    <updated>2019-05-05T07:11:07.923Z</updated>
    
    <content type="html"><![CDATA[<p><a name="nDtHU"></a></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p><em>作者Doug Lea</em>如此描述这个类：A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.<br>这是一个多线程协调的辅助类。源码中给出的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">     CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();</span><br><span class="line"></span><br><span class="line">     doSomethingElse();            <span class="comment">// don't let run yet</span></span><br><span class="line">     startSignal.countDown();      <span class="comment">// let all threads proceed</span></span><br><span class="line">     doSomethingElse();</span><br><span class="line">     doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">   Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">     <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line">     <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       startSignal.await();</span><br><span class="line">       doWork();</span><br><span class="line">       doneSignal.countDown();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>通过示例对CountDownLatch的使用场景应该有个清晰的认识。即当有需要线程等待，直到在其他线程的一系列操作完成之后，再接着往下执行。<br><a name="lqsge"></a></p><h1 id="Sync变量"><a href="#Sync变量" class="headerlink" title="Sync变量"></a>Sync变量</h1><p>Sync类是CountDownLatch的一个内部类，继承自AbstractQueuedSynchronizer，也就是常说的AQS。内部类重写了AQS的tryAcquireShared和tryReleaseShared两个方法。此外Sync的构造函数带一个int参数，在构造函数内调用了AQS的setState方法，这个方法是对AQS的内部一个int volatile变量赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在上边的示例中，我们用到了CountDownLatch的await方法和countDown方法，CountDownLatch的功能也就是通过这两个方法实现。这两个方法其实也就是调用sync。<br><a name="Wmmj6"></a></p><h1 id="CountDownLatch-await"><a href="#CountDownLatch-await" class="headerlink" title="CountDownLatch.await"></a>CountDownLatch.await</h1><p><strong>功能</strong>：当前线程等待，直到state等于0，或该线程interrupt。<br>该方法就是调用sync.acquireSharedInterruptibly(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">  <span class="comment">// 调用实现类Sync的tryAcquireShared</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// state 不等于 0 则执行</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// 用一个链表来表示需要"wait"的线程，在链表尾部加入一个node</span></span><br><span class="line">  <span class="comment">// 注意 如果head == null ,则初始化一个head，令head.next = node</span></span><br><span class="line">  <span class="comment">// 所以能理解state==0,一一唤醒所有等待的线程时，是唤醒头结点的下一节点所表示的线程</span></span><br><span class="line">  <span class="comment">// 这样就达到了唤醒所有线程的目的</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">// 前驱</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">          <span class="comment">// 如果当前节点为头节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">              <span class="comment">// 调用CountDownLatch实现类里的tryAcquireShared</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// 当state == 0时，设置node为头结点</span></span><br><span class="line">                  <span class="comment">// 并且唤醒(LockSupport.unpark)node下一节点的所表示的线程</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// wait，直到state == 0 时被唤醒（LockSupport.unpark）</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结：CountDownLatch.await就是调用LockSupport.park阻塞当前线程，并用一链表表示所有阻塞的线程，方便唤醒时一一唤醒。<br><a name="QRD9K"></a></p><h1 id="CountDownLatch-countDown"><a href="#CountDownLatch-countDown" class="headerlink" title="CountDownLatch.countDown"></a>CountDownLatch.countDown</h1><p>功能：令state减1，但state为0时，唤醒所有等待线程。<br>该方法是调用sync.releaseShared(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用实现类Sync的tryReleaseShared</span></span><br><span class="line">    <span class="comment">// state减1</span></span><br><span class="line">      <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 当state减为0时</span></span><br><span class="line">          doReleaseShared();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒等待链表的头结点的下一节点</span></span><br><span class="line"><span class="comment">// 下一节点唤醒后在doAcquireSharedInterruptibly这个方法中继续循环</span></span><br><span class="line"><span class="comment">// 直到执行setHeadAndPropagate，在此方法中又会调用doReleaseShared,唤醒接下来的节点</span></span><br><span class="line"><span class="comment">// 依次一一唤醒，直到唤醒所有等待线程节点</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">       * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">       * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">       * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">       * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">       * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">       * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">       * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">       * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          Node h = head;</span><br><span class="line">          <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">              <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">              <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// cas头结点状态为初始状态</span></span><br><span class="line">                  <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                      <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                  <span class="comment">// 此方法中是唤醒头结点的下一线程节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                       !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                  <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">// 如果线程节点改变重新循环</span></span><br><span class="line">          <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒node下一线程节点</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">       * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">       * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">      <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">          compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">       * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">       * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">       * non-cancelled successor.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      Node s = node.next;</span><br><span class="line">      <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// node后继节点可能为null或cancel</span></span><br><span class="line">          <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">              <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                  s = t;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 唤醒节点s表示线程</span></span><br><span class="line">          LockSupport.unpark(s.thread);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch源码分析的整个流程就是这样。CountDownLatch的功能是基于AQS展开，在后续的JUC的分析文章中还可以看到AQS的身影。接下来仍会对JDK中的源码做一些分析工作，重心会在JUC上。谢谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;nDtHU&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;&lt;em&gt;作者Doug Lea&lt;/em&gt;如此描述这个类：A
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JDK" scheme="https://blog.dengxf.cn/tags/JDK/"/>
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>QMQ源码分析之Actor</title>
    <link href="https://blog.dengxf.cn/93d6d117.html"/>
    <id>https://blog.dengxf.cn/93d6d117.html</id>
    <published>2019-03-22T19:00:16.000Z</published>
    <updated>2019-05-05T07:11:07.927Z</updated>
    
    <content type="html"><![CDATA[<p><a name="df368884"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>QMQ有关actor的一篇<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1bmFyY29ycC9xbXEvYmxvYi9tYXN0ZXIvZG9jcy9jbi9hY3Rvci5tZA==" title="https://github.com/qunarcorp/qmq/blob/master/docs/cn/actor.md">文章<i class="fa fa-external-link"></i></span>阐述了actor的应用场景。即client消费消息的请求会先进入一个RequestQueue，在client消费消息时，往往存在多个主题、多个消费组共享一个RequestQueue消费消息。在这个Queue中，存在不同主题的有不同消费组数量，以及不同消费组有不同consumer数量，那么就会存在抢占资源的情况。举个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1bmFyY29ycC9xbXEvYmxvYi9tYXN0ZXIvZG9jcy9jbi9hY3Rvci5tZA==" title="https://github.com/qunarcorp/qmq/blob/master/docs/cn/actor.md">文章<i class="fa fa-external-link"></i></span>中的例子，一个主题下有两个消费组A和B，A有100个consumer，B有200个consumer，那么在RequestQueue中来自B的请求可能会多于A，这个时候就存在消费unfair的情况，所以需要隔离不同主题不同消费组以保证fair。除此之外，当consumer消费能力不足，造成broker消息堆积，这个时候就会导致consumer所在消费组总在消费”老消息”，影响全局整体的一个消费能力。因为”老消息”不会存在page cache中，这个时候很可能就会从磁盘load，那么表现是RequestQueue中来自消费”老消息”消费组的请求处理时间过长，影响到其他主题消费组的消费，因此这个时候也需要做策略来避免不同消费组的相互影响。所以QMQ就有了actor机制，以消除各个消费组之间因消费能力不同、consumer数量不同而造成的相互影响各自的消费能力。</p></blockquote><p><a name="PullMessageWorker"></a></p><h1 id="PullMessageWorker"><a href="#PullMessageWorker" class="headerlink" title="PullMessageWorker"></a>PullMessageWorker</h1><p>要了解QMQ的actor模式是如何起作用的，就要先来看看Broker是如何处理消息拉取请求的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PullMessageWorker</span> <span class="keyword">implements</span> <span class="title">ActorSystem</span>.<span class="title">Processor</span>&lt;<span class="title">PullMessageProcessor</span>.<span class="title">PullEntry</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 消息存储层</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageStoreWrapper store;</span><br><span class="line">    <span class="comment">// actor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ActorSystem actorSystem;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ConcurrentMap&lt;String, Object&gt;&gt; subscribers;</span><br><span class="line"></span><br><span class="line">    PullMessageWorker(MessageStoreWrapper store, ActorSystem actorSystem) &#123;</span><br><span class="line">        <span class="keyword">this</span>.store = store;</span><br><span class="line">        <span class="keyword">this</span>.actorSystem = actorSystem;</span><br><span class="line">        <span class="keyword">this</span>.subscribers = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pull</span><span class="params">(PullMessageProcessor.PullEntry pullEntry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// subject+group作actor调度粒度</span></span><br><span class="line">        <span class="keyword">final</span> String actorPath = ConsumerGroupUtils.buildConsumerGroupKey(pullEntry.subject, pullEntry.group);</span><br><span class="line">        <span class="comment">// actor调度</span></span><br><span class="line">        actorSystem.dispatch(actorPath, pullEntry, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(PullMessageProcessor.PullEntry entry</span></span></span><br><span class="line"><span class="function"><span class="params">                           , ActorSystem.Actor&lt;PullMessageProcessor.PullEntry&gt; self)</span> </span>&#123;</span><br><span class="line">        QMon.pullQueueTime(entry.subject, entry.group, entry.pullBegin);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始处理请求的时候就过期了，那么就直接不处理了，也不返回任何东西给客户端，客户端等待超时</span></span><br><span class="line">        <span class="comment">//因为出现这种情况一般是server端排队严重，暂时挂起客户端可以避免情况恶化</span></span><br><span class="line">        <span class="comment">// deadline机制，如果QMQ认为这个消费请求来不及处理，那么就直接返回，避免雪崩</span></span><br><span class="line">      <span class="keyword">if</span> (entry.expired()) &#123;</span><br><span class="line">            QMon.pullExpiredCountInc(entry.subject, entry.group);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.isInValid()) &#123;</span><br><span class="line">            QMon.pullInValidCountInc(entry.subject, entry.group);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 存储层find消息</span></span><br><span class="line">        <span class="keyword">final</span> PullMessageResult pullMessageResult = store.findMessages(entry.pullRequest);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pullMessageResult == PullMessageResult.FILTER_EMPTY ||</span><br><span class="line">                pullMessageResult.getMessageNum() &gt; <span class="number">0</span></span><br><span class="line">                || entry.isPullOnce()</span><br><span class="line">                || entry.isTimeout()) &#123;</span><br><span class="line">            entry.processMessageResult(pullMessageResult);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 没有拉取到消息，那么挂起该actor</span></span><br><span class="line">        self.suspend();</span><br><span class="line">      <span class="comment">// timer task，在超时前唤醒actor</span></span><br><span class="line">        <span class="keyword">if</span> (entry.setTimerOnDemand()) &#123;</span><br><span class="line">            QMon.suspendRequestCountInc(entry.subject, entry.group);</span><br><span class="line">          <span class="comment">// 订阅消息，一有消息来就唤醒该actor</span></span><br><span class="line">            subscribe(entry.subject, entry.group);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 已经超时，那么即刻唤醒调度</span></span><br><span class="line">        self.resume();</span><br><span class="line">        entry.processNoMessageResult();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(String subject, String group)</span> </span>&#123;</span><br><span class="line">        ConcurrentMap&lt;String, Object&gt; map = subscribers.get(subject);</span><br><span class="line">        <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">            map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">            map = ObjectUtils.defaultIfNull(subscribers.putIfAbsent(subject, map), map);</span><br><span class="line">        &#125;</span><br><span class="line">        map.putIfAbsent(group, HOLDER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有消息来就唤醒订阅的subscriber</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remindNewMessages</span><span class="params">(<span class="keyword">final</span> String subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ConcurrentMap&lt;String, Object&gt; map = <span class="keyword">this</span>.subscribers.get(subject);</span><br><span class="line">        <span class="keyword">if</span> (map == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String group : map.keySet()) &#123;</span><br><span class="line">            map.remove(group);</span><br><span class="line">            <span class="keyword">this</span>.actorSystem.resume(ConsumerGroupUtils.buildConsumerGroupKey(subject, group));</span><br><span class="line">            QMon.resumeActorCountInc(subject, group);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActorSystem内定义的处理接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ActorSystem</span>.<span class="title">Processor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">process</span><span class="params">(T message, Actor&lt;T&gt; self)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能看除在这里起作用的是这个actorSystem。PullMessageWorker继承了ActorSystem.Processor，所以真正处理拉取请求的是这个接口里的process方法。请求到达pullMessageWorker，worker将该次请求交给actorSystem调度，调度到这次请求时，worker还有个根据拉取结果做反应的策略，即如果暂时没有消息，那么suspend，以一个timer task定时resume；如果在timer task执行之前有消息进来，那么也会即时resume。<br><a name="ActorSystem"></a></p><h1 id="ActorSystem"><a href="#ActorSystem" class="headerlink" title="ActorSystem"></a>ActorSystem</h1><p>接下来就看看ActorSystem里边是如何做的<code>公平调度</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActorSystem</span> </span>&#123;</span><br><span class="line"><span class="comment">// 内部维护的是一个ConcurrentMap，key即PullMessageWorker里的subject+group</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Actor&gt; actors;</span><br><span class="line">    <span class="comment">// 执行actor的executor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor executor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger actorsCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActorSystem</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name, Runtime.getRuntime().availableProcessors() * <span class="number">4</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActorSystem</span><span class="params">(String name, <span class="keyword">int</span> threads, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.actorsCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="comment">// 这里根据fair参数初始化一个优先级队列作为executor的参数，处理关于前言里说的"老消息"的情况</span></span><br><span class="line">        BlockingQueue&lt;Runnable&gt; queue = fair ? <span class="keyword">new</span> PriorityBlockingQueue&lt;&gt;() : <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.executor = <span class="keyword">new</span> ThreadPoolExecutor(threads, threads, <span class="number">60</span>, TimeUnit.MINUTES, queue, <span class="keyword">new</span> NamedThreadFactory(<span class="string">"actor-sys-"</span> + name));</span><br><span class="line">        <span class="keyword">this</span>.actors = Maps.newConcurrentMap();</span><br><span class="line">        QMon.dispatchersGauge(name, actorsCount::doubleValue);</span><br><span class="line">        QMon.actorSystemQueueGauge(name, () -&gt; (<span class="keyword">double</span>) executor.getQueue().size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，用一个线程池处理actor的调度执行，这个线程池里的队列是一个优先级队列。优先级队列存储的元素是Actor。关于Actor我们稍后来看，先来看一下ActorSystem的处理调度流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PullMessageWorker调用的就是这个方法</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(String actorPath, E msg, Processor&lt;E&gt; processor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取得actor</span></span><br><span class="line">      Actor&lt;E&gt; actor = createOrGet(actorPath, processor);</span><br><span class="line">    <span class="comment">// 在后文Actor定义里能看到，actor内部维护一个queue，这里actor仅仅是offer(msg)</span></span><br><span class="line">      actor.dispatch(msg);</span><br><span class="line">    <span class="comment">// 执行调度</span></span><br><span class="line">      schedule(actor, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无消息时，则会挂起</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">(String actorPath)</span> </span>&#123;</span><br><span class="line">      Actor actor = actors.get(actorPath);</span><br><span class="line">      <span class="keyword">if</span> (actor == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      actor.suspend();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有消息则恢复，可以理解成线程的"就绪状态"</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">(String actorPath)</span> </span>&#123;</span><br><span class="line">      Actor actor = actors.get(actorPath);</span><br><span class="line">      <span class="keyword">if</span> (actor == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      actor.resume();</span><br><span class="line">    <span class="comment">// 立即调度，可以留意一下那个false</span></span><br><span class="line">    <span class="comment">// 当actor是"可调度状态"时，这个actor是否能调度是取决于actor的queue是否有消息</span></span><br><span class="line">      schedule(actor, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> &lt;E&gt; <span class="function">Actor&lt;E&gt; <span class="title">createOrGet</span><span class="params">(String actorPath, Processor&lt;E&gt; processor)</span> </span>&#123;</span><br><span class="line">      Actor&lt;E&gt; actor = actors.get(actorPath);</span><br><span class="line">      <span class="keyword">if</span> (actor != <span class="keyword">null</span>) <span class="keyword">return</span> actor;</span><br><span class="line"></span><br><span class="line">      Actor&lt;E&gt; add = <span class="keyword">new</span> Actor&lt;&gt;(<span class="keyword">this</span>.name, actorPath, <span class="keyword">this</span>, processor, DEFAULT_QUEUE_SIZE);</span><br><span class="line">      Actor&lt;E&gt; old = actors.putIfAbsent(actorPath, add);</span><br><span class="line">      <span class="keyword">if</span> (old == <span class="keyword">null</span>) &#123;</span><br><span class="line">          LOG.info(<span class="string">"create actorSystem: &#123;&#125;"</span>, actorPath);</span><br><span class="line">          actorsCount.incrementAndGet();</span><br><span class="line">          <span class="keyword">return</span> add;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> old;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将actor入队的地方</span></span><br><span class="line">  <span class="keyword">private</span> &lt;E&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">schedule</span><span class="params">(Actor&lt;E&gt; actor, <span class="keyword">boolean</span> hasMessageHint)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果actor不能调度，则ret false</span></span><br><span class="line">      <span class="keyword">if</span> (!actor.canBeSchedule(hasMessageHint)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 设置actor为"可调度状态"</span></span><br><span class="line">      <span class="keyword">if</span> (actor.setAsScheduled()) &#123;</span><br><span class="line">        <span class="comment">// 提交时间，和actor执行总耗时共同决定在队列里的优先级</span></span><br><span class="line">          actor.submitTs = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 入队，入的是线程池里的优先级队列</span></span><br><span class="line">          <span class="keyword">this</span>.executor.execute(actor);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// actor.setAsScheduled()里，这里是actor已经是可调度状态，那么没必要再次入队</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>actorSystem维护一个线程池，线程池队列具有优先级，队列存储元素是actor。actor的粒度是subject+group。Actor是一个Runnable，且因为是优先级队列的存储元素所以需继承Comparable接口（队列并没有传<em>Comparator参数</em>），并且actor有四种状态，初始状态、可调度状态、挂起状态、调度状态（这个状态其实不存在，但是暂且这么叫以帮助理解）。<br>接下来看看Actor这个类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Actor</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Comparable</span>&lt;<span class="title">Actor</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 初始状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Open = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 可调度状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Scheduled = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 掩码，二进制表示:11 与Open和Scheduled作&amp;运算 </span></span><br><span class="line">  <span class="comment">// shouldScheduleMask&amp;currentStatus != Open 则为不可置为调度状态（当currentStatus为挂起状态或调度状态）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> shouldScheduleMask = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> shouldNotProcessMask = ~<span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 挂起状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> suspendUnit = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//每个actor至少执行的时间片</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUOTA = <span class="number">5</span>;</span><br><span class="line">  <span class="comment">// status属性内存偏移量，用Unsafe操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> statusOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            statusOffset = Unsafe.instance.objectFieldOffset(Actor.class.getDeclaredField(<span class="string">"status"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String systemName;</span><br><span class="line">    <span class="keyword">final</span> ActorSystem actorSystem;</span><br><span class="line">  <span class="comment">// actor内部维护的queue，后文简单分析下</span></span><br><span class="line">    <span class="keyword">final</span> BoundedNodeQueue&lt;E&gt; queue;</span><br><span class="line">  <span class="comment">// ActorSystem内部定义接口，PullMessageWorker实现的就是这个接口，用于真正业务逻辑处理的地方</span></span><br><span class="line">    <span class="keyword">final</span> Processor&lt;E&gt; processor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="comment">// 一个actor执行总耗时</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> total;</span><br><span class="line">  <span class="comment">// actor执行提交时间，即actor入队时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> submitTs;</span><br><span class="line">    <span class="comment">//通过Unsafe操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    Actor(String systemName, String name, ActorSystem actorSystem, Processor&lt;E&gt; processor, <span class="keyword">final</span> <span class="keyword">int</span> queueSize) &#123;</span><br><span class="line">        <span class="keyword">this</span>.systemName = systemName;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.actorSystem = actorSystem;</span><br><span class="line">        <span class="keyword">this</span>.processor = processor;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> BoundedNodeQueue&lt;&gt;(queueSize);</span><br><span class="line"></span><br><span class="line">        QMon.actorQueueGauge(systemName, name, () -&gt; (<span class="keyword">double</span>) queue.count());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队，是actor内部的队列</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dispatch</span><span class="params">(E message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.add(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// actor执行的地方</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        String old = Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().setName(systemName + <span class="string">"-"</span> + name);</span><br><span class="line">            <span class="keyword">if</span> (shouldProcessMessage()) &#123;</span><br><span class="line">                processMessages();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> duration = System.currentTimeMillis() - start;</span><br><span class="line">          <span class="comment">// 每次actor执行的耗时累加到total</span></span><br><span class="line">            total += duration;</span><br><span class="line">            QMon.actorProcessTime(name, duration);</span><br><span class="line"></span><br><span class="line">            Thread.currentThread().setName(old);</span><br><span class="line">          <span class="comment">// 设置为"空闲状态"，即初始状态 (currentStatus &amp; ~Scheduled)</span></span><br><span class="line">            setAsIdle();</span><br><span class="line">          <span class="comment">// 进行下一次调度</span></span><br><span class="line">            <span class="keyword">this</span>.actorSystem.schedule(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> deadline = System.currentTimeMillis() + QUOTA;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            E message = queue.peek();</span><br><span class="line">            <span class="keyword">if</span> (message == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">          <span class="comment">// 处理业务逻辑</span></span><br><span class="line">            <span class="keyword">boolean</span> process = processor.process(message, <span class="keyword">this</span>);</span><br><span class="line">          <span class="comment">// 失败，该message不会出队，等待下一次调度</span></span><br><span class="line">          <span class="comment">// 如pullMessageWorker中没有消息时将actor挂起</span></span><br><span class="line">            <span class="keyword">if</span> (!process) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 出队</span></span><br><span class="line">            queue.pollNode();</span><br><span class="line">          <span class="comment">// 每个actor只有QUOTA个时间片的执行时间</span></span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= deadline) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">shouldProcessMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 能够真正执行业务逻辑的判断</span></span><br><span class="line">      <span class="comment">// 一种场景是，针对挂起状态，由于没有拉取到消息该actor置为挂起状态</span></span><br><span class="line">      <span class="comment">// 自然就没有抢占时间片的必要了</span></span><br><span class="line">        <span class="keyword">return</span> (currentStatus() &amp; shouldNotProcessMask) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 能否调度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canBeSchedule</span><span class="params">(<span class="keyword">boolean</span> hasMessageHint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = currentStatus();</span><br><span class="line">        <span class="keyword">if</span> (s == Open || s == Scheduled) <span class="keyword">return</span> hasMessageHint || !queue.isEmpty();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = currentStatus();</span><br><span class="line">            <span class="keyword">int</span> next = s &lt; suspendUnit ? s : s - suspendUnit;</span><br><span class="line">            <span class="keyword">if</span> (updateStatus(s, next)) <span class="keyword">return</span> next &lt; suspendUnit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = currentStatus();</span><br><span class="line">            <span class="keyword">if</span> (updateStatus(s, s + suspendUnit)) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">setAsScheduled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = currentStatus();</span><br><span class="line">          <span class="comment">// currentStatus为非Open状态，则ret false</span></span><br><span class="line">            <span class="keyword">if</span> ((s &amp; shouldScheduleMask) != Open) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">// 更新actor状态为调度状态</span></span><br><span class="line">            <span class="keyword">if</span> (updateStatus(s, s | Scheduled)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAsIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = currentStatus();</span><br><span class="line">          <span class="comment">// 更新actor状态位不可调度状态，(这里可以理解为更新为初始状态Open)</span></span><br><span class="line">            <span class="keyword">if</span> (updateStatus(s, s &amp; ~Scheduled)) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">currentStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 根据status在内存中的偏移量取得status</span></span><br><span class="line">        <span class="keyword">return</span> Unsafe.instance.getIntVolatile(<span class="keyword">this</span>, statusOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateStatus</span><span class="params">(<span class="keyword">int</span> oldStatus, <span class="keyword">int</span> newStatus)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Unsafe 原子操作，处理status的轮转变更</span></span><br><span class="line">        <span class="keyword">return</span> Unsafe.instance.compareAndSwapInt(<span class="keyword">this</span>, statusOffset, oldStatus, newStatus);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 决定actor在优先级队列里的优先级的地方</span></span><br><span class="line">  <span class="comment">// 先看总耗时，以达到动态限速，保证执行"慢"的请求（已经堆积的消息拉取请求）在后执行</span></span><br><span class="line">  <span class="comment">// 其次看提交时间，先提交的actor先执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Actor o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = Long.compare(total, o.total);</span><br><span class="line">        <span class="keyword">return</span> result == <span class="number">0</span> ? Long.compare(submitTs, o.submitTs) : result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Actor&lt;?&gt; actor = (Actor&lt;?&gt;) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(systemName, actor.systemName) &amp;&amp;</span><br><span class="line">                Objects.equals(name, actor.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(systemName, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Actor实现了Comparable，在优先级队列里优先级是Actor里的total和submitTs共同决定的。total是actor执行总耗时，submitTs是调度时间。那么对于处理较慢的actor自然就会在队列里相对”尾部”位置，这时就做到了根据actor的执行耗时的一个动态限速。Actor利用Unsafe机制来控制各个状态的轮转原子性更新的，且每个actor执行时间可以简单理解为5个时间片（暂且这么理解，其实并不是时间片）。<br>其实工作进行到这里就可以结束了，但是抱着对于编程的热爱（周末闲的慌），还可以往下接着看看。<br>Actor内部维护一个Queue，这个Queue是自定义的，是一个<em>Lock-free bounded non-blocking multiple-producer single-consumer queue。JDK里的QUEUE多数都是用锁控制，不用锁，猜测也应该是用Unsafe 原子操作实现。那么来看看吧：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedNodeQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头结点、尾节点在内存中的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> enqOffset, deqOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            enqOffset = Unsafe.instance.objectFieldOffset(BoundedNodeQueue.class.getDeclaredField(<span class="string">"_enqDoNotCallMeDirectly"</span>));</span><br><span class="line">            deqOffset = Unsafe.instance.objectFieldOffset(BoundedNodeQueue.class.getDeclaredField(<span class="string">"_deqDoNotCallMeDirectly"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">// 尾节点，通过enqOffset操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Node&lt;T&gt; _enqDoNotCallMeDirectly;</span><br><span class="line">    <span class="comment">// 头结点，通过deqOffset操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Node&lt;T&gt; _deqDoNotCallMeDirectly;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">BoundedNodeQueue</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"AbstractBoundedNodeQueue.capacity must be &gt;= 0"</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;T&gt; n = <span class="keyword">new</span> Node&lt;T&gt;();</span><br><span class="line">        setDeq(n);</span><br><span class="line">        setEnq(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取尾节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node&lt;T&gt; <span class="title">getEnq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// getObjectVolatile这种方式保证拿到的都是最新数据</span></span><br><span class="line">        <span class="keyword">return</span> (Node&lt;T&gt;) Unsafe.instance.getObjectVolatile(<span class="keyword">this</span>, enqOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置尾节点，仅在初始化时用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setEnq</span><span class="params">(Node&lt;T&gt; n)</span> </span>&#123;</span><br><span class="line">        Unsafe.instance.putObjectVolatile(<span class="keyword">this</span>, enqOffset, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casEnq</span><span class="params">(Node&lt;T&gt; old, Node&lt;T&gt; nju)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cas，循环设置，直到成功</span></span><br><span class="line">        <span class="keyword">return</span> Unsafe.instance.compareAndSwapObject(<span class="keyword">this</span>, enqOffset, old, nju);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取头结点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node&lt;T&gt; <span class="title">getDeq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Node&lt;T&gt;) Unsafe.instance.getObjectVolatile(<span class="keyword">this</span>, deqOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅在初始化时用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setDeq</span><span class="params">(Node&lt;T&gt; n)</span> </span>&#123;</span><br><span class="line">        Unsafe.instance.putObjectVolatile(<span class="keyword">this</span>, deqOffset, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cas设置头结点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casDeq</span><span class="params">(Node&lt;T&gt; old, Node&lt;T&gt; nju)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Unsafe.instance.compareAndSwapObject(<span class="keyword">this</span>, deqOffset, old, nju);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与其叫count，不如唤作index，但是是否应该考虑溢出的情况？</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;T&gt; lastNode = getEnq();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> lastNodeCount = lastNode.count;</span><br><span class="line">        <span class="keyword">return</span> lastNodeCount - getDeq().count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the maximum capacity of this queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;T&gt; n = <span class="keyword">null</span>; ; ) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node&lt;T&gt; lastNode = getEnq();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> lastNodeCount = lastNode.count;</span><br><span class="line">            <span class="keyword">if</span> (lastNodeCount - getDeq().count &lt; capacity) &#123;</span><br><span class="line">                <span class="comment">// Trade a branch for avoiding to create a new node if full,</span></span><br><span class="line">                <span class="comment">// and to avoid creating multiple nodes on write conflict á la Be Kind to Your GC</span></span><br><span class="line">                <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    n = <span class="keyword">new</span> Node&lt;T&gt;();</span><br><span class="line">                    n.value = value;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                n.count = lastNodeCount + <span class="number">1</span>; <span class="comment">// Piggyback on the HB-edge between getEnq() and casEnq()</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Try to putPullLogs the node to the end, if we fail we continue loopin'</span></span><br><span class="line">                <span class="comment">// 相当于 </span></span><br><span class="line">              <span class="comment">// enq -&gt; next = new Node(value); enq = neq -&gt; next;</span></span><br><span class="line">                <span class="keyword">if</span> (casEnq(lastNode, n)) &#123;</span><br><span class="line">                  <span class="comment">// 注意一下这个Node.setNext方法</span></span><br><span class="line">                    lastNode.setNext(n);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// Over capacity—couldn't add the node</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// enq == deq 即为empty</span></span><br><span class="line">        <span class="keyword">return</span> getEnq() == getDeq();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the first element of this queue if any</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value of the first element of the queue, null if empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;T&gt; n = pollNode();</span><br><span class="line">        <span class="keyword">return</span> (n != <span class="keyword">null</span>) ? n.value : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt; n = peekNode();</span><br><span class="line">        <span class="keyword">return</span> (n != <span class="keyword">null</span>) ? n.value : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Node&lt;T&gt; <span class="title">peekNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node&lt;T&gt; deq = getDeq();</span><br><span class="line">            <span class="keyword">final</span> Node&lt;T&gt; next = deq.next();</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> || getEnq() == deq)</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the first element of this queue if any</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the `Node` of the first element of the queue, null if empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Node&lt;T&gt; <span class="title">pollNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node&lt;T&gt; deq = getDeq();</span><br><span class="line">            <span class="keyword">final</span> Node&lt;T&gt; next = deq.next();</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (casDeq(deq, next)) &#123;</span><br><span class="line">                    deq.value = next.value;</span><br><span class="line">                    deq.setNext(<span class="keyword">null</span>);</span><br><span class="line">                    next.value = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">return</span> deq;</span><br><span class="line">                &#125; <span class="comment">// else we retry (concurrent consumers)</span></span><br><span class="line">              <span class="comment">// 比较套路的cas操作，就不多说了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getEnq() == deq) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// If we got a null and head meets tail, we are empty</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                nextOffset = Unsafe.instance.objectFieldOffset(Node.class.getDeclaredField(<span class="string">"_nextDoNotCallMeDirectly"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> T value;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br><span class="line">        <span class="comment">// 也是利用偏移量操作</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Node&lt;T&gt; _nextDoNotCallMeDirectly;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Node&lt;T&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (Node&lt;T&gt;) Unsafe.instance.getObjectVolatile(<span class="keyword">this</span>, nextOffset);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(<span class="keyword">final</span> Node&lt;T&gt; newNext)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 这里有点讲究，下面分析下</span></span><br><span class="line">            Unsafe.instance.putOrderedObject(<span class="keyword">this</span>, nextOffset, newNext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，是通过属性在内存的偏移量，结合cas原子操作来进行更新赋值等操作，以此来实现lock-free，这是比较常规的套路。值得一说的是Node里的setNext方法，这个方法的调用是在cas节点后，对”上一位置”的next节点进行赋值。而这个方法使用的是Unsafe.instance.putOrderedObject，要说这个putOrderedObject，就不得不说MESI，缓存一致性协议。如volatile，当进行写操作时，它是依靠storeload barrier来实现其他线程对此的可见性。而putOrderedObject也是依靠内存屏障，只不过是storestore barrier。storestore是比storeload快速的一种内存屏障。在硬件层面，内存屏障分两种：Load-Barrier和Store-Barrier。Load-Barrier是让高速缓存中的数据失效，强制重新从主内存加载数据；Store-Barrier是让写入高速缓存的数据更新写入主内存，对其他线程可见。而java层面的四种内存屏障无非是硬件层面的两种内存屏障的组合而已。那么可见，storestore barrier自然比storeload barrier快速。那么有一个问题，我们可不可以在这里也用cas操作呢？答案是可以，但没必要。你可以想想这里为什么没必要。<br>谢谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;df368884&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;QMQ有关actor的一篇&lt;span
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="MQ" scheme="https://blog.dengxf.cn/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>QMQ源码分析之发送消息</title>
    <link href="https://blog.dengxf.cn/f0aaa51f.html"/>
    <id>https://blog.dengxf.cn/f0aaa51f.html</id>
    <published>2019-03-16T21:25:53.000Z</published>
    <updated>2019-05-05T07:11:07.927Z</updated>
    
    <content type="html"><![CDATA[<p><a name="df368884"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>QMQ发送消息部分的源码从两端来分析，即client端和broker端。</p></blockquote><p><a name="client"></a></p><h1 id="client"><a href="#client" class="headerlink" title="client"></a>client</h1><p>从官方的producer<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1bmFyY29ycC9xbXEvYmxvYi9tYXN0ZXIvZG9jcy9jbi9wcm9kdWNlci5tZA==" title="https://github.com/qunarcorp/qmq/blob/master/docs/cn/producer.md">文档<i class="fa fa-external-link"></i></span>能很容易的找到入口就是<code>MessageProducerProvider</code>这个类。通过这个文档，能发现这个类有两个属性是需要我们设置的，即appCode、metaServer。这里的appCode用来标识应用，metaServer是meta server地址，在发送消息时，可以通过这个地址获取broker cluser。从入口<code>MessageProducerProvider</code>看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 生产消息</span><br><span class="line">  @Override</span><br><span class="line">  public Message generateMessage(String subject) &#123;</span><br><span class="line">      BaseMessage msg = new BaseMessage(idGenerator.getNext(), subject);</span><br><span class="line">      msg.setExpiredDelay(configs.getMinExpiredTime(), TimeUnit.MINUTES);</span><br><span class="line">      msg.setProperty(BaseMessage.keys.qmq_appCode, appCode);</span><br><span class="line">      return msg;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从以上初始化一条消息的代码能看到，QMQ自身会设置一个过期时间，一个appCode的属性。而这里我最关心的是，它的id的是怎么组织的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimestampAndHostIdGenerator</span> <span class="keyword">implements</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] codex = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">18</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger messageOrder = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String localAddress = NetworkUtils.getLocalAddress();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在生成message id的时候带上进程id，避免一台机器上部署多个服务都发同样的消息时出问题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PID = PidUtil.getPid();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">40</span>);</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">        String ts = <span class="keyword">new</span> Timestamp(time).toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx : codex)</span><br><span class="line">        <span class="comment">// 处理时间</span></span><br><span class="line">            sb.append(ts.charAt(idx));</span><br><span class="line">        <span class="comment">// 本机地址</span></span><br><span class="line">        sb.append(<span class="string">'.'</span>).append(localAddress);</span><br><span class="line">        <span class="comment">// pid</span></span><br><span class="line">        sb.append(<span class="string">'.'</span>).append(PID);</span><br><span class="line">        sb.append(<span class="string">'.'</span>).append(messageOrder.getAndIncrement()); <span class="comment">//可能为负数.但是无所谓.</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QMQ的msgId是以时间+ip+pid+seq组织的。消息初始化了，那么就是发送了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Message message, MessageSendStateListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!STARTED.get()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"MessageProducerProvider未初始化，如果使用非Spring的方式请确认init()是否调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// trace信息</span></span><br><span class="line">    <span class="keyword">try</span> (Scope ignored = tracer.buildSpan(<span class="string">"Qmq.Produce.Send"</span>)</span><br><span class="line">            .withTag(<span class="string">"appCode"</span>, appCode)</span><br><span class="line">            .withTag(<span class="string">"subject"</span>, message.getSubject())</span><br><span class="line">            .withTag(<span class="string">"messageId"</span>, message.getMessageId())</span><br><span class="line">            .startActive(<span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (messageTracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">            message.setDurable(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 消息被包装在ProduceMessageImpl里</span></span><br><span class="line">        ProduceMessageImpl pm = initProduceMessage(message, listener);</span><br><span class="line">      <span class="comment">// 非持久消息那么直接发送</span></span><br><span class="line">        <span class="keyword">if</span> (!message.isDurable()) &#123;</span><br><span class="line">            pm.send();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 事务消息</span></span><br><span class="line">        <span class="keyword">if</span> (!messageTracker.trackInTransaction(pm)) &#123;</span><br><span class="line">          <span class="comment">// false则直接发送</span></span><br><span class="line">            pm.send();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QMQ是支持事务消息的，先来看下事务消息，trackInTransaction这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">trackInTransaction</span><span class="params">(ProduceMessage message)</span> </span>&#123;</span><br><span class="line">        MessageStore messageStore = <span class="keyword">this</span>.transactionProvider.messageStore();</span><br><span class="line">        message.setStore(messageStore);</span><br><span class="line">      <span class="comment">// 处在事务中</span></span><br><span class="line">        <span class="keyword">if</span> (transactionProvider.isInTransaction()) &#123;</span><br><span class="line">          <span class="comment">// 开始事务</span></span><br><span class="line">            <span class="keyword">this</span>.transactionListener.beginTransaction(messageStore);</span><br><span class="line">            <span class="keyword">this</span>.transactionProvider.setTransactionListener(transactionListener);</span><br><span class="line">            messageStore.beginTransaction();</span><br><span class="line">            <span class="keyword">this</span>.transactionListener.addMessage(message);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                message.save();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                message.getBase().setStoreAtFailed(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// transactionProvider isInTransaction</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TransactionSynchronizationManager.isActualTransactionActive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// transactionListener beginTransaction</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">(MessageStore store)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 此处的holder申明为 </span></span><br><span class="line">    <span class="comment">// private ThreadLocal&lt;TransactionMessageHolder&gt; holder = new ThreadLocal&lt;&gt;();</span></span><br><span class="line">        TransactionMessageHolder current = holder.get();</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">            holder.set(<span class="keyword">new</span> TransactionMessageHolder(store));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TransactionMessageHolder</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransactionMessageHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertMessage</span><span class="params">(ProduceMessage message)</span> </span>&#123;</span><br><span class="line">        add(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;ProduceMessage&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageStore store;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ProduceMessage&gt; queue = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    TransactionMessageHolder(MessageStore store) &#123;</span><br><span class="line">        <span class="keyword">this</span>.store = store;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(ProduceMessage message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty())</span><br><span class="line">            queue = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        queue.add(message);</span><br><span class="line">        message.setStore(store);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QMQ的事务消息是利用与业务DB共享连接，所以能够将QMQ事务和业务事务相绑定。当发送QMQ消息时，要是业务逻辑正在一个事务中，那么QMQ会将消息暂存到ThreadLocal中，当业务事务提交时，再将消息从ThreadLocal中取出，进行发送逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;ProduceMessage&gt; list = remove();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); ++i) &#123;</span><br><span class="line">        ProduceMessage msg = list.get(i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.send();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.error(<span class="string">"消息发送失败&#123;&#125;"</span>, msg.getMessageId(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;ProduceMessage&gt; list = remove();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); ++i) &#123;</span><br><span class="line">        ProduceMessage msg = list.get(i);</span><br><span class="line">        logger.info(<span class="string">"事务提交失败, 消息(&#123;&#125;)被忽略.subject:&#123;&#125;"</span>, msg.getMessageId(), msg.getSubject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QMQ的事务消息的大概流程就是这样，接着来看一下具体发送的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (state.compareAndSet(INIT, QUEUED)) &#123;</span><br><span class="line">            tries.incrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (sendSync()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> (Scope scope = tracer.buildSpan(<span class="string">"Qmq.QueueSender.Send"</span>).startActive(<span class="keyword">false</span>)) &#123;</span><br><span class="line">                traceSpan = scope.span();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sender.offer(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                    LOGGER.info(<span class="string">"进入发送队列 &#123;&#125;:&#123;&#125;"</span>, getSubject(), getMessageId());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (store != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    enterQueueFail.inc();</span><br><span class="line">                    LOGGER.info(<span class="string">"内存发送队列已满! 此消息将暂时丢弃,等待补偿服务处理 &#123;&#125;:&#123;&#125;"</span>, getSubject(), getMessageId());</span><br><span class="line">                    failed();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    LOGGER.info(<span class="string">"内存发送队列已满! 此消息在用户进程阻塞,等待队列激活 &#123;&#125;:&#123;&#125;"</span>, getSubject(), getMessageId());</span><br><span class="line">                    <span class="keyword">if</span> (sender.offer(<span class="keyword">this</span>, <span class="number">50</span>)) &#123;</span><br><span class="line">                        LOGGER.info(<span class="string">"进入发送队列 &#123;&#125;:&#123;&#125;"</span>, getSubject(), getMessageId());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        enterQueueFail.inc();</span><br><span class="line">                        LOGGER.info(<span class="string">"由于无法入队,发送失败！取消发送 &#123;&#125;:&#123;&#125;"</span>, getSubject(), getMessageId());</span><br><span class="line">                        onFailed();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            enterQueueFail.inc();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"同一条消息不能被入队两次."</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>发送QMQ消息时，会将消息入队，发送时会批量发送。而消息要是失败，同时消息也是事务消息，那么会有补偿任务来补发消息。QMQ用相对简单的方式解决了分布式事务消息问题，还是比较巧妙的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, MessageException&gt; <span class="title">send</span><span class="params">(List&lt;ProduceMessage&gt; messages)</span> <span class="keyword">throws</span> ClientSendException, RemoteException, BrokerRejectException </span>&#123;</span><br><span class="line">    sendMessageCountMetrics.inc(messages.size());</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 异步获取broker cluser</span></span><br><span class="line">        BrokerClusterInfo cluster = brokerService.getClusterBySubject(clientType, subject);</span><br><span class="line">        <span class="comment">// 负载均衡，random</span></span><br><span class="line">        BrokerGroupInfo target = brokerLoadBalance.loadBalance(cluster, lastSentBroker);</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClientSendException(ClientSendException.SendErrorCode.CREATE_CHANNEL_FAIL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastSentBroker = target;</span><br><span class="line">        <span class="comment">// 这里会有失败熔断等处理</span></span><br><span class="line">        Datagram response = doSend(target, messages);</span><br><span class="line">        RemotingHeader responseHeader = response.getHeader();</span><br><span class="line">        <span class="keyword">int</span> code = responseHeader.getCode();</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            <span class="keyword">case</span> CommandCode.SUCCESS:</span><br><span class="line">                <span class="keyword">return</span> process(target, response);</span><br><span class="line">            <span class="keyword">case</span> CommandCode.BROKER_REJECT:</span><br><span class="line">                handleSendReject(target);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokerRejectException(<span class="string">""</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sendMessageTimerMetrics.update(System.currentTimeMillis() - start, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送消息的client部分就先说到这里。<br><a name="broker"></a></p><h1 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h1><p>broker接收到消息之后，会将消息append到message_log中，这里是顺序写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public CompletableFuture&lt;Datagram&gt; processRequest(ChannelHandlerContext ctx, RemotingCommand command) &#123;</span><br><span class="line">    List&lt;RawMessage&gt; messages;</span><br><span class="line">    try &#123;</span><br><span class="line">    // 反序列化，但并不是反序列化整个消息体，payload</span><br><span class="line">        messages = deserializeRawMessages(command);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        LOG.error(&quot;received invalid message. channel: &#123;&#125;&quot;, ctx.channel(), e);</span><br><span class="line">        QMon.brokerReceivedInvalidMessageCountInc();</span><br><span class="line"></span><br><span class="line">        final Datagram response = RemotingBuilder.buildEmptyResponseDatagram(CommandCode.BROKER_ERROR, command.getHeader());</span><br><span class="line">        return CompletableFuture.completedFuture(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BrokerStats.getInstance().getLastMinuteSendRequestCount().add(messages.size());</span><br><span class="line"></span><br><span class="line">    final ListenableFuture&lt;Datagram&gt; result = sendMessageWorker.receive(messages, command);</span><br><span class="line">    final CompletableFuture&lt;Datagram&gt; future = new CompletableFuture&lt;&gt;();</span><br><span class="line">    // Future 回调</span><br><span class="line">    Futures.addCallback(result, new FutureCallback&lt;Datagram&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onSuccess(Datagram datagram) &#123;</span><br><span class="line">                    future.complete(datagram);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onFailure(Throwable ex) &#123;</span><br><span class="line">                    future.completeExceptionally(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">    return future;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// sendMessageWorker receive</span><br><span class="line">ListenableFuture&lt;Datagram&gt; receive(final List&lt;RawMessage&gt; messages, final RemotingCommand cmd) &#123;</span><br><span class="line">    final List&lt;SettableFuture&lt;ReceiveResult&gt;&gt; futures = new ArrayList&lt;&gt;(messages.size());</span><br><span class="line">    for (final RawMessage message : messages) &#123;</span><br><span class="line">        final MessageHeader header = message.getHeader();</span><br><span class="line">        monitorMessageReceived(header.getCreateTime(), header.getSubject());</span><br><span class="line"></span><br><span class="line">        final ReceivingMessage receivingMessage = new ReceivingMessage(message, cmd.getReceiveTime());</span><br><span class="line">        // 这种异步的处理方式，在QMQ中很多，很多开源产品基本也都是这样做的</span><br><span class="line">        futures.add(receivingMessage.promise());</span><br><span class="line">        invoker.invoke(receivingMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return Futures.transform(Futures.allAsList(futures),</span><br><span class="line">            (Function&lt;? super List&lt;ReceiveResult&gt;, ? extends Datagram&gt;) input -&gt; RemotingBuilder.buildResponseDatagram(CommandCode.SUCCESS, cmd.getHeader(), new SendResultPayloadHolder(input)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// invoke</span><br><span class="line">private void doInvoke(ReceivingMessage message) &#123;</span><br><span class="line">// 设置broker为readOnly，在发布的时候时候，等跌0，这种设置是很有必要的</span><br><span class="line">    if (BrokerConfig.isReadonly()) &#123;</span><br><span class="line">        brokerReadOnly(message);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 当主从同步差异较大时，将broker设置为readOnly</span><br><span class="line">    if (bigSlaveLag()) &#123;</span><br><span class="line">        brokerReadOnly(message);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final String subject = message.getSubject();</span><br><span class="line">    // 非法subject</span><br><span class="line">    if (isIllegalSubject(subject)) &#123;</span><br><span class="line">    // 可以配置某个subject直接reject</span><br><span class="line">        if (isRejectIllegalSubject()) &#123;</span><br><span class="line">            notAllowed(message);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">    // 就是append message_log</span><br><span class="line">        ReceiveResult result = messageStore.putMessage(message);</span><br><span class="line">        // 在这里可以设置当从也同步这条消息完成才认为这条消息发送成功</span><br><span class="line">        offer(message, result);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        error(message, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要节点我都注释上了，接下来看一下message_log：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">public PutMessageResult putMessage(final RawMessage message) &#123;</span><br><span class="line">        final AppendMessageResult&lt;MessageSequence&gt; result;</span><br><span class="line">        LogSegment segment = logManager.latestSegment();</span><br><span class="line">        if (segment == null) &#123;</span><br><span class="line">            segment = logManager.allocNextSegment();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (segment == null) &#123;</span><br><span class="line">            return new PutMessageResult(PutMessageStatus.CREATE_MAPPED_FILE_FAILED, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">// 主要在messageAppender这里，也可以从这个appender中看下message_log消息格式</span><br><span class="line">        result = segment.append(message, messageAppender);</span><br><span class="line">        switch (result.getStatus()) &#123;</span><br><span class="line">            case SUCCESS:</span><br><span class="line">                break;</span><br><span class="line">            case END_OF_FILE:</span><br><span class="line">            // 一个segmengt固定大小，这里是到达一个segment末尾，需要新建</span><br><span class="line">                LogSegment logSegment = logManager.allocNextSegment();</span><br><span class="line">                if (logSegment == null) &#123;</span><br><span class="line">                    return new PutMessageResult(PutMessageStatus.CREATE_MAPPED_FILE_FAILED, null);</span><br><span class="line">                &#125;</span><br><span class="line">                return putMessage(message);</span><br><span class="line">            case MESSAGE_SIZE_EXCEEDED:</span><br><span class="line">                return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result);</span><br><span class="line">            default:</span><br><span class="line">                return new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new PutMessageResult(PutMessageStatus.SUCCESS, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// message apender声明</span><br><span class="line">private class RawMessageAppender implements MessageAppender&lt;RawMessage, MessageSequence&gt; &#123;</span><br><span class="line">        private static final int MAX_BYTES = 1024;</span><br><span class="line"></span><br><span class="line">        private static final byte ATTR_EMPTY_RECORD = 1;</span><br><span class="line">        private static final byte ATTR_MESSAGE_RECORD = 0;</span><br><span class="line"></span><br><span class="line">        private final ByteBuffer workingBuffer = ByteBuffer.allocate(MAX_BYTES);</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public AppendMessageResult&lt;MessageSequence&gt; doAppend(long baseOffset, ByteBuffer targetBuffer, int freeSpace, RawMessage message) &#123;</span><br><span class="line">            workingBuffer.clear();</span><br><span class="line"></span><br><span class="line">            final String subject = message.getHeader().getSubject();</span><br><span class="line">            final byte[] subjectBytes = subject.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">            final long wroteOffset = baseOffset + targetBuffer.position();</span><br><span class="line">            final int recordSize = recordSize(subjectBytes.length, message.getBodySize());</span><br><span class="line"></span><br><span class="line">// 到达segment末尾，末尾填充</span><br><span class="line">            if (recordSize != freeSpace &amp;&amp; recordSize + MIN_RECORD_BYTES &gt; freeSpace) &#123;</span><br><span class="line">                workingBuffer.limit(MIN_RECORD_BYTES);</span><br><span class="line">                workingBuffer.putInt(MagicCode.MESSAGE_LOG_MAGIC_V3);</span><br><span class="line">                // empty消息attribute标识</span><br><span class="line">                workingBuffer.put(ATTR_EMPTY_RECORD);</span><br><span class="line">                workingBuffer.putLong(System.currentTimeMillis());</span><br><span class="line">                targetBuffer.put(workingBuffer.array(), 0, MIN_RECORD_BYTES);</span><br><span class="line">                int fillZeroLen = freeSpace - MIN_RECORD_BYTES;</span><br><span class="line">                if (fillZeroLen &gt; 0) &#123;</span><br><span class="line">                    targetBuffer.put(fillZero(fillZeroLen));</span><br><span class="line">                &#125;</span><br><span class="line">                return new AppendMessageResult&lt;&gt;(AppendMessageStatus.END_OF_FILE, wroteOffset, freeSpace, null);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            // 一条消息都会有一个逻辑sequence</span><br><span class="line">                final long sequence = consumerLogManager.getOffsetOrDefault(subject, 0);</span><br><span class="line"></span><br><span class="line">                int headerSize = recordSize - message.getBodySize();</span><br><span class="line">                workingBuffer.limit(headerSize);</span><br><span class="line">                // QMQ采用crc校验</span><br><span class="line">                workingBuffer.putInt(MagicCode.MESSAGE_LOG_MAGIC_V3);</span><br><span class="line">                // 正常消息attribute标识</span><br><span class="line">                workingBuffer.put(ATTR_MESSAGE_RECORD);</span><br><span class="line">                workingBuffer.putLong(System.currentTimeMillis());</span><br><span class="line">                workingBuffer.putLong(sequence);</span><br><span class="line">                workingBuffer.putShort((short) subjectBytes.length);</span><br><span class="line">                workingBuffer.put(subjectBytes);</span><br><span class="line">                workingBuffer.putLong(message.getHeader().getBodyCrc());</span><br><span class="line">                workingBuffer.putInt(message.getBodySize());</span><br><span class="line">                targetBuffer.put(workingBuffer.array(), 0, headerSize);</span><br><span class="line">                // payload</span><br><span class="line">                targetBuffer.put(message.getBody().nioBuffer());</span><br><span class="line"></span><br><span class="line">                consumerLogManager.incOffset(subject);</span><br><span class="line"></span><br><span class="line">                final long payloadOffset = wroteOffset + headerSize;</span><br><span class="line">                return new AppendMessageResult&lt;&gt;(AppendMessageStatus.SUCCESS, wroteOffset, recordSize, new MessageSequence(sequence, payloadOffset));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private byte[] fillZero(int len) &#123;</span><br><span class="line">            byte[] zero = new byte[len];</span><br><span class="line">            Arrays.fill(zero, (byte) 0);</span><br><span class="line">            return zero;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>RawMessageAppender</code>中我们也能看到message_log的消息存储格式，QMQ也是采用crc校验消息完整准确性。QMQ发送消息就是以上这些。谢谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;df368884&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="MQ" scheme="https://blog.dengxf.cn/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>QMQ源码分析之delay-server篇【三】</title>
    <link href="https://blog.dengxf.cn/4c5184d3.html"/>
    <id>https://blog.dengxf.cn/4c5184d3.html</id>
    <published>2019-03-10T01:18:34.000Z</published>
    <updated>2019-05-05T07:11:07.931Z</updated>
    
    <content type="html"><![CDATA[<p><a name="df368884"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>上篇我们分析了QMQ delay-server关于存储的部分，这一篇我们会对投递的源码进行分析。</p></blockquote><p><a name="31cb9169"></a></p><h1 id="投递"><a href="#投递" class="headerlink" title="投递"></a>投递</h1><p>投递的相关内容在WheelTickManager这个类。提前加载schedule_log、wheel根据延迟时间到时进行投递等相关工作都在这里完成。而关于真正进行投递的相关类是在sender这个包里。<br><a name="wheel"></a></p><h2 id="wheel"><a href="#wheel" class="headerlink" title="wheel"></a>wheel</h2><p>wheel包里一共就三个类文件，HashWheelTimer、WheelLoadCursor、WheelTickManager，WheelTickManager就应该是wheel加载文件，wheel中的消息到时投递的管理器；WheelLoadCursor应该就是上一篇中提到的schedule_log文件加载到哪里的cursor标识；那么HashWheelTimer就是一个辅助工具类，简单理解成Java中的ScheduledExecutorService，可理解成是根据延迟消息的延迟时间进行投递的timer，所以这里不对这个工具类做更多解读，我们更关心MQ逻辑。<br>首先来看提前一定时间加载schedule_log，这里的提前一定时间是多长时间呢？这个是根据需要配置的，比如3schedule_log的刻度自定义配置为1h，提前加载时间配置为30min，那么在2019-02-10 17:30就应该加载2019021018这个schedule_log。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!isStarted()) &#123;</span><br><span class="line">          sender.init();</span><br><span class="line">          <span class="comment">// hash wheel timer,内存中的wheel</span></span><br><span class="line">          timer.start();</span><br><span class="line">          started.set(<span class="keyword">true</span>);</span><br><span class="line">          <span class="comment">// 根据dispatch log,从上次投递结束的地方恢复开始投递</span></span><br><span class="line">          recover();</span><br><span class="line">          <span class="comment">// 加载线程，用于加载schedule_log</span></span><br><span class="line">          loadScheduler.scheduleWithFixedDelay(<span class="keyword">this</span>::load, <span class="number">0</span>, config.getLoadSegmentDelayMinutes(), TimeUnit.MINUTES);</span><br><span class="line">          LOGGER.info(<span class="string">"wheel started."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>recover这个方法，会根据dispatch log中的投递记录，找到上一次最后投递的位置，在delay-server重启的时候，wheel会根据这个位置恢复投递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      LOGGER.info(<span class="string">"wheel recover..."</span>);</span><br><span class="line">    <span class="comment">// 最新的dispatch log segment</span></span><br><span class="line">      DispatchLogSegment currentDispatchedSegment = facade.latestDispatchSegment();</span><br><span class="line">      <span class="keyword">if</span> (currentDispatchedSegment == <span class="keyword">null</span>) &#123;</span><br><span class="line">          LOGGER.warn(<span class="string">"load latest dispatch segment null"</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> latestOffset = currentDispatchedSegment.getSegmentBaseOffset();</span><br><span class="line">      DispatchLogSegment lastSegment = facade.lowerDispatchSegment(latestOffset);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> != lastSegment) doRecover(lastSegment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据最新的dispatch log segment进行恢复投递</span></span><br><span class="line">      doRecover(currentDispatchedSegment);</span><br><span class="line">      LOGGER.info(<span class="string">"wheel recover done. currentOffset:&#123;&#125;"</span>, latestOffset);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRecover</span><span class="params">(DispatchLogSegment dispatchLogSegment)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> segmentBaseOffset = dispatchLogSegment.getSegmentBaseOffset();</span><br><span class="line">      ScheduleSetSegment setSegment = facade.loadScheduleLogSegment(segmentBaseOffset);</span><br><span class="line">      <span class="keyword">if</span> (setSegment == <span class="keyword">null</span>) &#123;</span><br><span class="line">          LOGGER.error(<span class="string">"load schedule index error,dispatch segment:&#123;&#125;"</span>, segmentBaseOffset);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到一个关于已投递记录的set</span></span><br><span class="line">      LongHashSet dispatchedSet = loadDispatchLog(dispatchLogSegment);</span><br><span class="line">    <span class="comment">// 根据这个set，将最新的dispatch log segment中未投递的消息add in wheel。</span></span><br><span class="line">      WheelLoadCursor.Cursor loadCursor = facade.loadUnDispatch(setSegment, dispatchedSet, <span class="keyword">this</span>::refresh);</span><br><span class="line">      <span class="keyword">int</span> baseOffset = loadCursor.getBaseOffset();</span><br><span class="line">    <span class="comment">// 记录cursor</span></span><br><span class="line">      loadingCursor.shiftCursor(baseOffset, loadCursor.getOffset());</span><br><span class="line">      loadedCursor.shiftCursor(baseOffset);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>恢复基本就是以上的这些内容，接下来看看是如何加载的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提前一定时间加载到下一 delay segment</span></span><br><span class="line">      <span class="keyword">long</span> next = System.currentTimeMillis() + config.getLoadInAdvanceTimesInMillis();</span><br><span class="line">      <span class="keyword">int</span> prepareLoadBaseOffset = resolveSegment(next);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加载到prepareLoadBaseOffset这个delay segment</span></span><br><span class="line">          loadUntil(prepareLoadBaseOffset);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">          LOGGER.debug(<span class="string">"load segment interrupted"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadUntil</span><span class="params">(<span class="keyword">int</span> until)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 当前wheel已加载到baseOffset</span></span><br><span class="line">      <span class="keyword">int</span> loadedBaseOffset = loadedCursor.baseOffset();</span><br><span class="line">    <span class="comment">// 如已加载到until，则break</span></span><br><span class="line">      <span class="comment">// have loaded</span></span><br><span class="line">      <span class="keyword">if</span> (loadedBaseOffset &gt; until) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 加载失败，则break</span></span><br><span class="line">          <span class="comment">// wait next turn when loaded error.</span></span><br><span class="line">          <span class="keyword">if</span> (!loadUntilInternal(until)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前并没有until这个delay segment，即loading cursor小于until</span></span><br><span class="line">          <span class="comment">// load successfully(no error happened) and current wheel loading cursor &lt; until</span></span><br><span class="line">          <span class="keyword">if</span> (loadingCursor.baseOffset() &lt; until) &#123;</span><br><span class="line">            <span class="comment">// 阻塞，直到thresholdTime+blockingExitTime</span></span><br><span class="line">            <span class="comment">// 即如果提前blockingExitTime还未有until这个delay segment的消息进来，则退出</span></span><br><span class="line">              <span class="keyword">long</span> thresholdTime = System.currentTimeMillis() + config.getLoadBlockingExitTimesInMillis();</span><br><span class="line">              <span class="comment">// exit in a few minutes in advance</span></span><br><span class="line">              <span class="keyword">if</span> (resolveSegment(thresholdTime) &gt;= until) &#123;</span><br><span class="line">                  loadingCursor.shiftCursor(until);</span><br><span class="line">                  loadedCursor.shiftCursor(until);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 避免cpu load过高</span></span><br><span class="line">          Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125; <span class="keyword">while</span> (loadedCursor.baseOffset() &lt; until);</span><br><span class="line"></span><br><span class="line">      LOGGER.info(<span class="string">"wheel load until &#123;&#125; &lt;= &#123;&#125;"</span>, loadedCursor.baseOffset(), until);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>根据配置的提前加载时间，内存中的wheel会提前加载schedule_log，加载是在一个while循环里，直到加载到until delay segment才退出，如果当前没有until 这个delay segment，那么会在配置的blockingExitTime时间退出该循环，而为了避免cpu load过高，这里会在每次循环间隔设置100ms sleep。这里加载为什么是在while循环里？以及为什么sleep 100ms，sleep 500ms 或者1s可不可以？以及为什么要设置个blockingExitTime呢？下面的分析之后，应该就能回答这些问题了。主要考虑两种情况，一种是当之前一直没有delay segment或者delay segment是间隔存在的，比如delay segment刻度为1h，2019031001和2019031004之间的2019031002及2019031003不存在这种之类的delay segment不存在的情况，另一种是当正在加载delay segment的时候，位于该segment的延迟消息正在被加载，这种情况是有可能丢消息的。所以这里加载是在一个循环里，以及设置了两个cursor，即loading cursor，和loaded cursor。一个表示正在加载，一个表示已经加载。此外，上面每次循环sleep 100ms，可不可以sleep 500ms  1s？答案是可以，只是消息是否能容忍500ms 或者1s的延迟。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">loadUntilInternal</span><span class="params">(<span class="keyword">int</span> until)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = resolveStartIndex();</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= until) &#123;</span><br><span class="line">            ScheduleSetSegment segment = facade.loadScheduleLogSegment(index);</span><br><span class="line">            <span class="keyword">if</span> (segment == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextIndex = facade.higherScheduleBaseOffset(index);</span><br><span class="line">                <span class="keyword">if</span> (nextIndex &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                index = nextIndex;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体加载某个segment的地方</span></span><br><span class="line">            loadSegment(segment);</span><br><span class="line">            <span class="keyword">int</span> nextIndex = facade.higherScheduleBaseOffset(index);</span><br><span class="line">            <span class="keyword">if</span> (nextIndex &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            index = nextIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        LOGGER.error(<span class="string">"wheel load segment failed,currentSegmentOffset:&#123;&#125; until:&#123;&#125;"</span>, loadedCursor.baseOffset(), until, e);</span><br><span class="line">        QMon.loadSegmentFailed();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadSegment</span><span class="params">(ScheduleSetSegment segment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> baseOffset = segment.getSegmentBaseOffset();</span><br><span class="line">        <span class="keyword">long</span> offset = segment.getWrotePosition();</span><br><span class="line">        <span class="keyword">if</span> (!loadingCursor.shiftCursor(baseOffset, offset)) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"doLoadSegment error,shift loadingCursor failed,from &#123;&#125;-&#123;&#125; to &#123;&#125;-&#123;&#125;"</span>, loadingCursor.baseOffset(), loadingCursor.offset(), baseOffset, offset);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WheelLoadCursor.Cursor loadedCursorEntry = loadedCursor.cursor();</span><br><span class="line">        <span class="comment">// have loaded</span></span><br><span class="line">        <span class="comment">// 已经加载</span></span><br><span class="line">        <span class="keyword">if</span> (baseOffset &lt; loadedCursorEntry.getBaseOffset()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startOffset = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// last load action happened error</span></span><br><span class="line">        <span class="comment">// 如果上次加载失败，则从上一次的位置恢复加载</span></span><br><span class="line">        <span class="keyword">if</span> (baseOffset == loadedCursorEntry.getBaseOffset() &amp;&amp; loadedCursorEntry.getOffset() &gt; -<span class="number">1</span>)</span><br><span class="line">            startOffset = loadedCursorEntry.getOffset();</span><br><span class="line"></span><br><span class="line">        LogVisitor&lt;ScheduleIndex&gt; visitor = segment.newVisitor(startOffset, config.getSingleMessageLimitSize());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loadedCursor.shiftCursor(baseOffset, startOffset);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> currentOffset = startOffset;</span><br><span class="line">            <span class="comment">// 考虑一种情况，当前delay segment正在append消息，所以是while，而loaded cursor的offset也是没加载一个消息更新的</span></span><br><span class="line">            <span class="keyword">while</span> (currentOffset &lt; offset) &#123;</span><br><span class="line">                Optional&lt;ScheduleIndex&gt; recordOptional = visitor.nextRecord();</span><br><span class="line">                <span class="keyword">if</span> (!recordOptional.isPresent()) <span class="keyword">break</span>;</span><br><span class="line">                ScheduleIndex index = recordOptional.get();</span><br><span class="line">                currentOffset = index.getOffset() + index.getSize();</span><br><span class="line">                refresh(index);</span><br><span class="line">                loadedCursor.shiftOffset(currentOffset);</span><br><span class="line">            &#125;</span><br><span class="line">            loadedCursor.shiftCursor(baseOffset);</span><br><span class="line">            LOGGER.info(<span class="string">"loaded segment:&#123;&#125; &#123;&#125;"</span>, loadedCursor.baseOffset(), currentOffset);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            visitor.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Metrics.timer(<span class="string">"loadSegmentTimer"</span>).update(System.currentTimeMillis() - start, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得上一篇我们提到过，存储的时候，如果这个消息位于正在被wheel加载segment中，那么这个消息应该是会被加载到wheel中的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">iterateCallback</span><span class="params">(<span class="keyword">final</span> ScheduleIndex index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> scheduleTime = index.getScheduleTime();</span><br><span class="line">    <span class="keyword">long</span> offset = index.getOffset();</span><br><span class="line">    <span class="comment">// 主要看一下这个canAdd</span></span><br><span class="line">    <span class="keyword">if</span> (wheelTickManager.canAdd(scheduleTime, offset)) &#123;</span><br><span class="line">        wheelTickManager.addWHeel(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就是cursor起作用的地方了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canAdd</span><span class="params">(<span class="keyword">long</span> scheduleTime, <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">    WheelLoadCursor.Cursor currentCursor = loadingCursor.cursor();</span><br><span class="line">    <span class="keyword">int</span> currentBaseOffset = currentCursor.getBaseOffset();</span><br><span class="line">    <span class="keyword">long</span> currentOffset = currentCursor.getOffset();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据延迟时间确定该消息位于哪个segment</span></span><br><span class="line">    <span class="keyword">int</span> baseOffset = resolveSegment(scheduleTime);</span><br><span class="line">    <span class="comment">// 小于当前loading cursor,则put int wheel</span></span><br><span class="line">    <span class="keyword">if</span> (baseOffset &lt; currentBaseOffset) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正在加载</span></span><br><span class="line">    <span class="keyword">if</span> (baseOffset == currentBaseOffset) &#123;</span><br><span class="line">    <span class="comment">// 根据cursor的offset判断</span></span><br><span class="line">        <span class="keyword">return</span> currentOffset &lt;= offset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="sender"></a></p><h2 id="sender"><a href="#sender" class="headerlink" title="sender"></a>sender</h2><p>sender包里结构如下图：<br><br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1552225820958-e8c18683-a57d-4d74-af71-33a29ce43376.png#align=left&amp;display=inline&amp;height=146&amp;name=image.png&amp;originHeight=146&amp;originWidth=245&amp;size=6507&amp;status=done&amp;width=245" alt="image.png"><br>通过brokerGroup做分组，根据组批量发送，发送时是多线程发送，每个组互不影响，发送时也会根据实时broker的weight进行选择考虑broker进行发送。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(ScheduleIndex index)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!BrokerRoleManager.isDelayMaster()) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> add;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">long</span> waitTime = Math.abs(sendWaitTime);</span><br><span class="line">          <span class="comment">// 入队</span></span><br><span class="line">          <span class="keyword">if</span> (waitTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              add = batchExecutor.addItem(index, waitTime, TimeUnit.MILLISECONDS);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              add = batchExecutor.addItem(index);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!add) &#123;</span><br><span class="line">          reject(index);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;ScheduleIndex&gt; indexList)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 发送处理逻辑在senderExecutor里</span></span><br><span class="line">          senderExecutor.execute(indexList, <span class="keyword">this</span>, brokerService);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          LOGGER.error(<span class="string">"send message failed,messageSize:&#123;&#125; will retry"</span>, indexList.size(), e);</span><br><span class="line">          retry(indexList);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下为senderExecutor内容</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> List&lt;ScheduleIndex&gt; indexList, <span class="keyword">final</span> SenderGroup.ResultHandler handler, <span class="keyword">final</span> BrokerService brokerService)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 分组</span></span><br><span class="line">      Map&lt;SenderGroup, List&lt;ScheduleIndex&gt;&gt; groups = groupByBroker(indexList, brokerService);</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;SenderGroup, List&lt;ScheduleIndex&gt;&gt; entry : groups.entrySet()) &#123;</span><br><span class="line">          doExecute(entry.getKey(), entry.getValue(), handler);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExecute</span><span class="params">(<span class="keyword">final</span> SenderGroup group, <span class="keyword">final</span> List&lt;ScheduleIndex&gt; list, <span class="keyword">final</span> SenderGroup.ResultHandler handler)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 分组发送</span></span><br><span class="line">      group.send(list, sender, handler);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到，投递时是根据server broker进行分组投递。看一下SenderGroup这个类<br><br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1552226236558-1141d53b-a8d0-495b-a1ec-6fa7eb8d7310.png#align=left&amp;display=inline&amp;height=420&amp;name=image.png&amp;originHeight=420&amp;originWidth=781&amp;size=92662&amp;status=done&amp;width=781" alt="image.png"><br>可以看到，每个组的投递是多线程，互不影响，不会存在某个组的server挂掉，导致其他组无法投递。并且这里如果存在某个组无法投递，重试时会选择其它的server broker进行重试。与此同时，在选择组时，会根据每个server broker的weight进行综合考量，即当前server broker有多少消息量要发送。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 具体发送的地方</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Sender sender, ResultHandler handler, BrokerGroupInfo groupInfo, String groupName, List&lt;ScheduleIndex&gt; list)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">          List&lt;ScheduleSetRecord&gt; records = store.recoverLogRecord(list);</span><br><span class="line">          QMon.loadMsgTime(System.currentTimeMillis() - start);</span><br><span class="line"></span><br><span class="line">          Datagram response = sendMessages(records, sender);</span><br><span class="line">          release(records);</span><br><span class="line">          monitor(list, groupName);</span><br><span class="line">          <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">              handler.fail(list);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">int</span> responseCode = response.getHeader().getCode();</span><br><span class="line">              <span class="keyword">final</span> Map&lt;String, SendResult&gt; resultMap = getSendResult(response);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (resultMap == <span class="keyword">null</span> || responseCode != CommandCode.SUCCESS) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (responseCode == CommandCode.BROKER_REJECT || responseCode == CommandCode.BROKER_ERROR) &#123;</span><br><span class="line">                    <span class="comment">// 该组熔断  </span></span><br><span class="line">                    groupInfo.markFailed();</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  monitorSendFail(list, groupInfo.getGroupName());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重试</span></span><br><span class="line">                  handler.fail(list);</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              Set&lt;String&gt; failedMessageIds = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">              <span class="keyword">boolean</span> brokerRefreshed = <span class="keyword">false</span>;</span><br><span class="line">              <span class="keyword">for</span> (Map.Entry&lt;String, SendResult&gt; entry : resultMap.entrySet()) &#123;</span><br><span class="line">                  <span class="keyword">int</span> resultCode = entry.getValue().getCode();</span><br><span class="line">                  <span class="keyword">if</span> (resultCode != MessageProducerCode.SUCCESS) &#123;</span><br><span class="line">                      failedMessageIds.add(entry.getKey());</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (!brokerRefreshed &amp;&amp; resultCode == MessageProducerCode.BROKER_READ_ONLY) &#123;</span><br><span class="line">                      groupInfo.markFailed();</span><br><span class="line">                      brokerRefreshed = <span class="keyword">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (!brokerRefreshed) groupInfo.markSuccess();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// dispatch log 记录在这里产生</span></span><br><span class="line">              handler.success(records, failedMessageIds);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          LOGGER.error(<span class="string">"sender group send batch failed,broker:&#123;&#125;,batch size:&#123;&#125;"</span>, groupName, list.size(), e);</span><br><span class="line">          handler.fail(list);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>就是以上这些，关于QMQ的delay-server源码分析就是这些了，如果以后有机会会分析一下QMQ的其他模块源码，谢谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;df368884&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;上篇我们分析了QMQ
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="MQ" scheme="https://blog.dengxf.cn/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>QMQ源码分析之delay-server篇【二】</title>
    <link href="https://blog.dengxf.cn/14f2781.html"/>
    <id>https://blog.dengxf.cn/14f2781.html</id>
    <published>2019-03-02T01:35:59.000Z</published>
    <updated>2019-05-05T07:11:07.931Z</updated>
    
    <content type="html"><![CDATA[<p><a name="df368884"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>本来是固定时间周六更博，但是昨天失恋了，心情不好，晚了一天。那么上一篇我们梳理了下QMQ延迟消息的主要功能，这一篇在此基础上，对照着功能分析一下源码。</p></blockquote><p><a name="74fc4edb"></a></p><h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><p>要了解delay-server源码的一个整体结构，需要我们跟着源码，从初始化开始简单先过一遍。重试化的工作都在startup这个包里，而这个包只有一个ServerWrapper类。<img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1551520273789-e28ea7fb-b86e-4c50-ba21-66bbf9a2f123.png#align=left&amp;display=inline&amp;height=668&amp;name=image.png&amp;originHeight=668&amp;originWidth=1207&amp;size=86215&amp;status=done&amp;width=1207" alt="image.png"><br>结合上一篇的内容，通过这个类就基本能看到delay的一个源码结构。delay-server基于netty，init方法完成初始化工作（端口默认为20801、心跳、wheel等），register方法是向meta-server发起请求，获取自己自己的<code>角色</code>为<code>delay</code>，并开始和meta-server的心跳。startServer方法是开始HashWheel的转动，从上次结束的位置继续message_log的回放，开启netty server。另外在做准备工作时知道QMQ是基于一主一从一备的方式，关于这个sync方法，是开启监听一个端口回应<code>同步拉取</code>动作，如果是从节点还要开始向主节点发起<code>同步拉取</code>动作。当这一切都完成了，那么online方法就执行，表示delay开始上线提供服务了。总结一下两个要点，QMQ是基于netty进行通信，并且采用一主一从一备的方式。<br><a name="a39cf1ca"></a></p><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p>关于存储在之前我们也讨论了，delay-server接收到延迟消息，会顺序append到message_log，之后再对message_log进行回放，以生成schedule_log。所以关于存储我们需要关注两个东西，一个是message_log的存储，另一个是schedule_log的生成。<br><a name="message_log"></a></p><h2 id="message-log"><a href="#message-log" class="headerlink" title="message_log"></a>message_log</h2><p>其实message_log的生成很简单，就是顺序append。主要逻辑在<code>qunar.tc.qmq.delay.receiver.Receiver</code>这个类里，大致流程就是关于QMQ自定义协议的一个反序列化，然后再对序列化的单个消息进行存储。如图：<img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1551598452729-dfd480c5-fa43-4b60-b81a-221e3950acb1.png#align=left&amp;display=inline&amp;height=615&amp;name=image.png&amp;originHeight=615&amp;originWidth=1141&amp;size=114348&amp;status=done&amp;width=1141" alt="image.png"><br>主要逻辑在途中标红方法<code>doInvoke</code>中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void doInvoke(ReceivedDelayMessage message) &#123;</span><br><span class="line">    // ... </span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      // 注：这里是进行append的地方</span><br><span class="line">      ReceivedResult result = facade.appendMessageLog(message);</span><br><span class="line">      offer(message, result);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">       error(message, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delay存储层相关逻辑都在facade这个类里，初始化时类似消息的校验等工作也都在这里，而message_log的相关操作都在messageLog里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public AppendMessageRecordResult append(RawMessageExtend record) &#123;</span><br><span class="line">      AppendMessageResult&lt;Long&gt; result;</span><br><span class="line">      // 注：当前最新的一个segment</span><br><span class="line">      LogSegment segment = logManager.latestSegment();</span><br><span class="line">      if (null == segment) &#123;</span><br><span class="line">          segment = logManager.allocNextSegment();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (null == segment) &#123;</span><br><span class="line">          return new AppendMessageRecordResult(PutMessageStatus.CREATE_MAPPED_FILE_FAILED, null);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">// 注：真正进行append的动作是messageAppender</span><br><span class="line">      result = segment.append(record, messageAppender);</span><br><span class="line">      switch (result.getStatus()) &#123;</span><br><span class="line">          case MESSAGE_SIZE_EXCEEDED:</span><br><span class="line">              return new AppendMessageRecordResult(PutMessageStatus.MESSAGE_ILLEGAL, null);</span><br><span class="line">          case END_OF_FILE:</span><br><span class="line">              if (null == logManager.allocNextSegment()) &#123;</span><br><span class="line">                  return new AppendMessageRecordResult(PutMessageStatus.CREATE_MAPPED_FILE_FAILED, null);</span><br><span class="line">              &#125;</span><br><span class="line">              return append(record);</span><br><span class="line">          case SUCCESS:</span><br><span class="line">              return new AppendMessageRecordResult(PutMessageStatus.SUCCESS, result);</span><br><span class="line">          default:</span><br><span class="line">              return new AppendMessageRecordResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 看一下这个appender，也可以通过这里能看到QMQ的delay message 格式定义</span><br><span class="line">  private class DelayRawMessageAppender implements MessageAppender&lt;RawMessageExtend, Long&gt; &#123;</span><br><span class="line">      private final ReentrantLock lock = new ReentrantLock();</span><br><span class="line">      private final ByteBuffer workingBuffer = ByteBuffer.allocate(1024);</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public AppendMessageResult&lt;Long&gt; doAppend(long baseOffset, ByteBuffer targetBuffer, int freeSpace, RawMessageExtend message) &#123;</span><br><span class="line">          // 这个lock这里影响不大</span><br><span class="line">          lock.lock();</span><br><span class="line">          try &#123;</span><br><span class="line">              workingBuffer.clear();</span><br><span class="line"></span><br><span class="line">              final String messageId = message.getHeader().getMessageId();</span><br><span class="line">              final byte[] messageIdBytes = messageId.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">              final String subject = message.getHeader().getSubject();</span><br><span class="line">              final byte[] subjectBytes = subject.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">              final long startWroteOffset = baseOffset + targetBuffer.position();</span><br><span class="line">              final int recordSize = recordSizeWithCrc(messageIdBytes.length, subjectBytes.length, message.getBodySize());</span><br><span class="line"></span><br><span class="line">              if (recordSize &gt; config.getSingleMessageLimitSize()) &#123;</span><br><span class="line">                  return new AppendMessageResult&lt;&gt;(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED, startWroteOffset, freeSpace, null);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              workingBuffer.flip();</span><br><span class="line">              if (recordSize != freeSpace &amp;&amp; recordSize + MIN_RECORD_BYTES &gt; freeSpace) &#123;</span><br><span class="line">              // 填充</span><br><span class="line">                  workingBuffer.limit(freeSpace);</span><br><span class="line">                  workingBuffer.putInt(MESSAGE_LOG_MAGIC_V1);</span><br><span class="line">                  workingBuffer.put(MessageLogAttrEnum.ATTR_EMPTY_RECORD.getCode());</span><br><span class="line">                  workingBuffer.putLong(System.currentTimeMillis());</span><br><span class="line">                  targetBuffer.put(workingBuffer.array(), 0, freeSpace);</span><br><span class="line">                  return new AppendMessageResult&lt;&gt;(AppendMessageStatus.END_OF_FILE, startWroteOffset, freeSpace, null);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  int headerSize = recordSize - message.getBodySize();</span><br><span class="line">                  workingBuffer.limit(headerSize);</span><br><span class="line">                  workingBuffer.putInt(MESSAGE_LOG_MAGIC_V2);</span><br><span class="line">                  workingBuffer.put(MessageLogAttrEnum.ATTR_MESSAGE_RECORD.getCode());</span><br><span class="line">                  workingBuffer.putLong(System.currentTimeMillis());</span><br><span class="line">                  // 注意这里，是schedule_time ，即延迟时间</span><br><span class="line">                  workingBuffer.putLong(message.getScheduleTime());</span><br><span class="line">                  // sequence,每个brokerGroup应该是唯一的</span><br><span class="line">                  workingBuffer.putLong(sequence.incrementAndGet());</span><br><span class="line">                  workingBuffer.putInt(messageIdBytes.length);</span><br><span class="line">                  workingBuffer.put(messageIdBytes);</span><br><span class="line">                  workingBuffer.putInt(subjectBytes.length);</span><br><span class="line">                  workingBuffer.put(subjectBytes);</span><br><span class="line">                  workingBuffer.putLong(message.getHeader().getBodyCrc());</span><br><span class="line">                  workingBuffer.putInt(message.getBodySize());</span><br><span class="line">                  targetBuffer.put(workingBuffer.array(), 0, headerSize);</span><br><span class="line">                  targetBuffer.put(message.getBody().nioBuffer());</span><br><span class="line"></span><br><span class="line">                  final long payloadOffset = startWroteOffset + headerSize;</span><br><span class="line">                  return new AppendMessageResult&lt;&gt;(AppendMessageStatus.SUCCESS, startWroteOffset, recordSize, payloadOffset);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">              lock.unlock();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上基本就是message_log的存储部分，接下来我们来看message_log的回放生成schedule_log。<br><a name="schedule_log"></a></p><h2 id="schedule-log"><a href="#schedule-log" class="headerlink" title="schedule_log"></a>schedule_log</h2><p>MessageLogReplayer这个类就是控制回放的地方。那么考虑一个问题，下一次重启的时候，我们该从哪里进行回放？QMQ是会有一个回放的offset，这个offset会定时刷盘，下次重启的时候会从这个offset位置开始回放。细节可以看一下下面这段代码块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">final LogVisitor&lt;LogRecord&gt; visitor = facade.newMessageLogVisitor(iterateFrom.longValue());</span><br><span class="line">adjustOffset(visitor);</span><br><span class="line"></span><br><span class="line">while (true) &#123;</span><br><span class="line">    final Optional&lt;LogRecord&gt; recordOptional = visitor.nextRecord();</span><br><span class="line">    if (recordOptional.isPresent() &amp;&amp; recordOptional.get() == DelayMessageLogVisitor.EMPTY_LOG_RECORD) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    recordOptional.ifPresent((record) -&gt; &#123;</span><br><span class="line">    // post以进行存储</span><br><span class="line">        dispatcher.post(record);</span><br><span class="line">        long checkpoint = record.getStartWroteOffset() + record.getRecordSize();</span><br><span class="line">        this.cursor.addAndGet(record.getRecordSize());</span><br><span class="line">        facade.updateIterateOffset(checkpoint);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">iterateFrom.add(visitor.visitedBufferSize());</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(5);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    LOGGER.warn(&quot;message log iterate sleep interrupted&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里除了offset还有个cursor，这是为了防止回放失败，sleep 5ms后再次回放的时候从cursor位置开始，避免重复消息。那么我们看一下dispatcher.post这个方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void post(LogRecord event) &#123;</span><br><span class="line">// 这里是schedule_log</span><br><span class="line">    AppendLogResult&lt;ScheduleIndex&gt; result = facade.appendScheduleLog(event);</span><br><span class="line">    int code = result.getCode();</span><br><span class="line">    if (MessageProducerCode.SUCCESS != code) &#123;</span><br><span class="line">        LOGGER.error(&quot;appendMessageLog schedule log error,log:&#123;&#125; &#123;&#125;,code:&#123;&#125;&quot;, event.getSubject(), event.getMessageId(), code);</span><br><span class="line">        throw new AppendException(&quot;appendScheduleLogError&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 先看这里</span><br><span class="line">    iterateCallback.apply(result.getAdditional());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如以上代码，我们看略过schedule_log的存储，看一下那个callback是几个意思:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private boolean iterateCallback(final ScheduleIndex index) &#123;</span><br><span class="line">  // 延迟时间</span><br><span class="line">      long scheduleTime = index.getScheduleTime();</span><br><span class="line">      // 这个offset是startOffset,即在delay_segment中的这个消息的起始位置</span><br><span class="line">      long offset = index.getOffset();</span><br><span class="line">      // 是否add到内存中的HashWheel</span><br><span class="line">      if (wheelTickManager.canAdd(scheduleTime, offset)) &#123;</span><br><span class="line">          wheelTickManager.addWHeel(index);</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的意思是，delay-server接收到消息，会判断一下这个消息是否需要add到内存中的wheel中，以防止丢消息。大家记着有这个事情，在投递小节中我们回过头来再说这里。那么回到facade.appendScheduleLog这个方法，schedule_log相关操作在scheduleLog里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public RecordResult&lt;T&gt; append(LogRecord record) &#123;</span><br><span class="line">      long scheduleTime = record.getScheduleTime();</span><br><span class="line">      // 这里是根据延迟时间定位对应的delaySegment的</span><br><span class="line">      DelaySegment&lt;T&gt; segment = locateSegment(scheduleTime);</span><br><span class="line">      if (null == segment) &#123;</span><br><span class="line">          segment = allocNewSegment(scheduleTime);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (null == segment) &#123;</span><br><span class="line">          return new NopeRecordResult(PutMessageStatus.CREATE_MAPPED_FILE_FAILED);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">// 具体动作在append里</span><br><span class="line">      return retResult(segment.append(record, appender));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>留意locateSegment这个方法，它是根据延迟时间定位DelaySegment，比如如果延迟时间是2019-03-03 16:00:00，那么就会定位到201903031600这个DelaySegment（注：这里贴的代码不是最新的，最新的是DelaySegment的刻度是可以配置，到分钟级别）。同样，具体动作也是appender做的，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public AppendRecordResult&lt;ScheduleSetSequence&gt; appendLog(LogRecord log) &#123;</span><br><span class="line">        workingBuffer.clear();</span><br><span class="line">        workingBuffer.flip();</span><br><span class="line">        final byte[] subjectBytes = log.getSubject().getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        final byte[] messageIdBytes = log.getMessageId().getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        int recordSize = getRecordSize(log, subjectBytes.length, messageIdBytes.length);</span><br><span class="line">        workingBuffer.limit(recordSize);</span><br><span class="line"></span><br><span class="line">        long scheduleTime = log.getScheduleTime();</span><br><span class="line">        long sequence = log.getSequence();</span><br><span class="line">        workingBuffer.putLong(scheduleTime);</span><br><span class="line">        // message_log中的sequence</span><br><span class="line">        workingBuffer.putLong(sequence);</span><br><span class="line">        workingBuffer.putInt(log.getPayloadSize());</span><br><span class="line">        workingBuffer.putInt(messageIdBytes.length);</span><br><span class="line">        workingBuffer.put(messageIdBytes);</span><br><span class="line">        workingBuffer.putInt(subjectBytes.length);</span><br><span class="line">        workingBuffer.put(subjectBytes);</span><br><span class="line">        workingBuffer.put(log.getRecord());</span><br><span class="line">        workingBuffer.flip();</span><br><span class="line">        ScheduleSetSequence record = new ScheduleSetSequence(scheduleTime, sequence);</span><br><span class="line">        return new AppendRecordResult&lt;&gt;(AppendMessageStatus.SUCCESS, 0, recordSize, workingBuffer, record);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里也能看到schedule_log的消息格式。</p><p><strong>发现就写了个存储篇幅就已经挺大了，投递涉及到的内容可能更多，那么关于投递就开个下一篇吧。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;df368884&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="MQ" scheme="https://blog.dengxf.cn/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>QMQ源码分析之delay-server篇【一】</title>
    <link href="https://blog.dengxf.cn/3159cb59.html"/>
    <id>https://blog.dengxf.cn/3159cb59.html</id>
    <published>2019-02-23T01:26:24.000Z</published>
    <updated>2019-05-05T07:11:07.935Z</updated>
    
    <content type="html"><![CDATA[<p><a name="df368884"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>QMQ是一款去哪儿网内部使用多年的mq。不久前(大概1-2年前)已在携程投入生产大规模使用，年前这款mq也开源了出来。关于<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1bmFyY29ycC9xbXE=" title="https://github.com/qunarcorp/qmq">QMQ<i class="fa fa-external-link"></i></span>的相关设计文章可以看<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1bmFyY29ycC9xbXEvdHJlZS9tYXN0ZXIvZG9jcy9jbg==" title="https://github.com/qunarcorp/qmq/tree/master/docs/cn">这里<i class="fa fa-external-link"></i></span>。在这里，我假设你已经对QMQ前世今生以及其设计和实现等背景知识已经有了一个较为全面的认识。</p></blockquote><p><a name="f2aee0d8"></a></p><h2 id="我的阅读姿势"><a href="#我的阅读姿势" class="headerlink" title="我的阅读姿势"></a>我的阅读姿势</h2><p>对一款开源产品愈来愈感兴趣，想要了解一款开源产品更多的技术细节的时候，最好的方式自然是去阅读她的源码。那么一个正确阅读开源软件源码的姿势是什么呢？我觉得这完全就像一个相亲过程：</p><ol><li>媒婆介绍相亲对象基本信息。这一定是前提。很多人都忽视了这一个步骤。在这个步骤中，要去了解这款开源软件是用来做什么的？解决了什么问题？如何解决这些问题的？所处地位？其实就是what,why,how,where四个问题。要是在阅读源码前能准备下这四个问题的答案，那么接下来阅读源码的工作将更有效果。</li><li>见面，喝茶，对媒婆所言一探究竟。这个时候我们要去认识下软件的整体结构，例如，包结构，依赖轻重，主要功能是哪些在哪里等。此外还要去验证下”媒婆所言”是否属实，我们要自己操作运行一下，对这个”姑娘”有一个基础认识。</li><li>约会。有以上基础认识之后，就要深入源码一探究竟。针对各功能点(主要是第一个步骤中谈到的解决的什么问题即why)各条线深入下去，最后贯穿起来，形成一个闭环。</li><li>自由发挥。这个时候就看缘分了，对上眼就成了contributor，对不上眼也能多个朋友多条路不是。</li></ol><p><a name="31762d66"></a></p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>对于delay-server，官方已经有了一些<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvX05XRW1rdTd2UkF1NWNjLW1LRHhLQQ==" title="https://mp.weixin.qq.com/s/_NWEmku7vRAu5cc-mKDxKA">介绍<i class="fa fa-external-link"></i></span>。记住，官方通常是最卖力的那个”媒婆”。qmq-delay-server其实主要做的是转发工作。所谓转发，就是delay-server做的就是个存储和投递的工作。怎么理解，就是qmq-client会对消息进行一个路由，即实时消息投递到实时server，延迟消息往delay-server投递，多说一句，这个路由的功能是由qmq-meta-server提供。投递到delay-server的消息会存下来，到时间之后再进行投递。现在我们知道了<code>存储</code>和<code>投递</code>是delay-server主要的两个功能点。那么我们挨个击破:<br><a name="a39cf1ca"></a></p><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>假如让我们来设计实现一个delay-server，存储部分我们需要解决什么问题？我觉得主要是要解决到期投递的<code>到期</code>问题。我们可以用传统db做，但是这个性能肯定是上不去的。我们也可以用基于LSM树的RocksDB。或者，干脆直接用文件存储。QMQ是用文件存储的。而用文件存储是怎么解决<code>到期</code>问题的呢？delay-server接收到延迟消息，就将消息append到message_log中，然后再通过回放这个message_log得到schedule_log，此外还有一个dispatch _log用于记录投递记录。QMQ还有个跟投递相关的存储设计，即两层HashWheel。第一层位于磁盘上，例如，以一个小时一个刻度一个文件，我们叫delay_message_segment，如延迟时间为2019年02月23日 19:00 至2019年02月23日 20:00为延迟消息将被存储在2019022319。并且这个刻度是可以配置调整的。第二层HashWheel位于内存中。也是以一个时间为刻度，比如500ms，加载进内存中的延迟消息文件会根据延迟时间hash到一个HashWheel中，第二层的wheel涉及更多的是下一小节的<strong>投递</strong>。貌似存储到这里就结束了，然而还有一个问题，目前当投递的时候我们需要将一个delay_message_segment加载进内存中，而假如我们提前一个刻度加载进一个delay_message_segment到内存中的hashwheel，比如在2019年02月23日 18:00加载2019022319这个segment文件，那么一个hashwheel中就会存在两个delay_message_segment，而这个时候所占内存是非常大的，所以这是完全不可接收的。所以，QMQ引入了一个数据结构，叫schedule_index，即消息索引，存储的内容为消息的索引，我们加载到内存的是这个schedule_index，在真正投递的时候再根据索引查到消息体进行投递。<br><a name="31cb9169"></a></p><h4 id="投递"><a href="#投递" class="headerlink" title="投递"></a>投递</h4><p>解决了存储，那么到期的延迟消息如何投递呢？如在上一小节<strong>存储</strong>中所提到的，内存中的hashwheel会提前一段时间加载delay_schedule_index，这个时间自然也是可以配置的。而在hashwheel中，默认每500ms会tick一次，这个500ms也是可以根据用户需求配置的。而在投递的时候，QMQ根据实时broker进行分组多线程投递，如果某一broker离线不可用，导致投递失败，delay-server会将延迟消息投递在其他<code>存活</code>的实时broker。其实这里对于实时的broker应该有一个关于投递消息权重的，现在delay-server没有考虑到这一点，不过我看已经有一个pr解决了这个问题，只是官方还没有时间看这个问题。除此之外，QMQ还考虑到了要是当前延迟消息所属的delay_segment已经加载到内存中的hashwheel了，这个时候消息应该是直接投递或也应加载到hashwheel中的。这里需要考虑的情况还是比较多的，比如考虑delay_segment正在加载、已经加载、加载完成等情况，对于这种情况，QMQ用了两个cursor来表示hashwheel加载到哪个delay_segment以及加载到对应segment的什么offset了，这里还是挺复杂的，这里的代码逻辑在<code>WheelTickManager</code>这个类。</p><hr><p>我们先来看一看整体结构<br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550935854945-5930d1df-0316-4e07-8d51-4f794093200f.png#align=left&amp;display=inline&amp;height=746&amp;name=image.png&amp;originHeight=746&amp;originWidth=1366&amp;size=265433&amp;status=done&amp;width=1366" alt="image.png"><br>以功能划分的包结构，算是比较清晰。cleaner是日志清理工作相关，receiver是接收消息相关，sender是投递相关，store是存储相关，sync是同步备份相关，wheel则是hashwheel相关。</p><p><strong>关于QMQ源码阅读前的准备工作就先做到这里，下一篇我们就深入源码分析以上提到的各个细节。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a name=&quot;df368884&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="技术分享" scheme="https://blog.dengxf.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="源码分析" scheme="https://blog.dengxf.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="MQ" scheme="https://blog.dengxf.cn/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>如何科学上网？</title>
    <link href="https://blog.dengxf.cn/8c46c59b.html"/>
    <id>https://blog.dengxf.cn/8c46c59b.html</id>
    <published>2019-02-14T18:54:09.000Z</published>
    <updated>2019-05-05T07:11:07.935Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为了给我们提供一个<code>安全</code>的网络环境，所以先驱前辈们建立了一堵墙。总有些<code>调皮</code> <code>好奇</code>的孩子想要翻过墙去看看墙那边的世界。但是存在风险，需谨慎。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550203371840-7da7ce17-8331-4d90-9a69-0e2e66e5d844.png#align=left&amp;display=inline&amp;height=368&amp;name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190215120239.png&amp;originHeight=948&amp;originWidth=1920&amp;size=59975&amp;width=746" alt="微信图片_20190215120239.png"><br>共有下面两种方式供选择：<br><a name="50c84e82"></a></p><h2 id="利用VPN"><a href="#利用VPN" class="headerlink" title="利用VPN"></a>利用VPN</h2><p><a name="aa2c9140"></a></p><h4 id="免费"><a href="#免费" class="headerlink" title="免费"></a>免费</h4><p>免费的vpn有很多，但是速度、稳定性和流量限制是基本不能满足需要的，所以就不推荐了。<br><a name="b00379d1"></a></p><h4 id="收费"><a href="#收费" class="headerlink" title="收费"></a>收费</h4><p>收费的vpn一般都在每月10元左右，并且足够稳定。另外，建议大家选择国外的vpn，国内的vpn产商说不定哪天就跑路什么的。在这里，推荐ExpressVPN和PureVPN。前者比较知名，也比较<code>稳健</code>，价格大概在每月$7+；后者也相对比较好用，每月大概在$3+，说是有中国用户的专线。<br>详情可<span class="exturl" data-url="aHR0cHM6Ly93d3cudnBuZGFkYS5jb20vYmVzdC12cG5zLWZvci1jaGluYS1jbi8=" title="https://www.vpndada.com/best-vpns-for-china-cn/">参考<i class="fa fa-external-link"></i></span>。<br><a name="a27e687d"></a></p><h2 id="自建代理"><a href="#自建代理" class="headerlink" title="自建代理"></a>自建代理</h2><p>喜欢掌握主动权的我，倾向于采用自建代理的方案。综合来看自建代理都是最实惠，最可控的方案。<br><a name="96f439d6"></a></p><h4 id="购买VPS"><a href="#购买VPS" class="headerlink" title="购买VPS"></a>购买VPS</h4><p>目前VPS产商有两家做的最大，分别是BandwagonHost(搬瓦工)和Vultr。有篇<span class="exturl" data-url="aHR0cHM6Ly9mbHl6eWJsb2cuY29tL2JhbmR3YWdvbmhvc3QtdnVsdHItY29tcGFyaXNvbi8=" title="https://flyzyblog.com/bandwagonhost-vultr-comparison/">文章<i class="fa fa-external-link"></i></span>对比了这两家厂商的产品。<br>购买VPS都是有优惠的，<span class="exturl" data-url="aHR0cDovL2JhbndhZ29uZy5jbi8=" title="http://banwagong.cn/">搬瓦工<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cHM6Ly93d3cudnVsdHJ5aHcuY24v" title="https://www.vultryhw.cn/">Vultr<i class="fa fa-external-link"></i></span>。<br>因为搬瓦工比较老牌，老而弥坚，所以我选择的是它。如果你不喜欢老而弥<code>坚</code>的东西，选择了Vultr，那么请移步看<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3RhY2tjYy5jb20vMjAxOC8xMS8wOC9zc3ItdnBzLw==" title="https://www.stackcc.com/2018/11/08/ssr-vps/">搭建SSR<i class="fa fa-external-link"></i></span>。购买时注意是不是支持中国专线，如果没注意，那么购买成功之后也是可以更改线路的。购买完成，你会受到一封邮件，里边有ip port password等信息，连接上vps，安装完一些基础工具(wget等)，就可以开干了。<br><a name="8cc36ea8"></a></p><h4 id="搭建代理"><a href="#搭建代理" class="headerlink" title="搭建代理"></a>搭建代理</h4><p>现在用的最多的就是<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoYWRvd3NvY2tz" title="https://github.com/shadowsocks">shadowsocks<i class="fa fa-external-link"></i></span>，以及其衍生版本<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoYWRvd3NvY2tzci1iYWNrdXA=" title="https://github.com/shadowsocksr-backup">shadowsocks r<i class="fa fa-external-link"></i></span>。我选择的是shadowsockr。这里有个<span class="exturl" data-url="aHR0cHM6Ly9zc3IudG9vbHMv" title="https://ssr.tools/">ssr<i class="fa fa-external-link"></i></span>工具网站，客户端，一键安装脚本在这里都能找到。</p><ol><li>ssh连接上vps</li><li>依次运行下边三条命令：<br></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x shadowsocks-all.sh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure><ol><li>接下来按照提示，选择参数安装即可，步骤大概为：<ol><li>选择版本，建议ShadowsocksR</li><li>设置SSR密码</li><li>选择SSR服务器端口</li><li>选择加密方式<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/261134/1550223183058-b27b72ac-027a-4550-8273-f8516e1c1f1b.jpeg#align=left&amp;display=inline&amp;height=290&amp;name=2018-07-12_154549.jpg&amp;originHeight=290&amp;originWidth=446&amp;size=23089&amp;width=446" alt="2018-07-12_154549.jpg"><br>如这里选择chacha20，输入对应序号12即可。</li><li>选择协议<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/261134/1550223232353-b1c4eea1-8116-4bab-b3ae-366e0c83982d.jpeg#align=left&amp;display=inline&amp;height=230&amp;name=2018-07-12_154640.jpg&amp;originHeight=230&amp;originWidth=420&amp;size=23545&amp;width=420" alt="2018-07-12_154640.jpg"><br>如这里选择auth_aes128_md5，输入对应序号5即可</li><li>选择混淆方式<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/261134/1550223307214-0422bcaf-06ae-4139-b639-8958cb161b0a.jpeg#align=left&amp;display=inline&amp;height=182&amp;name=2018-07-12_154714.jpg&amp;originHeight=182&amp;originWidth=392&amp;size=18147&amp;width=392" alt="2018-07-12_154714.jpg"><br>如这里选择http_simple，输入对应序号2即可</li><li>参数设置完成，任意键开始安装，静静等待。</li><li><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/261134/1550223377785-43bafaa1-6fd7-4030-a2a6-030421a377ae.jpeg#align=left&amp;display=inline&amp;height=325&amp;name=2018-07-12_155328.jpg&amp;originHeight=325&amp;originWidth=644&amp;size=39392&amp;width=644" alt="2018-07-12_155328.jpg"><br>安装完成，你会看到以上信息，记录下来，待会儿会用到。你也可以在下图文件夹下的config.json看到。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550223556002-311135cd-fbdb-4c3c-9bf7-1d7f02b25dc5.png#align=left&amp;display=inline&amp;height=272&amp;name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190215173855.png&amp;originHeight=272&amp;originWidth=556&amp;size=4809&amp;width=556" alt="微信图片_20190215173855.png"><br><br><a name="e4dba1fd"></a><h4 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a>客户端安装</h4><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoYWRvd3NvY2tzcnIvc2hhZG93c29ja3NyLWNzaGFycC9yZWxlYXNlcw==" title="https://github.com/shadowsocksrr/shadowsocksr-csharp/releases">windows<i class="fa fa-external-link"></i></span> 下载<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Fpbnl1aGFuZy9TaGFkb3dzb2Nrc1gtTkctUi9yZWxlYXNlcw==" title="https://github.com/qinyuhang/ShadowsocksX-NG-R/releases">mac<i class="fa fa-external-link"></i></span>下载<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoYWRvd3NvY2tzcnIvc2hhZG93c29ja3NyLWFuZHJvaWQvcmVsZWFzZXM=" title="https://github.com/shadowsocksrr/shadowsocksr-android/releases">andriod<i class="fa fa-external-link"></i></span>下载 或者在应用商城看一下有没有shadowsocks-r(或者ssr)客户端下载<br>ios 免费的App可以用Potatso Lite，不过应该需要<span class="exturl" data-url="aHR0cHM6Ly9zc3IudG9vbHMvMTA0" title="https://ssr.tools/104">申请<i class="fa fa-external-link"></i></span>一下美国AppleID<br>安装完毕，输入安装完毕让你记下的那些信息(在/etc/shadowsocks-r/config.json，或者在刚才安装的目录下找到shadowsocks-all.log文件里也有相关信息)。另外，ssr客户端支持二维码扫描，剪贴板导入等方式，很方便，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550225021512-044ebcee-5e88-4073-b67d-3630d915b71b.png#align=left&amp;display=inline&amp;height=106&amp;name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190215180301.png&amp;originHeight=106&amp;originWidth=238&amp;size=19155&amp;width=238" alt="微信图片_20190215180301.png"><br>安卓上效果如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550225391948-1810ccd1-1ab2-412f-99a9-0fc3c3dcabb5.png#align=left&amp;display=inline&amp;height=846&amp;name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190215180933.png&amp;originHeight=846&amp;originWidth=531&amp;size=565850&amp;width=531" alt="微信图片_20190215180933.png"><br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550225391033-e95f0c13-f1be-4b8e-8b21-686736e93f04.png#align=left&amp;display=inline&amp;height=840&amp;name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190215180822.png&amp;originHeight=840&amp;originWidth=423&amp;size=164845&amp;width=423" alt="微信图片_20190215180822.png"><br>好了，安卓和ios设备现在基本都能上网了。但是pc端还需要一个东西，即chrome的一个插件，<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3dpdGNoeW9tZWdhLmNvbS8=" title="https://www.switchyomega.com/">swithy omega<i class="fa fa-external-link"></i></span>。下载插件添加到chrome完毕，配置如下图：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550225813408-a0996f52-f174-414e-86b0-4587373541ee.png#align=left&amp;display=inline&amp;height=349&amp;name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190215181638.png&amp;originHeight=899&amp;originWidth=1920&amp;size=74173&amp;width=746" alt="微信图片_20190215181638.png"><img src="https://cdn.nlark.com/yuque/0/2019/png/261134/1550225813437-708b1d32-c8d5-4df9-99ac-636e21e35f9b.png#align=left&amp;display=inline&amp;height=349&amp;name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190215181642.png&amp;originHeight=899&amp;originWidth=1920&amp;size=41237&amp;width=746" alt="微信图片_20190215181642.png"></li></ol></li></ol><p>其中的规则列表网址：<span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2dmd2xpc3QvZ2Z3bGlzdC9tYXN0ZXIvZ2Z3bGlzdC50eHQ=" title="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt<i class="fa fa-external-link"></i></span> 详情可以参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dmd2xpc3QvZ2Z3bGlzdA==" title="https://github.com/gfwlist/gfwlist">gfwlist<i class="fa fa-external-link"></i></span></p><p>就是这些，你可以科学上网了。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;为了给我们提供一个&lt;code&gt;安全&lt;/code&gt;的网络环境，所以先驱前辈们建立了一堵墙。总有些&lt;code&gt;调皮&lt;/code&gt;
        
      
    
    </summary>
    
      <category term="工具" scheme="https://blog.dengxf.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="科学上网" scheme="https://blog.dengxf.cn/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>2018年终总结</title>
    <link href="https://blog.dengxf.cn/59ca7e41.html"/>
    <id>https://blog.dengxf.cn/59ca7e41.html</id>
    <published>2018-12-31T08:00:00.000Z</published>
    <updated>2019-05-05T07:10:26.067Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br><strong>又到年底，然而今年并不打算再写年终总结。</strong><br></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p
        
      
    
    </summary>
    
      <category term="生活" scheme="https://blog.dengxf.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="杂谈" scheme="https://blog.dengxf.cn/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
