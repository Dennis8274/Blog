<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
      
    
    
      
    
  <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
  <link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css">







  <meta name="google-site-verification" content="nZuxLdmlM5fb35MBllAK9Fwx_04gKAp_E8qkkXSabwA">







  <meta name="baidu-site-verification" content="5ztlSKyYhT">











  

<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon .png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=6.7.0">


  <link rel="mask-icon" href="/images/dxf.png?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="写在前面 根据源码总的描述，SynchronousQueue是一个阻塞队列，所有的入队出队操作都是阻塞的。根据作者的描述，这个工具的定位是在线程间同步对象，以达到在线程间传递一些信息、事件、或者任务的目的(_They are well suited for handoff designs, in which an object running in one thread must sync up">
<meta name="keywords" content="JDK,源码分析">
<meta property="og:type" content="article">
<meta property="og:title" content="JDK源码阅读之SynchronousQueue">
<meta property="og:url" content="https://blog.dengxf.cn/157f68af.html">
<meta property="og:site_name" content="young driver">
<meta property="og:description" content="写在前面 根据源码总的描述，SynchronousQueue是一个阻塞队列，所有的入队出队操作都是阻塞的。根据作者的描述，这个工具的定位是在线程间同步对象，以达到在线程间传递一些信息、事件、或者任务的目的(_They are well suited for handoff designs, in which an object running in one thread must sync up">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-06-27T09:38:57.502Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JDK源码阅读之SynchronousQueue">
<meta name="twitter:description" content="写在前面 根据源码总的描述，SynchronousQueue是一个阻塞队列，所有的入队出队操作都是阻塞的。根据作者的描述，这个工具的定位是在线程间同步对象，以达到在线程间传递一些信息、事件、或者任务的目的(_They are well suited for handoff designs, in which an object running in one thread must sync up">



  <link rel="alternate" href="/atom.xml" title="young driver" type="application/atom+xml">




  <link rel="canonical" href="https://blog.dengxf.cn/157f68af.html">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>JDK源码阅读之SynchronousQueue | young driver</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">young driver</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">小时候想要找一个喜欢《わがまま☆フェアリー ミルモでポン！》的女朋友</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">5</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">3</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">15</span></a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dengxf.cn/157f68af.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="邓旭峰">
      <meta itemprop="description" content="团结友爱互助">
      <meta itemprop="image" content="/images/dxf.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="young driver">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">JDK源码阅读之SynchronousQueue

              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-26 08:51:04" itemprop="dateCreated datePublished" datetime="2019-05-26T08:51:04+08:00">2019-05-26</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术分享/" itemprop="url" rel="index"><span itemprop="name">技术分享</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <a href="/157f68af.html#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/157f68af.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a name="5nF7T"></a></p>
<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote>
<p>根据源码总的描述，SynchronousQueue是一个阻塞队列，所有的入队出队操作都是阻塞的。根据作者的描述，这个工具的定位是在线程间同步对象，以达到在线程间传递一些信息、事件、或者任务的目的(_They are well suited for handoff designs, in which an object running in one thread must sync up with an object running in another thread in order to hand it some information, event, or )。<br>关于这个工具的描述，作者只介绍了这么多。SynchronousQueue是实现了BlockingQueue，但是有与一般意义上的queue(比如ArrayBlockingQueue)不一样，它内部并没有存放元素的地方。入队阻塞直到出队成功，反之亦然，在线程间同步传递对象，以在线程间同步信息。</p>
</blockquote>
<p><a name="zbM2O"></a></p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>SynchronousQueue内部并没有容纳元素的数据结构，也就是说SynchronousQueue并不存储元素。实现采用了一种无锁算法，扩展的<span class="exturl" data-url="aHR0cDovL3d3dy5jcy5yb2NoZXN0ZXIuZWR1L3Jlc2VhcmNoL3N5bmNocm9uaXphdGlvbi9wc2V1ZG9jb2RlL2R1YWxzLmh0bWw=" title="http://www.cs.rochester.edu/research/synchronization/pseudocode/duals.html">Dual stack and Dual Queue<i class="fa fa-external-link"></i></span>算法，算法的大概实现是采用链表，用头结点(head)和尾结点(tail)记录队列状态，而队列可以根据头尾以及当前节点状态，在不需要锁的情况的执行入出队操作。此外，竞争时，支持公平竞争和非公平竞争。公平竞争实现采用先进先出队列( FIFO queue)；而非公平竞争实现采用先进后出栈(FILO stack)。<br><a name="uuBx9"></a></p>
<h3 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** The number of CPUs, for spin control */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPUS = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxTimedSpins = (NCPUS &lt; <span class="number">2</span>) ? <span class="number">0</span> : <span class="number">32</span></span><br><span class="line">     </span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxUntimedSpins = maxTimedSpins * <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The number of nanoseconds for which it is faster to spin</span></span><br><span class="line"><span class="comment">  * rather than to use timed park. A rough estimate suffices.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;   </span><br><span class="line">     <span class="comment">/** Node represents an unfulfilled consumer */</span></span><br><span class="line">     <span class="comment">// 表示consumer，获取元素的请求</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST    = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">/** Node represents an unfulfilled producer */</span></span><br><span class="line">     <span class="comment">// 表示producer，插入元素的请求</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA       = <span class="number">1</span>;</span><br><span class="line">     <span class="comment">/** Node is fulfilling another unfulfilled DATA or REQUEST */</span></span><br><span class="line">     <span class="comment">// 这个状态就是匹配上了队列中的某一个节点</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FULFILLING = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/** Node class for TransferStacks. */</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SNode</span> </span>&#123;</span><br><span class="line">         <span class="keyword">volatile</span> SNode next;        <span class="comment">// next node in stack</span></span><br><span class="line">         <span class="comment">// 匹配上了某个节点</span></span><br><span class="line">         <span class="keyword">volatile</span> SNode match;       <span class="comment">// the node matched to this</span></span><br><span class="line">         <span class="keyword">volatile</span> Thread waiter;     <span class="comment">// to control park/unpark</span></span><br><span class="line">         Object item;                <span class="comment">// data; or null for REQUESTs</span></span><br><span class="line">         <span class="keyword">int</span> mode;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//...省略其他代码</span></span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Puts or takes an item.</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">     E transfer(E e, boolean timed, long nanos)&#123;</span></span><br><span class="line"><span class="comment">     	// ...</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     //... 省略其他代码</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> static final class TransferQueue&lt;E&gt; extends Transferer&lt;E&gt;&#123;</span></span><br><span class="line"><span class="comment">     static final class QNode &#123;</span></span><br><span class="line"><span class="comment">         volatile QNode next;          // next node in queue</span></span><br><span class="line"><span class="comment">         // 注意区别SNode的item是volatile的</span></span><br><span class="line"><span class="comment">         volatile Object item;         // CAS'ed to or from null</span></span><br><span class="line"><span class="comment">         volatile Thread waiter;       // to control park/unpark</span></span><br><span class="line"><span class="comment">         final boolean isData;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         //...</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     /** Head of queue */</span></span><br><span class="line">     <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode head;</span><br><span class="line">     <span class="comment">/** Tail of queue */</span></span><br><span class="line">     <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode tail;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Reference to a cancelled node that might not yet have been</span></span><br><span class="line"><span class="comment">      * unlinked from queue because it was the last inserted node</span></span><br><span class="line"><span class="comment">      * when it was cancelled.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode cleanMe;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Puts or takes an item.</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">     E transfer(E e, boolean timed, long nanos)&#123;</span></span><br><span class="line"><span class="comment">//...   </span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br></pre></td></tr></table></figure>

<p>没有用于存储队列元素内部变量，并且有表示自旋时间的静态变量。内部有个Transferer抽象类，抽象类只有一个transfer方法。分别有TransferStack和TransferQueue实现了这个类，表示非公平和公平两种模式。<br><a name="6cLh5"></a></p>
<h1 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h1><p>主要逻辑都在这个transfer方法中，包括出入队也都是通过这个方法实现的。<br><a name="1T6Eh"></a></p>
<h3 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element into this queue, waiting if necessary</span></span><br><span class="line"><span class="comment"> * up to the specified wait time for another thread to receive it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 插入元素，阻塞给定时间，直到另一线程接收到插入元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, java.util.concurrent.TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 方法都是一个方法，区别在于第一个参数是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(e, <span class="keyword">true</span>, unit.toNanos(timeout)) != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Thread.interrupted())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="unehW"></a></p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Retrieves and removes the head of this queue, waiting</span></span><br><span class="line"><span class="comment">    * if necessary up to the specified wait time, for another thread</span></span><br><span class="line"><span class="comment">    * to insert it.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 获取和移除队列头部元素，阻塞给定时间，直到另一线程往队列插入元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="comment">// 方法都是一个方法，区别在于第一个参数是否为null</span></span><br><span class="line">       E e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">       <span class="keyword">if</span> (e != <span class="keyword">null</span> || !Thread.interrupted())</span><br><span class="line">           <span class="keyword">return</span> e;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><a name="KY6lj"></a></p>
<h3 id="TransferStack-transfer"><a href="#TransferStack-transfer" class="headerlink" title="TransferStack.transfer"></a>TransferStack.transfer</h3><p>TransferStack是非公平竞争的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * Basic algorithm is to loop trying one of three actions:</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * 1. If apparently empty or already containing nodes of same</span></span><br><span class="line"><span class="comment">           *    mode, try to push node on stack and wait for a match,</span></span><br><span class="line"><span class="comment">           *    returning it, or null if cancelled.</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * 2. If apparently containing node of complementary mode,</span></span><br><span class="line"><span class="comment">           *    try to push a fulfilling node on to stack, match</span></span><br><span class="line"><span class="comment">           *    with corresponding waiting node, pop both from</span></span><br><span class="line"><span class="comment">           *    stack, and return matched item. The matching or</span></span><br><span class="line"><span class="comment">           *    unlinking might not actually be necessary because of</span></span><br><span class="line"><span class="comment">           *    other threads performing action 3:</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * 3. If top of stack already holds another fulfilling node,</span></span><br><span class="line"><span class="comment">           *    help it out by doing its match and/or pop</span></span><br><span class="line"><span class="comment">           *    operations, and then continue. The code for helping</span></span><br><span class="line"><span class="comment">           *    is essentially the same as for fulfilling, except</span></span><br><span class="line"><span class="comment">           *    that it doesn't return the item.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          SNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">          <span class="comment">// 根据第一个参数决定具体是哪一种请求(poll or offer)</span></span><br><span class="line">          <span class="keyword">int</span> mode = (e == <span class="keyword">null</span>) ? REQUEST : DATA;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              SNode h = head;</span><br><span class="line">              <span class="comment">// 队列目前为空 或者 队列中全是同一种类型的节点</span></span><br><span class="line">              <span class="keyword">if</span> (h == <span class="keyword">null</span> || h.mode == mode) &#123;  <span class="comment">// empty or same-mode</span></span><br><span class="line">                  <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) &#123;      <span class="comment">// can't wait</span></span><br><span class="line">                      <span class="comment">// 这种直接返回null</span></span><br><span class="line">                      <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.isCancelled())</span><br><span class="line">                          casHead(h, h.next);     <span class="comment">// pop cancelled node</span></span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                  <span class="comment">// 构造一个节点入队</span></span><br><span class="line">                  <span class="comment">// s.next=h </span></span><br><span class="line">                  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class="line">                      <span class="comment">// 自旋或阻塞等待直到fulfill匹配</span></span><br><span class="line">                      SNode m = awaitFulfill(s, timed, nanos);</span><br><span class="line">                      <span class="comment">// 对于TransferStack，取消(超时)的节点,会赋值match为this</span></span><br><span class="line">                      <span class="comment">// 当match等于自身的时候就是该clean的节点，说明等待足够长时间了</span></span><br><span class="line">                      <span class="keyword">if</span> (m == s) &#123;               <span class="comment">// wait was cancelled</span></span><br><span class="line">                          clean(s);</span><br><span class="line">                          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="comment">// fulfill，匹配</span></span><br><span class="line">                      <span class="comment">// h -&gt; fulfill node ; s -&gt; match node;</span></span><br><span class="line">                      <span class="keyword">if</span> ((h = head) != <span class="keyword">null</span> &amp;&amp; h.next == s)</span><br><span class="line">                          <span class="comment">// s节点出队(或者该说出栈)</span></span><br><span class="line">                          casHead(h, s.next);     <span class="comment">// help s's fulfiller</span></span><br><span class="line">                      <span class="comment">// 如果是consumer的话，那么返回的值该是fulfill节点m的值，否则就是s节点的值</span></span><br><span class="line">                      <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                  &#125;</span><br><span class="line">              <span class="comment">// 那么这里就是fulfill操作了</span></span><br><span class="line">              <span class="comment">// h节点并不是fulfill</span></span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) &#123; <span class="comment">// try to fulfill</span></span><br><span class="line">                  <span class="keyword">if</span> (h.isCancelled())            <span class="comment">// already cancelled</span></span><br><span class="line">                      casHead(h, h.next);         <span class="comment">// pop and retry</span></span><br><span class="line">                  <span class="comment">// 入队一个fulfill节点</span></span><br><span class="line">                  <span class="comment">// s.next = h; h也应该是s的匹配节点</span></span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class="line">                      <span class="comment">// for循环 以防刚好待匹配节点因为时间到了失效了</span></span><br><span class="line">                      <span class="keyword">for</span> (;;) &#123; <span class="comment">// loop until matched or waiters disappear</span></span><br><span class="line">                          SNode m = s.next;       <span class="comment">// m is s's match</span></span><br><span class="line">                          <span class="comment">// 队列中已经没有等待节点</span></span><br><span class="line">                          <span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123;        <span class="comment">// all waiters are gone</span></span><br><span class="line">                              <span class="comment">// 这个时候就不该插fulfill节点了，所以pop刚插的fulfill</span></span><br><span class="line">                              casHead(s, <span class="keyword">null</span>);   <span class="comment">// pop fulfill node</span></span><br><span class="line">                              s = <span class="keyword">null</span>;           <span class="comment">// use new node next time</span></span><br><span class="line">                              <span class="keyword">break</span>;              <span class="comment">// restart main loop</span></span><br><span class="line">                          &#125;</span><br><span class="line">                          SNode mn = m.next;</span><br><span class="line">                          <span class="comment">// 即 m.match = s; unpark(m.thread);</span></span><br><span class="line">                          <span class="keyword">if</span> (m.tryMatch(s)) &#123;</span><br><span class="line">                              casHead(s, mn);     <span class="comment">// pop both s and m</span></span><br><span class="line">                              <span class="comment">// 同上</span></span><br><span class="line">                              <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                          &#125; <span class="keyword">else</span>                  <span class="comment">// lost match</span></span><br><span class="line">                              <span class="comment">// 匹配节点m已经cancel失效，则移除m节点</span></span><br><span class="line">                              s.casNext(m, mn);   <span class="comment">// help unlink</span></span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              <span class="comment">// h节点是fulfill节点，总会有这种情况的出现</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// help a fulfiller</span></span><br><span class="line">                  SNode m = h.next;               <span class="comment">// m is h's match</span></span><br><span class="line">                  <span class="keyword">if</span> (m == <span class="keyword">null</span>)                  <span class="comment">// waiter is gone</span></span><br><span class="line">                      casHead(h, <span class="keyword">null</span>);           <span class="comment">// pop fulfilling node</span></span><br><span class="line">                  <span class="keyword">else</span> &#123;</span><br><span class="line">                      SNode mn = m.next;</span><br><span class="line">                      <span class="keyword">if</span> (m.tryMatch(h))          <span class="comment">// help match</span></span><br><span class="line">                          casHead(h, mn);         <span class="comment">// pop both h and m</span></span><br><span class="line">                      <span class="keyword">else</span>                        <span class="comment">// lost match</span></span><br><span class="line">                          h.casNext(m, mn);       <span class="comment">// help unlink</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个SNode节点</span></span><br><span class="line"><span class="comment">// next一般是h</span></span><br><span class="line">      <span class="function"><span class="keyword">static</span> SNode <span class="title">snode</span><span class="params">(SNode s, Object e, SNode next, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (s == <span class="keyword">null</span>) s = <span class="keyword">new</span> SNode(e);</span><br><span class="line">          s.mode = mode;</span><br><span class="line">          s.next = next;</span><br><span class="line">          <span class="keyword">return</span> s;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spins/blocks until node s is matched by a fulfill operation.</span></span><br><span class="line"><span class="comment">// 自旋，直到fulfill操作匹配节点</span></span><br><span class="line">      <span class="function">SNode <span class="title">awaitFulfill</span><span class="params">(SNode s, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">          Thread w = Thread.currentThread();</span><br><span class="line">          <span class="comment">// 如果s在队列头，或者队列中有一有效的fulfill节点，那么将采用自旋</span></span><br><span class="line">          <span class="keyword">int</span> spins = (shouldSpin(s) ?</span><br><span class="line">                       (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">                  <span class="comment">// SNode.tryCancel：</span></span><br><span class="line">                  <span class="comment">// s.match = s</span></span><br><span class="line">                  s.tryCancel();</span><br><span class="line">              <span class="comment">// 节点s的匹配节点</span></span><br><span class="line">              SNode m = s.match;</span><br><span class="line">              <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">                  <span class="keyword">return</span> m;</span><br><span class="line">              <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                  nanos = deadline - System.nanoTime();</span><br><span class="line">                  <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                      s.tryCancel();</span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 自旋</span></span><br><span class="line">              <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">                  spins = shouldSpin(s) ? (spins-<span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">                  s.waiter = w; <span class="comment">// establish waiter so can park next iter</span></span><br><span class="line">              <span class="comment">// 阻塞</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">                  LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">              <span class="comment">// 给的时间大于阈值才会进入阻塞状态</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">                  LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Returns true if node s is at head or there is an active</span></span><br><span class="line"><span class="comment">       * fulfiller.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">boolean</span> <span class="title">shouldSpin</span><span class="params">(SNode s)</span> </span>&#123;</span><br><span class="line">          SNode h = head;</span><br><span class="line">          <span class="keyword">return</span> (h == s || h == <span class="keyword">null</span> || isFulfilling(h.mode));</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>TransferStack总是先进后出，并不保证公平，甚至在一些极端情况会导致一部分请求总得不到调度。<br>详情：</p>
<ul>
<li>请求到达，如果栈为空，则入栈相对应状态(consumer-&gt;request、producer-&gt;data)节点</li>
<li>如果栈不为空，并且目前节点状态与栈顶结点状态不一致(即并不是都为consumer or producer)，那么入栈一fulfill节点</li>
<li>匹配过程，匹配栈顶结点为fulfill以及后继节点为头结点的match，成功则出栈两节点</li>
<li>最后根据节点状态返回对应的需要同步的数据对象<br><a name="hvuBw"></a><h3 id="TransferQueue-transfer"><a href="#TransferQueue-transfer" class="headerlink" title="TransferQueue.transfer"></a>TransferQueue.transfer</h3>TransferQueue是公平竞争的实现。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">          <span class="comment">/* Basic algorithm is to loop trying to take either of</span></span><br><span class="line"><span class="comment">           * two actions:</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * 1. If queue apparently empty or holding same-mode nodes,</span></span><br><span class="line"><span class="comment">           *    try to add node to queue of waiters, wait to be</span></span><br><span class="line"><span class="comment">           *    fulfilled (or cancelled) and return matching item.</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * 2. If queue apparently contains waiting items, and this</span></span><br><span class="line"><span class="comment">           *    call is of complementary mode, try to fulfill by CAS'ing</span></span><br><span class="line"><span class="comment">           *    item field of waiting node and dequeuing it, and then</span></span><br><span class="line"><span class="comment">           *    returning matching item.</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * In each case, along the way, check for and try to help</span></span><br><span class="line"><span class="comment">           * advance head and tail on behalf of other stalled/slow</span></span><br><span class="line"><span class="comment">           * threads.</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * The loop starts off with a null check guarding against</span></span><br><span class="line"><span class="comment">           * seeing uninitialized head or tail values. This never</span></span><br><span class="line"><span class="comment">           * happens in current SynchronousQueue, but could if</span></span><br><span class="line"><span class="comment">           * callers held non-volatile/final ref to the</span></span><br><span class="line"><span class="comment">           * transferer. The check is here anyway because it places</span></span><br><span class="line"><span class="comment">           * null checks at top of loop, which is usually faster</span></span><br><span class="line"><span class="comment">           * than having them implicitly interspersed.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          QNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">          <span class="keyword">boolean</span> isData = (e != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              QNode t = tail;</span><br><span class="line">              QNode h = head;</span><br><span class="line">              <span class="comment">// 初始化还未完成</span></span><br><span class="line">              <span class="keyword">if</span> (t == <span class="keyword">null</span> || h == <span class="keyword">null</span>)         <span class="comment">// saw uninitialized value</span></span><br><span class="line">                  <span class="keyword">continue</span>;                       <span class="comment">// spin</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">// 队列为空，或当前节点和尾为相同类型节点</span></span><br><span class="line">              <span class="keyword">if</span> (h == t || t.isData == isData) &#123; <span class="comment">// empty or same-mode</span></span><br><span class="line">                  QNode tn = t.next;</span><br><span class="line">                  <span class="comment">// 尾巴变了</span></span><br><span class="line">                  <span class="keyword">if</span> (t != tail)                  <span class="comment">// inconsistent read</span></span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  <span class="comment">// 尾巴变了，但未更新，help一下</span></span><br><span class="line">                  <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;               <span class="comment">// lagging tail</span></span><br><span class="line">                      advanceTail(t, tn);</span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)        <span class="comment">// can't wait</span></span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                      <span class="comment">// 构造节点入队</span></span><br><span class="line">                      s = <span class="keyword">new</span> QNode(e, isData);</span><br><span class="line">                  <span class="keyword">if</span> (!t.casNext(<span class="keyword">null</span>, s))        <span class="comment">// failed to link in</span></span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 入队</span></span><br><span class="line">                  advanceTail(t, s);              <span class="comment">// swing tail and wait</span></span><br><span class="line">                  <span class="comment">// 阻塞等待fulfill</span></span><br><span class="line">                  Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line">                  <span class="comment">// QNode 的item：</span></span><br><span class="line">                  <span class="comment">// 等于this-&gt;cancel;null-&gt;consumer;not null -&gt; producer</span></span><br><span class="line">                  <span class="keyword">if</span> (x == s) &#123;                   <span class="comment">// wait was cancelled</span></span><br><span class="line">                      clean(t, s);</span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// s脱离队列，已不在队列中，这个时候需要重置一下队列</span></span><br><span class="line">                  <span class="keyword">if</span> (!s.isOffList()) &#123;           <span class="comment">// not already unlinked</span></span><br><span class="line">                      advanceHead(t, s);          <span class="comment">// unlink if head</span></span><br><span class="line">                      <span class="keyword">if</span> (x != <span class="keyword">null</span>)              <span class="comment">// and forget fields</span></span><br><span class="line">                          s.item = s;</span><br><span class="line">                      s.waiter = <span class="keyword">null</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 结合下面的else看，在else中会更改s.item</span></span><br><span class="line">                  <span class="comment">// x != null 表示当前为consumer</span></span><br><span class="line">                  <span class="comment">// x == null 表示当前为producer</span></span><br><span class="line">                  <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line"></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// complementary-mode</span></span><br><span class="line">                  <span class="comment">// m为fulfill节点</span></span><br><span class="line">                  QNode m = h.next;               <span class="comment">// node to fulfill</span></span><br><span class="line">                  <span class="comment">// 队列改变，或者fulfill为空则需要retry</span></span><br><span class="line">                  <span class="keyword">if</span> (t != tail || m == <span class="keyword">null</span> || h != head)</span><br><span class="line">                      <span class="keyword">continue</span>;                   <span class="comment">// inconsistent read</span></span><br><span class="line"></span><br><span class="line">                  Object x = m.item;</span><br><span class="line">                  <span class="comment">// m的item已经操作过:m.casItem(x,e)，即already fulfilled</span></span><br><span class="line">                  <span class="keyword">if</span> (isData == (x != <span class="keyword">null</span>) ||    <span class="comment">// m already fulfilled</span></span><br><span class="line">                      <span class="comment">// m节点失效</span></span><br><span class="line">                      x == m ||                   <span class="comment">// m cancelled</span></span><br><span class="line">                      <span class="comment">// 相当于TransferStack的匹配过程，将m.item=e</span></span><br><span class="line">                      <span class="comment">// cas失败，表示others have done，则需要重置头节点retry</span></span><br><span class="line">                      !m.casItem(x, e)) &#123;         <span class="comment">// lost CAS</span></span><br><span class="line">                      advanceHead(h, m);          <span class="comment">// dequeue and retry</span></span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 成功，h出队，head=m</span></span><br><span class="line">                  advanceHead(h, m);              <span class="comment">// successfully fulfilled</span></span><br><span class="line">                  <span class="comment">// 唤醒m节点阻塞线程</span></span><br><span class="line">                  LockSupport.unpark(m.waiter);</span><br><span class="line">                  <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Spins/blocks until node s is fulfilled.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function">Object <span class="title">awaitFulfill</span><span class="params">(QNode s, E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">          <span class="comment">/* Same idea as TransferStack.awaitFulfill */</span></span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">          Thread w = Thread.currentThread();</span><br><span class="line">          <span class="keyword">int</span> spins = ((head.next == s) ?</span><br><span class="line">                       (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">                  <span class="comment">// QNode.tryCancel:</span></span><br><span class="line">                  <span class="comment">// s.item = s</span></span><br><span class="line">                  s.tryCancel(e);</span><br><span class="line">              Object x = s.item;</span><br><span class="line">              <span class="keyword">if</span> (x != e)</span><br><span class="line">                  <span class="keyword">return</span> x;</span><br><span class="line">              <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                  nanos = deadline - System.nanoTime();</span><br><span class="line">                  <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                      s.tryCancel(e);</span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 自旋</span></span><br><span class="line">              <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">                  --spins;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">                  s.waiter = w;</span><br><span class="line">              <span class="comment">// 阻塞</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">                  LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">              <span class="comment">// 同样，需要大于阻塞阈值才会真正阻塞，否则就自旋</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">                  LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>TransferQueue总是FIFO，保证了公平。<br>详情：</p>
<ul>
<li>请求到达，如果队列为空，或者尾节点的类型和当前节点相同（同是consumer或producer），则在队列尾部入队当前节点等待，直到被唤醒</li>
<li>否则头结点出队，唤醒头结点对应线程，返回对应值</li>
</ul>

      
    </div>

    
      


    

    
    
    

    
      <div>
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------The End-------------</div>
    
</div>
      </div>
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JDK/" rel="tag"># JDK</a>
          
            <a href="/tags/源码分析/" rel="tag"># 源码分析</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/77e66558.html" rel="next" title="JDK源码阅读之StampedLock">
                <i class="fa fa-chevron-left"></i> JDK源码阅读之StampedLock
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/f8a3bd88.html" rel="prev" title="JDK源码阅读之LinkedTransferQueue">
                JDK源码阅读之LinkedTransferQueue <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/dxf.png" alt="邓旭峰">
            
              <p class="site-author-name" itemprop="name">邓旭峰</p>
              <p class="site-description motion-element" itemprop="description">团结友爱互助</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Rlbm5pczgyNzQ=" title="GitHub &rarr; https://github.com/Dennis8274"><i class="fa fa-fw fa-github"></i>GitHub</span>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <span class="exturl" data-url="bWFpbHRvOmRlbm5pc2R4ZkBnbWFpbC5jb20=" title="E-Mail &rarr; mailto:dennisdxf@gmail.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</span>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#写在前面"><span class="nav-number">1.</span> <span class="nav-text">写在前面</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#实现原理"><span class="nav-number"></span> <span class="nav-text">实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内部结构"><span class="nav-number">1.</span> <span class="nav-text">内部结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#transfer"><span class="nav-number"></span> <span class="nav-text">transfer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#offer"><span class="nav-number">1.</span> <span class="nav-text">offer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poll"><span class="nav-number">2.</span> <span class="nav-text">poll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TransferStack-transfer"><span class="nav-number">3.</span> <span class="nav-text">TransferStack.transfer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TransferQueue-transfer"><span class="nav-number">4.</span> <span class="nav-text">TransferQueue.transfer</span></a></li></ol></li></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">邓旭峰</span>

  

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>

  
  <script src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>

  
  <script src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'TTQ8VRPngUbtEIBsm3hiuo73-gzGzoHsz',
    appKey: 'eRXYHfCrk7gPGvyzHYa8eqbz',
    placeholder: '长得好看的人，说话都好听。',
    avatar: 'wavatar',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false
  });
</script>




  


  

  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('5');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  
  <script src="/js/src/exturl.js?v=6.7.0"></script>


  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function(i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap');
      $(e).after($wrap);
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
        var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
          return $(e).text();
        }).toArray().join('\n');
        var ta = document.createElement('textarea');
        var range = document.createRange(); //For Chrome
        var sel = window.getSelection(); //For Chrome
        var yPosition = window.pageYOffset || document.documentElement.scrollTop;
        ta.style.top = yPosition + 'px'; //Prevent page scroll
        ta.style.position = 'absolute';
        ta.style.opacity = '0';
        ta.value = code;
        ta.textContent = code; //For FireFox
        ta.contentEditable = true;
        ta.readOnly = false;
        document.body.appendChild(ta);
        range.selectNode(ta);
        sel.removeAllRanges();
        sel.addRange(range);
        ta.setSelectionRange(0, code.length);
        var result = document.execCommand('copy');
        
          if (result) $(this).text('复制成功');
          else $(this).text('复制失败');
        
        ta.blur(); //For iOS
        $(this).blur();
      })).on('mouseleave', function(e) {
        var $b = $(this).find('.copy-btn');
        setTimeout(function() {
          $b.text('复制');
        }, 300);
      }).append(e);
    })
  </script>


  

</body>
</html>
